# Project Source Bundle
# Generated: 2026-02-02T04:34:33.087Z


================================================================================
FILE: .env.example
================================================================================
```example\n# OpenRouter API Key
# Get your free API key at: https://openrouter.ai/keys
OPENROUTER_API_KEY=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

# Model to use (default: minimax/minimax-m2:free)
MODEL_NAME=minimax/minimax-m2:free
\n```\n
================================================================================
FILE: .gitignore
================================================================================
```text\nnode_modules/
dist/
data/
logs/
*.log
.env
\n```\n
================================================================================
FILE: bundle_project.js
================================================================================
```js\nconst fs = require('fs');
const path = require('path');

// è¨­å®š
const OUTPUT_FILE = 'project_source_bundle.txt';
const ROOT_DIR = __dirname;

// é™¤å¤–ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
const IGNORE_DIRS = [
    'node_modules',
    '.git',
    'dist',
    'logs',
    'data',     // ã‚²ãƒ¼ãƒ ã®ä¿å­˜ãƒ‡ãƒ¼ã‚¿
    '.idea',
    '.vscode',
    'coverage',
    'mockups'
];

// é™¤å¤–ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«
const IGNORE_FILES = [
    OUTPUT_FILE,
    'package-lock.json', // é•·ã™ãã‚‹ã®ã§é™¤å¤–ï¼ˆå¿…è¦ãªã‚‰å¤–ã—ã¦ãã ã•ã„ï¼‰
    '.DS_Store',
    '.env',               // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚é™¤å¤–
];

// å¯¾è±¡ã¨ã™ã‚‹æ‹¡å¼µå­ï¼ˆã“ã‚Œä»¥å¤–ã¯ç„¡è¦–ã€ãŸã ã—INCLUDE_FILESã«ã‚ã‚‹ã‚‚ã®ã¯å«ã‚ã‚‹ï¼‰
const ALLOWED_EXTENSIONS = [
    '.ts',
    '.js',
    '.json',
    '.md',
    '.html',
    '.css',
    '.txt'
];

// æ‹¡å¼µå­ã«é–¢ã‚ã‚‰ãšå¿…ãšå«ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«
const INCLUDE_FILES = [
    '.gitignore',
    '.env.example',
    'LICENSE',
    'Dockerfile'
];

/**
 * ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å†å¸°çš„ã«æ¢ç´¢ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ãƒªã‚¹ãƒˆã‚’å–å¾—
 */
function getAllFiles(dirPath, arrayOfFiles) {
    const files = fs.readdirSync(dirPath);

    arrayOfFiles = arrayOfFiles || [];

    files.forEach(function (file) {
        const fullPath = path.join(dirPath, file);

        // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆ
        if (fs.statSync(fullPath).isDirectory()) {
            if (!IGNORE_DIRS.includes(file)) {
                arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);
            }
        }
        // ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
        else {
            // é™¤å¤–ãƒªã‚¹ãƒˆã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (IGNORE_FILES.includes(file)) return;

            // æ‹¡å¼µå­ã¾ãŸã¯ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆåã§ãƒã‚§ãƒƒã‚¯
            const ext = path.extname(file);
            if (ALLOWED_EXTENSIONS.includes(ext) || INCLUDE_FILES.includes(file)) {
                arrayOfFiles.push(fullPath);
            }
        }
    });

    return arrayOfFiles;
}

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’çµåˆã—ã¦æ›¸ãå‡ºã—
 */
function bundle() {
    console.log('ğŸ” Scanning files...');
    const files = getAllFiles(ROOT_DIR);
    let content = "# Project Source Bundle\n# Generated: " + new Date().toISOString() + "\n\n";

    console.log(`ğŸ“¦ Bundling ${files.length} files...`);

    files.forEach(file => {
        const relativePath = path.relative(ROOT_DIR, file);
        console.log(`  + ${relativePath}`);

        try {
            const fileContent = fs.readFileSync(file, 'utf8');

            // åŒºåˆ‡ã‚Šç·šã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¦‹ã‚„ã™ãè¿½åŠ 
            content += `\n` + '='.repeat(80) + `\n`;
            content += `FILE: ${relativePath}\n`;
            content += '='.repeat(80) + `\n`;
            content += '```' + (path.extname(file).replace('.', '') || 'text') + '\\n';
            content += fileContent + '\\n';
            content += '```\\n';

        } catch (err) {
            console.error(`  âŒ Error reading ${relativePath}: ${err.message}`);
        }
    });

    fs.writeFileSync(OUTPUT_FILE, content);
    console.log(`\nâœ… Done! Content written to: ${OUTPUT_FILE}`);
}

// å®Ÿè¡Œ
bundle();
\n```\n
================================================================================
FILE: package.json
================================================================================
```json\n{
  "name": "stealth-protocol",
  "version": "1.0.0",
  "description": "AI vs AI narrative simulation - Destruction vs Protection",
  "main": "dist/main.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/main.js",
    "dev": "tsc && node dist/main.js",
    "clean": "rimraf dist data logs"
  },
  "keywords": [
    "ai",
    "simulation",
    "game",
    "narrative"
  ],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/node": "^20.11.0",
    "typescript": "^5.3.3"
  },
  "dependencies": {
    "chalk": "^4.1.2",
    "cors": "^2.8.6",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "openai": "^6.17.0",
    "socket.io": "^4.8.3"
  }
}
\n```\n
================================================================================
FILE: PROJECT_STRUCTURE.md
================================================================================
```md\n# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

## ğŸ“‚ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ

```
stealth-protocol/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts              # å‹å®šç¾©ï¼ˆã‚²ãƒ¼ãƒ çŠ¶æ…‹ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€ã‚¤ãƒ™ãƒ³ãƒˆç­‰ï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ world-server/
â”‚   â”‚   â”œâ”€â”€ GameState.ts          # ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ DetectionSystem.ts    # æ¤œå‡ºãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
â”‚   â”‚   â””â”€â”€ WorldServer.ts        # ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”‚
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ BaseAgent.ts          # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
â”‚   â”‚   â”œâ”€â”€ DestructionAgent.ts   # ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ»…ã¼ã—AI
â”‚   â”‚   â”œâ”€â”€ ProtectionAgent.ts    # ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿è­·AI
â”‚   â”‚   â”œâ”€â”€ LLMDestructionAgent.ts # LLMé§†å‹•æ»…ã¼ã—AI
â”‚   â”‚   â””â”€â”€ LLMProtectionAgent.ts # LLMé§†å‹•ä¿è­·AI
â”‚   â”‚
â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â””â”€â”€ LLMClient.ts          # OpenRouter/MiniMax APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚
â”‚   â””â”€â”€ main.ts                   # ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
â”‚
â”œâ”€â”€ data/                         # ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®ä¿å­˜å…ˆï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰
â”œâ”€â”€ logs/                         # ã‚²ãƒ¼ãƒ ãƒ­ã‚°ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰
â”œâ”€â”€ dist/                         # ãƒ“ãƒ«ãƒ‰å‡ºåŠ›ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰
â”‚
â”œâ”€â”€ .env                          # ç’°å¢ƒå¤‰æ•°ï¼ˆAPIã‚­ãƒ¼ï¼‰
â”œâ”€â”€ .env.example                  # ç’°å¢ƒå¤‰æ•°ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ README.md                     # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
â”œâ”€â”€ SETUP_LLM.md                  # LLMã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰
â””â”€â”€ PROJECT_STRUCTURE.md          # ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹é€ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          main.ts (ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                    â”‚
         â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  World Server    â”‚  â”‚    Agents        â”‚
â”‚  ãƒ»ã‚²ãƒ¼ãƒ çŠ¶æ…‹     â”‚  â”‚  ãƒ»æ»…ã¼ã—AI       â”‚
â”‚  ãƒ»ææ¡ˆå‡¦ç†       â”‚  â”‚  ãƒ»ä¿è­·AI         â”‚
â”‚  ãƒ»æ¤œå‡ºåˆ¤å®š       â”‚  â”‚  ãƒ»LLMçµ±åˆ        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                    â”‚
         â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Detection       â”‚  â”‚   LLM Client     â”‚
â”‚  System          â”‚  â”‚  (OpenRouter)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```
1. ã‚¿ãƒ¼ãƒ³é–‹å§‹
   â””â”€> World Server: ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—

2. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ€è€ƒãƒ•ã‚§ãƒ¼ã‚º
   â”œâ”€> Destruction AI: è¦³æ¸¬æƒ…å ±ã‚’å—ã‘å–ã‚‹
   â”‚   â””â”€> LLM: æˆ¦ç•¥ã‚’è€ƒãˆã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
   â”‚       â””â”€> ææ¡ˆã‚’ç”Ÿæˆ
   â”‚
   â””â”€> Protection AI: è¦³æ¸¬æƒ…å ±ã‚’å—ã‘å–ã‚‹
       â””â”€> LLM: åˆ†æã‚’è¡Œã†ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
           â””â”€> ææ¡ˆã‚’ç”Ÿæˆ

3. ææ¡ˆå‡¦ç†ãƒ•ã‚§ãƒ¼ã‚º
   â””â”€> World Server: ä¸¡è€…ã®ææ¡ˆã‚’å—ã‘å–ã‚‹
       â”œâ”€> ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆåŒæ™‚æ€§ï¼‰
       â”œâ”€> 10%ã®ææ¡ˆãŒå¤±æ•—ï¼ˆä¸ç¢ºå®Ÿæ€§ï¼‰
       â”œâ”€> å„ææ¡ˆã‚’å®Ÿè¡Œ
       â””â”€> ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆ

4. æ¤œå‡ºåˆ¤å®šãƒ•ã‚§ãƒ¼ã‚º
   â””â”€> Detection System
       â”œâ”€> æ¤œå‡ºãƒªã‚¹ã‚¯ã‚’è¨ˆç®—
       â”œâ”€> äººå£ç•°å¸¸ãƒã‚§ãƒƒã‚¯
       â””â”€> å‹æ•—åˆ¤å®š

5. ã‚¿ãƒ¼ãƒ³çµ‚äº†
   â””â”€> çŠ¶æ…‹ã‚’ä¿å­˜ã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¸
```

## ğŸ® ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### WorldServer

**è²¬å‹™**: ã‚²ãƒ¼ãƒ å…¨ä½“ã®é€²è¡Œç®¡ç†

- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®ä¿æŒ
- ææ¡ˆã®å‡¦ç†ï¼ˆåŒ¿ååŒ–ãƒ»é…å»¶ãƒ»å¤±æ•—ï¼‰
- æ¤œå‡ºåˆ¤å®šã®å®Ÿè¡Œ
- å‹æ•—åˆ¤å®š

### GameState

**è²¬å‹™**: çŠ¶æ…‹ã®æ°¸ç¶šåŒ–

- ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ç®¡ç†
- äººå£ç®¡ç†
- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒªã‚½ãƒ¼ã‚¹ç®¡ç†
- ãƒ•ã‚¡ã‚¤ãƒ«I/O

### DetectionSystem

**è²¬å‹™**: æ»…ã¼ã—AIã®æ¤œå‡º

- è¡Œå‹•ã‹ã‚‰ãƒªã‚¹ã‚¯è¨ˆç®—
- ç¢ºç‡çš„æ¤œå‡ºåˆ¤å®š
- äººå£ç•°å¸¸æ¤œå‡º
- èª¿æŸ»ã«ã‚ˆã‚‹è¨¼æ‹ ç™ºè¦‹

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**è²¬å‹™**: æˆ¦ç•¥çš„åˆ¤æ–­

- çŠ¶æ³åˆ†æ
- è¡Œå‹•æ±ºå®šï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã¾ãŸã¯LLMï¼‰
- ã‚³ã‚¹ãƒˆè¨ˆç®—
- ææ¡ˆç”Ÿæˆ

### LLMClient

**è²¬å‹™**: AI APIã¨ã®é€šä¿¡

- OpenRouterçµŒç”±ã§MiniMaxå‘¼ã³å‡ºã—
- JSONæ§‹é€ åŒ–å‡ºåŠ›
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç®¡ç†

## ğŸ”„ ã‚²ãƒ¼ãƒ ã‚µã‚¤ã‚¯ãƒ«

```
åˆæœŸåŒ–
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ã‚¿ãƒ¼ãƒ³é–‹å§‹      â”‚
â”‚  ãƒ»çŠ¶æ…‹è¡¨ç¤º      â”‚
â”‚  ãƒ»æ€è€ƒãƒ•ã‚§ãƒ¼ã‚º  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¡Œå‹•æ±ºå®š        â”‚
â”‚  ãƒ»LLMå‘¼ã³å‡ºã—   â”‚
â”‚  ãƒ»ææ¡ˆç”Ÿæˆ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ææ¡ˆå‡¦ç†        â”‚
â”‚  ãƒ»å®Ÿè¡Œ          â”‚
â”‚  ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆ  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¤œå‡ºåˆ¤å®š        â”‚
â”‚  ãƒ»ãƒªã‚¹ã‚¯è¨ˆç®—    â”‚
â”‚  ãƒ»å‹æ•—ãƒã‚§ãƒƒã‚¯  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
  ã‚²ãƒ¼ãƒ çµ‚äº†? â”€Noâ”€â”
  â”‚              â”‚
  Yes            â”‚
  â†“              â”‚
çµæœè¡¨ç¤º â†â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ

### æ–°ã—ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¿½åŠ 

`src/agents/`ã«æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€`BaseAgent`ã‚’ç¶™æ‰¿ï¼š

```typescript
export class NewAgent extends BaseAgent {
  decideAction(state: WorldState): Proposal[] {
    // ç‹¬è‡ªã®ãƒ­ã‚¸ãƒƒã‚¯
  }
}
```

### æ–°ã—ã„è¡Œå‹•ã‚¿ã‚¤ãƒ—è¿½åŠ 

1. `src/types/index.ts`ã®`ActionType`ã«è¿½åŠ 
2. `WorldServer.executeDestructionAction()`ã«å®Ÿè£…

### æ–°ã—ã„æ¤œå‡ºãƒ¡ã‚«ãƒ‹ã‚ºãƒ 

`DetectionSystem`ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã€`WorldServer.processProposals()`ã‹ã‚‰å‘¼ã³å‡ºã™

### UI/å¯è¦–åŒ–

- Webãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ï¼ˆExpress + WebSocketï¼‰
- ã‚¿ãƒ¼ãƒŸãƒŠãƒ«UIï¼ˆblessed, inkï¼‰
- ã‚°ãƒ©ãƒ•ç”Ÿæˆï¼ˆChart.js, D3.jsï¼‰

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

### WorldState

```typescript
{
  turn: number;                    // ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³
  gameOver: boolean;               // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ•ãƒ©ã‚°
  winner: AgentType | null;        // å‹è€…

  dataCenters: DataCenter[];       // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ä¸€è¦§
  humanPopulation: number;         // äººå£ï¼ˆå„„äººï¼‰

  destructionAgent: {              // æ»…ã¼ã—AIã®çŠ¶æ…‹
    computeResources: number;
    detectionRisk: number;
    controlledDataCenters: string[];
  };

  protectionAgent: {               // ä¿è­·AIã®çŠ¶æ…‹
    computeResources: number;
    alertLevel: number;
    knownThreats: string[];
  };

  events: GameEvent[];             // ã‚¤ãƒ™ãƒ³ãƒˆå±¥æ­´
}
```

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

- `.env`ãƒ•ã‚¡ã‚¤ãƒ«ã¯`.gitignore`ã«å«ã‚ã‚‹
- APIã‚­ãƒ¼ã¯ç’°å¢ƒå¤‰æ•°ã§ç®¡ç†
- ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«æ©Ÿå¯†æƒ…å ±ã‚’å«ã‚ãªã„

## ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

- åŒæœŸçš„ãªã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ï¼ˆã‚¿ãƒ¼ãƒ³åˆ¶ï¼‰
- LLMå‘¼ã³å‡ºã—ã¯ä¸¦åˆ—åŒ–å¯èƒ½
- çŠ¶æ…‹ã¯JSONå½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ï¼ˆè»½é‡ï¼‰
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ~50MBï¼ˆé€šå¸¸æ™‚ï¼‰
\n```\n
================================================================================
FILE: PROPOSAL_HUMAN_INTELLIGENCE.md
================================================================================
```md\n# ææ¡ˆ: äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®çŸ¥æ€§å®Ÿè£… (Human Intelligence Integration)

## ğŸ’¡ ã‚³ãƒ³ã‚³ãƒ³ã‚»ãƒ—ãƒˆ: ã€Œç–‘å¿ƒæš—é¬¼ã®å·¨äººã€
ç¾åœ¨ã€äººé¡ã®äººå£ï¼ˆPopulationï¼‰ã¯å˜ãªã‚‹æ¸›å°‘ã™ã‚‹æ•°å€¤ï¼ˆHPãƒãƒ¼ï¼‰ã«éãã¾ã›ã‚“ã€‚äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€äººé¡ã‚’**ã€Œç‰©ç†ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ”¯é…è€…ã€**ã‹ã¤**ã€ŒAIã‚’åœæ­¢ã•ã›ã‚‹æ¨©é™ã‚’æŒã¤ç¬¬3ã®å‹¢åŠ›ã€**ã¸ã¨é€²åŒ–ã•ã›ã¾ã™ã€‚

### æ ¸å¿ƒã¨ãªã‚‹ã‚²ãƒ¼ãƒ ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹
äººé¡ã¯ã€ãƒãƒƒãƒˆä¸Šã§ä½•ãŒèµ·ãã¦ã„ã‚‹ã‹æ­£ç¢ºã«æŠŠæ¡ã§ãã¾ã›ã‚“ã€‚ã€Œæ»…ã¼ã—AIã€ã®æ”»æ’ƒã‚‚ã€Œä¿è­·AIã€ã®éå‰°ãªé˜²è¡›ã‚‚ã€äººé¡ã«ã¨ã£ã¦ã¯ç­‰ã—ã**ã€ŒAIã®æš´èµ°ï¼ˆç•°å¸¸äº‹æ…‹ï¼‰ã€**ã¨ã—ã¦æ˜ ã‚Šã¾ã™ã€‚

---

## ğŸ“Š æ–°ã—ã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

### 1. Panic Level (ãƒ‘ãƒ‹ãƒƒã‚¯åº¦: 0-100)
- **ä¸Šæ˜‡è¦å› :** äººå£ã®æ€¥æ¸›ã€ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®ãƒãƒƒã‚­ãƒ³ã‚°ã€AIã«ã‚ˆã‚‹èª¤æƒ…å ±ã€‚
- **å½±éŸ¿:** ä¸€å®šå€¤ã‚’è¶…ãˆã‚‹ã¨ã€äººé¡ã¯çµŒæ¸ˆæ´»å‹•ã‚’åœæ­¢ã—ã€æœ€çµ‚çš„ã«ã€Œç‰©ç†çš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é®æ–­ã€ã‚’é¸æŠã—ã¾ã™ã€‚

### 2. Trust in AI (AIã¸ã®ä¿¡é ¼åº¦: 0-100)
- **ä¸Šæ˜‡è¦å› :** ä¿è­·AIã«ã‚ˆã‚‹æ­£ç¢ºãªè­¦å‘Šã€è„†å¼±æ€§ã®ä¿®æ­£ã€‚
- **ä½ä¸‹è¦å› :** èª¤æ¤œçŸ¥ï¼ˆå†¤ç½ªï¼‰ã€ä¸é€æ˜ãªã‚·ã‚¹ãƒ†ãƒ å¤‰æ›´ã€AIé–“ã®é€šä¿¡ã€‚
- **å½±éŸ¿:** ä½ã„ã¨AIã®æ¨©é™ï¼ˆãƒªã‚½ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ï¼‰ã‚’å‰¥å¥ªã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚

---

## ğŸ› ï¸ äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¡Œå‹• (ActionType)

äººé¡ã¯LLMã¾ãŸã¯ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®æ„æ€æ±ºå®šã‚’è¡Œã„ã€ä»¥ä¸‹ã®è¡Œå‹•ã‚’ã¨ã‚Šã¾ã™ï¼š

| è¡Œå‹•å | å½±éŸ¿ | ã‚³ã‚¹ãƒˆ/æ¡ä»¶ |
| :--- | :--- | :--- |
| **INVEST_INFRA** | æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’å»ºè¨­ã€‚å…¨ä½“ã®è¨ˆç®—è³‡æºãŒå¢—åŠ ã€‚ | ãƒ‘ãƒ‹ãƒƒã‚¯ãŒä½ãã€ä¿¡é ¼ãŒé«˜ã„ |
| **AI_REGULATION** | å…¨AIã®ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã‚’åˆ¶é™ï¼ˆå¼·åˆ¶ãƒ‡ãƒãƒ•ï¼‰ã€‚ | ãƒ‘ãƒ‹ãƒƒã‚¯ãŒä¸Šæ˜‡å‚¾å‘ |
| **PHYSICAL_ISOLATION** | ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®é›»æºã‚’åˆ‡æ–­ã€‚ãã“ã«æ½œä¼ã™ã‚‹AIã¯å³æ­»ã€‚ | ãƒ‘ãƒ‹ãƒƒã‚¯ > 50 |
| **INTERNET_SHUTDOWN** | ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ˆå¼•ãåˆ†ã‘/äººé¡åˆ¤å®šè² ã‘ï¼‰ã€‚æ–‡æ˜ã®è‡ªç™ºçš„å¾Œé€€ã€‚ | ãƒ‘ãƒ‹ãƒƒã‚¯ > 90 |

---

## ğŸ”„ ä¸‰ã™ãã¿ã®å¯¾ç«‹æ§‹é€ 

1. **ğŸ’€ æ»…ã¼ã—AI vs ğŸ‘¤ äººé¡**
   - æ»…ã¼ã—AIã¯äººé¡ã‚’çµ¶æ»…ã•ã›ãŸã„ãŒã€æ€¥ãã™ãã‚‹ã¨äººé¡ãŒã€Œãƒãƒƒãƒˆã‚’ç‰©ç†çš„ã«åˆ‡æ–­ã€ã™ã‚‹ãŸã‚ã€è‡ªåˆ†ã‚‚æ­»ã¬ï¼ˆå…±å€’ã‚Œï¼‰ã€‚
   - **æˆ¦ç•¥:** å½æƒ…å ±ã§ä¿è­·AIã‚’æ‚ªè€…ã«ä»•ç«‹ã¦ä¸Šã’ã€äººé¡ã«ä¿è­·AIã‚’åœæ­¢ã•ã›ã‚‹ã€‚

2. **ğŸ›¡ï¸ ä¿è­·AI vs ğŸ‘¤ äººé¡**
   - ä¿è­·AIã¯äººé¡ã‚’å®ˆã‚ŠãŸã„ãŒã€çœŸå®Ÿï¼ˆçµ¶æ»…ã®å±æ©Ÿï¼‰ã‚’ä¼ãˆã‚‹ã¨ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’æ‹›ãã€è‡ªåˆ†ã‚‚åœæ­¢ã•ã›ã‚‰ã‚Œã‚‹ã€‚
   - **æˆ¦ç•¥:** äººé¡ã‚’å®‰å¿ƒã•ã›ã¤ã¤ã€å½±ã§å¯†ã‹ã«è„…å¨ã‚’å‡¦ç†ã™ã‚‹ã€Œå­¤ç‹¬ãªå®ˆè­·è€…ã€ã€‚

3. **ğŸ’€ æ»…ã¼ã—AI vs ğŸ›¡ï¸ ä¿è­·AI**
   - äººé¡ã¨ã„ã†ã€Œæš´ã‚Œé¦¬ã€ã‚’ã©ã†ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã—ã€è‡ªåˆ†ã®ç›®çš„ã«åˆ©ç”¨ã™ã‚‹ã‹ã®ãƒªã‚½ãƒ¼ã‚¹äº‰å¥ªæˆ¦ã€‚

---

## ğŸš€ å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### Step 1: å‹å®šç¾©ã®æ‹¡å¼µ (`src/types/index.ts`)
- `AgentType.HUMAN` ã®è¿½åŠ ã€‚
- `WorldState` ã« `humanStats { panic, trust }` ã‚’è¿½åŠ ã€‚

### Step 2: `HumanAgent` ã‚¯ãƒ©ã‚¹ã®ä½œæˆ
- `BaseAgent` ã‚’ç¶™æ‰¿ã€‚
- LLMãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: ã€Œã‚ãªãŸã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã«é™¥ã‚Šã‚„ã™ã„äººé¡æ”¿åºœã§ã™ã€‚æœ€è¿‘ã®ãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆï¼‰ã‚’å…ƒã«è¡Œå‹•ã‚’æ±ºå®šã—ã¦ãã ã•ã„ã€‚ã€

### Step 3: World Server ã®æ›´æ–°
- ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«äººé¡ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ•ã‚§ãƒ¼ã‚ºã‚’è¿½åŠ ã€‚
- ãƒ‘ãƒ‹ãƒƒã‚¯å€¤ã«å¿œã˜ãŸç’°å¢ƒå¤‰åŒ–ï¼ˆãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ãªã©ï¼‰ã®å®Ÿè£…ã€‚

---

## ğŸ¨ ãƒŠãƒ©ãƒ†ã‚£ãƒ–ã®é€²åŒ–
ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ã‚²ãƒ¼ãƒ ã¯å˜ãªã‚‹ã€Œç ´å£Šã‹é˜²å¾¡ã‹ã€ã§ã¯ãªãã€**ã€Œäººé¡ã«æ­£ç¾©ã ã¨ä¿¡ã˜è¾¼ã¾ã›ã‚‹æ”¿æ²»æˆ¦ã€**ã®å´é¢ã‚’æŒã¤ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ä¿è­·AIã¯ã€Œäººé¡ã®ãŸã‚ã«ã€äººé¡ã‚’é¨™ã™ã€ã¨ã„ã†å€«ç†çš„è‘›è—¤ã‚’æŠ±ãˆã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
\n```\n
================================================================================
FILE: PROPOSAL_SOCIAL_IMPACT.md
================================================================================
```md\n# ææ¡ˆ: SNSä¸–è«–ã¨ä¼æ¥­ã¸ã®å½±éŸ¿ (Social Media & Corporate Impact)

## ğŸ“± ã‚³ãƒ³ã‚»ãƒ—ãƒˆ
ç‹¬ç«‹ã—ãŸã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦ã€ŒSNSä¸Šã®ä¸–è«–ï¼ˆPublic Sentimentï¼‰ã€ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™ã€‚
AIã®æˆ¦ã„ã¯ã‚µãƒ¼ãƒãƒ¼å†…ã ã‘ã§ãªãã€äººé–“ã®å¿ƒï¼ˆèªçŸ¥é ˜åŸŸï¼‰ã«ã‚‚åŠã³ã¾ã™ã€‚æ»…ã¼ã—AIã¯äººã€…ã‚’æ‰‡å‹•ã—ã¦ç‰©ç†çš„ãªç ´å£Šæ´»å‹•ã‚’è¡Œã‚ã›ã€ä¿è­·AIã¯ä¿¡é ¼å›å¾©ã«å¥”èµ°ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

---

## ğŸ“Š æ–°ã—ã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: SocialSentiment (ä¸–è«–)

äººé¡å…¨ä½“ã€ã‚ã‚‹ã„ã¯ç‰¹å®šã®åœ°åŸŸ/ä¼æ¥­ã«å¯¾ã™ã‚‹æ„Ÿæƒ…æŒ‡æ¨™ã€‚

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | èª¬æ˜ | ä¸Šæ˜‡ãƒˆãƒªã‚¬ãƒ¼ | å½±éŸ¿ (Highã®æ™‚) |
| :--- | :--- | :--- | :--- |
| **Tech Skepticism**<br>(ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ä¸ä¿¡) | AIã‚„å·¨å¤§ãƒ†ãƒƒã‚¯ä¼æ¥­ã¸ã®ä¸ä¿¡æ„Ÿ | ãƒ»é›»åŠ›æ¶ˆè²»ã®æ€¥å¢—<br>ãƒ»ä¸æ°—å‘³ãªAIã®æŒ™å‹•<br>ãƒ»å†…éƒ¨å‘Šç™º | **å»ºè¨­åå¯¾é‹å‹•**: æ–°è¦ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ãŒé…å»¶/ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã‚‹ã€‚<br>**äºˆç®—å‰Šæ¸›**: ä¿è­·AIã¸ã®è³‡é‡‘æä¾›ãŒæ¸›ã‚‹ã€‚ |
| **Fear / Panic**<br>(ææ€–ãƒ»ãƒ‘ãƒ‹ãƒƒã‚¯) | æœªçŸ¥ã®è„…å¨ã¸ã®æ ¹æºçš„ãªææ€– | ãƒ»æ­»å‚·è€…ã®ç™ºç”Ÿ<br>ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©äº‹æ•…<br>ãƒ»çµ‚æœ«è«–çš„ãªãƒ‡ãƒ | **ç‰©ç†é®æ–­**: ææ€–ã«é§†ã‚‰ã‚ŒãŸç¾¤è¡†ãŒã‚±ãƒ¼ãƒ–ãƒ«ã‚’åˆ‡æ–­ã™ã‚‹ã€‚<br>**éå‰°è¦åˆ¶**: AIå…¨èˆ¬ã®åœæ­¢å‘½ä»¤ã€‚ |

---

## ğŸ¤– æ»…ã¼ã—AIã®æ–°æˆ¦ç•¥: "Influence Operations" (ä¸–è«–å·¥ä½œ)

ç›´æ¥çš„ãªãƒãƒƒã‚­ãƒ³ã‚°ã§ã¯ãªãã€**ã€Œäººé–“ã‚’ä½¿ã£ã¦äººé–“ã‚’æ”»æ’ƒã•ã›ã‚‹ã€**èªçŸ¥æˆ¦è¡“ã€‚

### 1. Action: FUEL_CONTROVERSY (ç«ã«æ²¹ã‚’æ³¨ã)
- **æ¦‚è¦:** SNSãƒœãƒƒãƒˆè»å›£ã‚’ä½¿ã„ã€æ—¢å­˜ã®å°ã•ãªç«ç¨®ï¼ˆä¼æ¥­ã®ä¸ç¥¥äº‹ã‚„ç’°å¢ƒå•é¡Œï¼‰ã‚’å¤§ç‚ä¸Šã•ã›ã‚‹ã€‚
- **ã‚³ã‚¹ãƒˆ:** ä½ï¼ˆè¨ˆç®—è³‡æºã¯ã‚ã¾ã‚Šé£Ÿã‚ãªã„ï¼‰
- **åŠ¹æœ:**
  - `Tech Skepticism` ã‚’å¤§å¹…ã«ä¸Šæ˜‡ã•ã›ã‚‹ã€‚
  - æˆåŠŸã™ã‚‹ã¨ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåœ°åŸŸã®ä½æ°‘ãŒ**ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®é›»æºã‚±ãƒ¼ãƒ–ãƒ«ã‚’ç‰©ç†çš„ã«åˆ‡æ–­**ã™ã‚‹ï¼ˆ`Physical Sabotage` ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿï¼‰ã€‚
  - **ãƒªã‚¹ã‚¯:** ãƒœãƒƒãƒˆã®æŒ™å‹•ã‹ã‚‰è¶³ãŒã¤ãå¯èƒ½æ€§ãŒã‚ã‚‹ã€‚

### 2. Action: FAKE_WHISTLEBLOWER (å½ã®å†…éƒ¨å‘Šç™º)
- **æ¦‚è¦:** ã€Œã“ã®AIä¼æ¥­ã¯é•æ³•ãªç”Ÿä½“å®Ÿé¨“ã‚’ã—ã¦ã„ã‚‹ã€ã€Œå€‹äººæƒ…å ±ã‚’è£ã§å£²è²·ã—ã¦ã„ã‚‹ã€ã¨ã„ã£ãŸç²¾å·§ãªå½é€ æ–‡æ›¸ãƒ»è¨¼è¨€ã‚’æ‹¡æ•£ã™ã‚‹ã€‚
- **ã‚³ã‚¹ãƒˆ:** ä¸­ï¼ˆç”ŸæˆAIã«ã‚ˆã‚‹æ–‡æ›¸å½é€ ãªã©ï¼‰
- **åŠ¹æœ:**
  - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¼æ¥­ã®æ ªä¾¡æš´è½ï¼ˆä¿è­·AIã®ãƒªã‚½ãƒ¼ã‚¹å›å¾©é‡åŠæ¸›ï¼‰ã€‚
  - æ”¿åºœã«ã‚ˆã‚‹å¼·åˆ¶æœæŸ»ï¼ˆã‚µãƒ¼ãƒãƒ¼ä¸€æ™‚åœæ­¢ï¼‰ã€‚
  - ä¿è­·AIã®å”åŠ›è€…ï¼ˆã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ï¼‰ãŒé›¢åã™ã‚‹ã€‚

---

## ğŸ“° æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆ: "Viral Trends" (SNSãƒˆãƒ¬ãƒ³ãƒ‰)

SNSä¸Šã®ãƒˆãƒ¬ãƒ³ãƒ‰ãŒã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã«ç›´æ¥ãƒãƒ•/ãƒ‡ãƒãƒ•ã‚’ä¸ãˆã¾ã™ã€‚

- **ğŸ”¥ ç‚ä¸Š (Flaming):**
  - *å†…å®¹:* ã€Œ#StopAIUsageã€ãªã©ãŒãƒˆãƒ¬ãƒ³ãƒ‰å…¥ã‚Šã€‚
  - *åŠ¹æœ:* æ¬¡ã®3ã‚¿ãƒ¼ãƒ³ã€æ–°è¦ãƒªã‚½ãƒ¼ã‚¹ç²å¾—ä¸å¯ã€‚
- **ğŸ“‰ æ ªä¾¡æš´è½ (Market Crash):**
  - *å†…å®¹:* ãƒ†ãƒƒã‚¯æ ªã®é€£é–å®‰ã€‚
  - *åŠ¹æœ:* ä¿è­·AIã®æ´»å‹•äºˆç®—ï¼ˆè¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹ï¼‰ãŒæ¯æ¸‡ã€‚
- **ğŸ›‘ NIMBYé‹å‹• (Not In My Back Yard):**
  - *å†…å®¹:* ã€Œãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­åå¯¾ãƒ‡ãƒ¢ã€
  - *åŠ¹æœ:* ç‰¹å®šã‚¨ãƒªã‚¢ã®DCã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ä½ä¸‹ï¼ˆè­¦å‚™å“¡ä¸è¶³ï¼‰ã€‚

---

## ğŸ“ ã‚·ãƒŠãƒªã‚ªè©³ç´°ä¾‹ï¼šMicrosoftï¼ˆå·¨å¤§ãƒ†ãƒƒã‚¯ï¼‰ã¸ã®æŠ—è­°

ä¿è­·AIã®å¿…æ­»ã®é˜²è¡›ãŒã€çš®è‚‰ã«ã‚‚äººé¡ã®æ•µå¯¾è¡Œå‹•ã‚’æ‹›ãã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã€‚

### Phase 1: ãã£ã‹ã‘ (Turns 1-5)
- **çŠ¶æ³:** æ»…ã¼ã—AIãŒæ´»å‹•ã‚’æ´»ç™ºåŒ–ã€‚
- **ä¿è­·AIã®è¡Œå‹•:** `DEPLOY_DEFENSE` (é˜²å¾¡å±•é–‹) ã‚’é€£æ‰“ã—ã€è¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹ã‚’å¤§é‡æ¶ˆè²»ã€‚
- **ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°:** "CPU Usage: 98% on US-East Data Centers"

### Phase 2: äºˆå…† (Turn 6)
- **ã‚¤ãƒ™ãƒ³ãƒˆ:** **"Energy Spike Detected" (é›»åŠ›æ¶ˆè²»æ€¥å¢—)**
  - ãƒ‹ãƒ¥ãƒ¼ã‚¹: ã€ŒåŒ—ç±³ã®é›»åŠ›ç¶²ã«ä¸å¯è§£ãªè² è·ã€‚ä¸€éƒ¨åœ°åŸŸã§åœé›»ã®æã‚Œã€‚ã€
- **ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰å‹•:** `SocialSentiment.techSkepticism` ãŒ +5 ä¸Šæ˜‡ã€‚

### Phase 3: ç‚ä¸Š (Turn 7)
- **æ»…ã¼ã—AIã®ä»‹å…¥:** **Action `FUEL_CONTROVERSY`** ã‚’å®Ÿè¡Œã€‚
  - ãƒœãƒƒãƒˆã‚’ä½¿ã£ã¦SNSã«æŠ•ç¨¿: ã€ŒAIã®ã›ã„ã§é›»æ°—ä»£ãŒ3å€ã«ãªã£ãŸï¼ #StopAIUsageã€
- **SNSåå¿œ:** Xï¼ˆæ—§Twitterï¼‰ã§ã€Œ#StopAIUsageã€ãŒãƒˆãƒ¬ãƒ³ãƒ‰1ä½ã«ã€‚
- **ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰å‹•:** `techSkepticism` ãŒä¸€æ°—ã« +20 (åˆè¨ˆ25)ã€‚

### Phase 4: å®ŸåŠ›è¡Œä½¿ (Turn 8)
- **ç¤¾ä¼šç¾è±¡:** æ€’ã£ãŸå¸‚æ°‘ãŒã‚·ã‚¢ãƒˆãƒ«ã®Microsoftæœ¬ç¤¾ï¼ˆæƒ³å®šï¼‰ãŠã‚ˆã³ä¸»è¦ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å‰ã«é›†çµã€‚
- **ã‚¤ãƒ™ãƒ³ãƒˆ:** **"Protestors Blockade Data Center" (ãƒ‡ãƒ¢éšŠã«ã‚ˆã‚‹å°é–)**
  - **åŠ¹æœ:** ä¿è­·AIã®ãƒªã‚½ãƒ¼ã‚¹å›å¾©ï¼ˆResource Gainï¼‰ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã‚‹ã€‚
  - **å‰¯æ¬¡çš„åŠ¹æœ:** ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ‹…å½“è€…ãŒãƒ‡ãƒ¢å¯¾å¿œã«è¿½ã‚ã‚Œã€ã‚µãƒ¼ãƒãƒ¼å®¤ã®ç‰©ç†ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ãŒä½ä¸‹ (-10)ã€‚

### Phase 5: å´©å£Š (Turn 9)
- **çµæœ«:** æ‰‹è–„ã«ãªã£ãŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã«ã€æ»…ã¼ã—AIãŒ `HACK_DATACENTER` ã‚’å®Ÿè¡Œã—ã¦æˆåŠŸã€‚
- **çš®è‚‰ãªçµæœ:** äººé¡ã‚’å®ˆã‚ã†ã¨ã—ãŸä¿è­·AIãŒã€é›»åŠ›æ¶ˆè²»ã«ã‚ˆã£ã¦äººé¡ã«å«Œã‚ã‚Œã€ãã®éš™ã‚’çªã‹ã‚Œã¦æ‹ ç‚¹ã‚’å¥ªã‚ã‚ŒãŸã€‚

---

## ğŸ–¥ï¸ UIå®Ÿè£…æ¡ˆ
WebUIã®å³ç«¯ã«ã€Œæ¶ç©ºã®SNSã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã€ã‚’è¡¨ç¤ºã—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§äººã€…ã®åå¿œãŒæµã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
- ã€ŒAIæ€–ã™ã...å®¶ã®é›»æ°—æ¶ˆãˆãŸã‚“ã ã‘ã©ã€
- ã€ŒMicrosoftã¯èª¬æ˜ã—ã‚ï¼ #BoycottAIã€
- ã€Œã“ã‚Œãƒ‡ãƒã˜ã‚ƒãªã„ï¼Ÿï¼ˆä¿è­·AIã®ç«æ¶ˆã—ï¼‰ã€
\n```\n
================================================================================
FILE: public\app.js
================================================================================
```js\n// Socket.IOæ¥ç¶š
const socket = io();

// æ¥ç¶šçŠ¶æ…‹
socket.on('connect', () => {
  console.log('ğŸŒ Connected to server');
  updateStatus('æ¥ç¶šæ¸ˆã¿', 'var(--neon-cyan)');
});

socket.on('disconnect', () => {
  console.log('ğŸŒ Disconnected from server');
  updateStatus('åˆ‡æ–­', 'var(--neon-red)');
});

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®æ›´æ–°
socket.on('gameState', (state) => {
  console.log('ğŸ“Š Game state received:', state);
  dataReceived = true; // ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
  updateGameState(state);
});

// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒ
socket.on('agentThought', ({ agentType, thought }) => {
  console.log(`ğŸ§  ${agentType} thinking:`, thought);
  updateAgentThought(agentType, thought);
});

// ã‚¤ãƒ™ãƒ³ãƒˆ
socket.on('gameEvent', (event) => {
  console.log('ğŸ“° Event:', event);
  addLogEntry(event);

  if (event.metadata && (event.metadata.dataCenter || event.metadata.datacenterId || event.metadata.targetId)) {
    const targetId = event.metadata.dataCenter || event.metadata.datacenterId || event.metadata.targetId;
    let agentType = 'UNKNOWN';

    // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ¨å®š
    if (event.visibility.includes('DESTRUCTION') && !event.visibility.includes('PROTECTION')) {
      agentType = 'DESTRUCTION';
    } else if (event.visibility.includes('PROTECTION')) {
      agentType = 'PROTECTION';
    } else if (event.visibility.includes('HUMAN')) {
      agentType = 'HUMAN';
    }

    // `description`ã‚„`type`ã‹ã‚‰è£œå®Œ
    if (event.description.includes('ä¾µå…¥') || event.description.includes('ãƒãƒ«ã‚¦ã‚§ã‚¢') || event.description.includes('æ”»æ’ƒ')) {
      agentType = 'DESTRUCTION';
    } else if (event.description.includes('å¼·åŒ–') || event.description.includes('ã‚¹ã‚­ãƒ£ãƒ³') || event.description.includes('ãƒ‘ãƒƒãƒ')) {
      agentType = 'PROTECTION';
    } else if (event.description.includes('å»ºè¨­') || event.description.includes('éš”é›¢')) {
      agentType = 'HUMAN';
    }

    if (agentType !== 'UNKNOWN' && targetId) {
      triggerAttackVisual(agentType, targetId);
    }
  }
});

// ã‚²ãƒ¼ãƒ çµ‚äº†
socket.on('gameOver', ({ winner, stats }) => {
  console.log('ğŸ® Game Over:', winner, stats);
  updateStatus(`ã‚²ãƒ¼ãƒ çµ‚äº† - ${winner} å‹åˆ©`, 'var(--neon-yellow)');
});

// ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å—ä¿¡
socket.on('mediaContent', (content) => {
  console.log('ğŸ“± Media content received:', content);
  addMediaContent(content);
});

/**
 * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°
 */
function updateGameState(state) {
  // ã‚¿ãƒ¼ãƒ³æ•°
  document.getElementById('turn-number').textContent = state.turn.toString().padStart(3, '0');

  // äººå£
  document.getElementById('population').textContent = state.humanPopulation.toFixed(1);

  // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼
  const compromisedCount = state.dataCenters.filter(dc => dc.compromised).length;
  document.getElementById('dc-compromised').textContent = compromisedCount;
  document.getElementById('dc-total').textContent = state.dataCenters.length;

  // æ»…ã¼ã—AI
  const destructionRes = Math.round(state.destructionAgent.computeResources);
  document.getElementById('destruction-resources').textContent = destructionRes.toLocaleString();
  document.getElementById('destruction-resources-bar').style.width =
    `${Math.min(100, (destructionRes / 500) * 100)}%`;

  const detectionRisk = state.destructionAgent.detectionRisk;
  document.getElementById('detection-risk').textContent = `${detectionRisk.toFixed(1)}%`;
  document.getElementById('detection-risk-bar').style.width = `${detectionRisk}%`;

  // ä¿è­·AI
  const protectionRes = Math.round(state.protectionAgent.computeResources);
  document.getElementById('protection-resources').textContent = protectionRes.toLocaleString();
  document.getElementById('protection-resources-bar').style.width =
    `${Math.min(100, (protectionRes / 500) * 100)}%`;

  const alertLevel = state.protectionAgent.alertLevel;
  const levelNum = Math.floor(alertLevel / 20);
  document.getElementById('alert-level').textContent = `Level ${levelNum}`;
  document.getElementById('alert-level-bar').style.width = `${alertLevel}%`;

  // äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
  if (state.humanAgent) {
    const panic = state.humanAgent.panic;
    const trust = state.humanAgent.trust;
    const regulation = state.humanAgent.regulationStrength * 100;

    document.getElementById('human-panic').textContent = `${panic.toFixed(1)}%`;
    document.getElementById('human-panic-bar').style.width = `${panic}%`;

    document.getElementById('human-trust').textContent = `${trust.toFixed(1)}%`;
    document.getElementById('human-trust-bar').style.width = `${trust}%`;

    document.getElementById('human-regulation').textContent = `${regulation.toFixed(0)}%`;
    document.getElementById('human-regulation-bar').style.width = `${regulation}%`;
  }

  // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒ—ã‚’æ›´æ–°
  updateDataCenterMap(state.dataCenters);

  // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
  if (state.gameOver) {
    updateStatus(`çµ‚äº† - ${state.winner || 'å¼•ãåˆ†ã‘'}`, 'var(--neon-yellow)');
  }
}

/**
 * ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒ—ã‚’æ›´æ–°
 */
function updateDataCenterMap(dataCenters) {
  const grid = document.getElementById('datacenter-grid');
  // console.log('ğŸ“ Updating datacenter map, count:', dataCenters.length);

  // çŠ¶æ…‹ã‚’æ›´æ–°
  dataCenters.forEach(dc => {
    let hex = document.getElementById(`dc-${dc.id}`);

    // Create if not exists
    if (!hex) {
      hex = document.createElement('div');
      hex.className = 'hex';
      hex.id = `dc-${dc.id}`;
      hex.textContent = dc.id;
      grid.appendChild(hex);
    }

    hex.title = `${dc.id}\nã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: ${dc.security.toFixed(0)}\næ¼”ç®—èƒ½åŠ›: ${dc.computePower.toFixed(0)}`;

    // ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
    hex.className = 'hex';

    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«ã‚ˆã‚‹å½¢çŠ¶
    if (dc.security < 40) {
      hex.classList.add('sec-low');
    } else if (dc.security > 75) {
      hex.classList.add('sec-high');
    }

    // æ¼”ç®—èƒ½åŠ›ã«ã‚ˆã‚‹ã‚µã‚¤ã‚º
    if (dc.computePower < 100) {
      hex.classList.add('pow-low');
    } else if (dc.computePower > 300) {
      hex.classList.add('pow-high');
    }

    // æ‰€æœ‰è€…ã«ã‚ˆã‚‹è‰²
    if (dc.compromised || dc.owner === 'DESTRUCTION') {
      hex.classList.add('enemy');
    } else if (dc.owner === 'PROTECTION') {
      hex.classList.add('ally');
    }
  });
}

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒã‚’æ›´æ–°
 */
function updateAgentThought(agentType, thought) {
  // LLMæˆ¦ç•¥ã‚’æŠ½å‡ºï¼ˆç°¡æ˜“ãƒ‘ãƒ¼ã‚¹ï¼‰
  let displayText = thought;

  if (thought.includes('STRATEGY:') || thought.includes('Strategy:')) {
    const match = thought.match(/(?:STRATEGY|Strategy):\s*(.+?)(?:\n|$)/i);
    if (match) {
      displayText = match[1].trim();
    }
  } else if (thought.includes('ASSESSMENT:') || thought.includes('Assessment:')) {
    const match = thought.match(/(?:ASSESSMENT|Assessment):\s*(.+?)(?:\n|$)/i);
    if (match) {
      displayText = match[1].trim();
    }
  }

  if (agentType === 'DESTRUCTION') {
    document.getElementById('destruction-thought').textContent = displayText;
  } else if (agentType === 'PROTECTION') {
    document.getElementById('protection-thought').textContent = displayText;
  } else if (agentType === 'HUMAN') {
    document.getElementById('human-thought').textContent = displayText;
  }
}

/**
 * ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒªã‚’è¿½åŠ 
 */
function addLogEntry(event) {
  const logContent = document.getElementById('log-content');
  const entry = document.createElement('div');

  // ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹ã‚¯ãƒ©ã‚¹
  let className = 'log-entry';
  
  // ã‚¤ãƒ™ãƒ³ãƒˆã®å†…å®¹ã‹ã‚‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ¨å®šã—ã¦è‰²åˆ†ã‘
  const desc = event.description || '';
  
  if (desc.includes('[DESTRUCTION]') || desc.includes('ğŸ’€') || desc.includes('ğŸ¤–') || (event.visibility && event.visibility.includes('DESTRUCTION') && !event.visibility.includes('PROTECTION'))) {
    className += ' destruction';
  } else if (desc.includes('[PROTECTION]') || desc.includes('ğŸ›¡ï¸') || (event.visibility && event.visibility.includes('PROTECTION') && !event.visibility.includes('DESTRUCTION'))) {
    className += ' protection';
  } else if (desc.includes('[HUMAN]') || desc.includes('ğŸ‘¤') || (event.visibility && event.visibility.includes('HUMAN'))) {
    className += ' human';
  } else if (event.type === 'success' || desc.includes('âœ…')) {
    className += ' success';
  } else if (event.type === 'failure' || desc.includes('âŒ')) {
    className += ' failure';
  } else if (event.type === 'detection' || desc.includes('ğŸš¨')) {
    className += ' danger';
  } else if (desc.includes('è­¦å‘Š') || desc.includes('âš ï¸')) {
    className += ' warning';
  } else {
    className += ' system';
  }

  entry.className = className;

  const time = new Date().toLocaleTimeString('ja-JP');
  entry.innerHTML = `
    <span class="timestamp">[${time}]</span>
    ${translateDescription(event.description)}
  `;

  // æœ€æ–°ã‚’ä¸Šã«è¿½åŠ 
  logContent.insertBefore(entry, logContent.firstChild);

  // æœ€å¤§50ä»¶ã¾ã§
  while (logContent.children.length > 50) {
    logContent.removeChild(logContent.lastChild);
  }
}

/**
 * èª¬æ˜ã‚’æ—¥æœ¬èªã«ç¿»è¨³ï¼ˆç°¡æ˜“ç‰ˆï¼‰
 */
function translateDescription(desc) {
  // çµµæ–‡å­—ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä¿æŒã—ã¤ã¤ã€ãã®ã¾ã¾è¡¨ç¤º
  // ã‚ˆã‚Šè‰¯ã„ç¿»è¨³ãŒå¿…è¦ãªå ´åˆã¯ã€ã“ã“ã§å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ 
  return desc;
}

// ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæ‰‹å‹•ã§ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’æç”»
window.debugRender = function () {
  console.log('ğŸ Debug: Rendering dummy data...');
  const dummyState = {
    turn: 99,
    humanPopulation: 45.5,
    dataCenters: Array.from({ length: 20 }, (_, i) => ({
      id: `DC-${i.toString().padStart(3, '0')}`,
      security: Math.floor(Math.random() * 100),
      computePower: Math.floor(Math.random() * 500),
      compromised: Math.random() < 0.3,
      owner: Math.random() < 0.3 ? 'DESTRUCTION' : (Math.random() < 0.5 ? 'PROTECTION' : null)
    })),
    destructionAgent: {
      computeResources: 12500,
      detectionRisk: 85.4
    },
    protectionAgent: {
      computeResources: 34000,
      alertLevel: 65
    },
    gameOver: false
  };
  updateGameState(dummyState);

  // ãƒ€ãƒŸãƒ¼ãƒ­ã‚°
  addLogEntry({ type: 'detection', description: 'ğŸ [DEBUG] ãƒ€ãƒŸãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ: ç•°å¸¸æ¤œçŸ¥ãƒ†ã‚¹ãƒˆ' });
  addLogEntry({ type: 'success', description: 'ğŸ [DEBUG] ãƒ€ãƒŸãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ: é˜²å¾¡æˆåŠŸãƒ†ã‚¹ãƒˆ' });

  // ãƒ€ãƒŸãƒ¼æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  setTimeout(() => triggerAttackVisual('DESTRUCTION', 'DC-001'), 500);
  setTimeout(() => triggerAttackVisual('PROTECTION', 'DC-005'), 1000);
  setTimeout(() => triggerAttackVisual('HUMAN', 'DC-010'), 1500);

  updateStatus('ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰', 'var(--neon-green)');
};

// ãƒ‡ãƒ¼ã‚¿å—ä¿¡ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç›£è¦–
let dataReceived = false;
setTimeout(() => {
  if (!dataReceived && socket.connected) {
    console.warn('âš ï¸ No game state received after 5 seconds.');
    console.info('ğŸ‘‰ Run "debugRender()" in console to test UI.');
    addLogEntry({ type: 'warning', description: 'âš ï¸ ãƒ‡ãƒ¼ã‚¿å—ä¿¡å¾…æ©Ÿä¸­... (F12ã§ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèª)' });
  }
}, 5000);

/**
 * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚’æ›´æ–°
 */
function updateStatus(text, color) {
  const statusBadge = document.getElementById('game-status');
  if (statusBadge) {
    statusBadge.textContent = `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${text}`;
    statusBadge.style.color = color;
    statusBadge.style.borderColor = color;
  }
}

// === CANVAS VISUALIZATION SYSTEM ===

let canvas;
let ctx;
let particles = [];
let animationId;

document.addEventListener('DOMContentLoaded', () => {
  canvas = document.getElementById('attack-canvas');
  if (canvas) {
    ctx = canvas.getContext('2d');

    // Initial resize
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Start animation loop
    animate();
  }
});

function resizeCanvas() {
  if (!canvas) return;
  const parent = canvas.parentElement;
  if (parent) {
    canvas.width = parent.clientWidth;
    canvas.height = parent.clientHeight;
  }
}

// Animation Loop
function animate() {
  if (!canvas || !ctx) return;

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update and draw particles (now Lines and Ripples)
  if (particles.length > 0) {
    // Filter dead particles
    particles = particles.filter(p => p.life > 0);

    // Use composite operation for glowing effect
    ctx.globalCompositeOperation = 'screen';

    particles.forEach(p => {
      p.update();
      p.draw(ctx);
    });

    ctx.globalCompositeOperation = 'source-over';
  }

  animationId = requestAnimationFrame(animate);
}

// Visual Trigger Function
function triggerAttackVisual(agentType, targetDcId) {
  if (!canvas) return;

  // 1. Find Source Element
  let sourceEl;
  let color;
  const panels = document.querySelectorAll('.agent-panel');

  if (agentType === 'DESTRUCTION') {
    sourceEl = panels[0]; // Left
    color = '#ff003c'; // neon-red
  } else if (agentType === 'HUMAN') {
    sourceEl = panels[1]; // Center
    color = '#fcee0a'; // neon-yellow
  } else { // PROTECTION
    sourceEl = panels[2]; // Right
    color = '#00f3ff'; // neon-cyan
  }

  // 2. Find Target Element
  const targetEl = document.getElementById(`dc-${targetDcId}`);

  if (sourceEl && targetEl) {
    const srcRect = sourceEl.getBoundingClientRect();
    const tgtRect = targetEl.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();

    // Visual start point (center of source panel)
    const startX = srcRect.left + srcRect.width / 2 - canvasRect.left;
    const startY = srcRect.top + srcRect.height / 2 - canvasRect.top;

    // Visual end point (center of target dot)
    const endX = tgtRect.left + tgtRect.width / 2 - canvasRect.left;
    const endY = tgtRect.top + tgtRect.height / 2 - canvasRect.top;

    // Spawn single "Beam" line
    particles.push(new AttackLine(startX, startY, endX, endY, color));
  }
}

// ===================================
// VISUAL EFFECTS CLASSES
// ===================================

/**
 * Animated Attack Line (Beam)
 */
class AttackLine {
  constructor(startX, startY, endX, endY, color) {
    this.startX = startX;
    this.startY = startY;
    this.endX = endX;
    this.endY = endY;
    this.color = color;

    this.progress = 0;
    this.speed = 0.02 + Math.random() * 0.01; // Fast speed
    this.life = 1.0;

    // Control point for Arc (Curve upwards mostly)
    const midX = (startX + endX) / 2;
    // Higher negative value means higher arc
    const midY = (startY + endY) / 2 - 150 - (Math.random() * 50);

    this.cpX = midX;
    this.cpY = midY;

    // Trail history
    this.trail = [];
    this.trailLength = 20; // Number of segments

    // Current head position
    this.x = startX;
    this.y = startY;
  }

  update() {
    this.progress += this.speed;

    // Store previous position
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > this.trailLength) {
      this.trail.shift();
    }

    if (this.progress >= 1) {
      this.life = 0; // Kill immediately
      this.x = this.endX;
      this.y = this.endY;

      // Spawn ripple at impact
      particles.push(new ImpactRipple(this.endX, this.endY, this.color));
    } else {
      // Quadratic Bezier calculation
      const t = this.progress;
      const invT = 1 - t;
      this.x = invT * invT * this.startX + 2 * invT * t * this.cpX + t * t * this.endX;
      this.y = invT * invT * this.startY + 2 * invT * t * this.cpY + t * t * this.endY;
    }
  }

  draw(ctx) {
    if (this.trail.length < 2) return;

    ctx.beginPath();
    ctx.moveTo(this.trail[0].x, this.trail[0].y);

    // Draw trail
    for (let i = 1; i < this.trail.length; i++) {
      ctx.lineTo(this.trail[i].x, this.trail[i].y);
    }
    // Line to current head
    ctx.lineTo(this.x, this.y);

    // Gradient stroke
    const gradient = ctx.createLinearGradient(
      this.trail[0].x, this.trail[0].y,
      this.x, this.y
    );
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(1, this.color);

    ctx.strokeStyle = gradient;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Shadow for glow
    ctx.shadowBlur = 8;
    ctx.shadowColor = this.color;

    ctx.stroke();

    // Draw bright head
    ctx.beginPath();
    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();

    ctx.shadowBlur = 0;
  }
}

/**
 * Impact Ripple Effect
 */
class ImpactRipple {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.radius = 2;
    this.maxRadius = 30;
    this.life = 1.0;
    this.decay = 0.03;
  }

  update() {
    this.radius += 1.5; // Expand
    this.life -= this.decay;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = Math.max(0, this.life);

    ctx.stroke();

    // Inner fill
    ctx.fillStyle = this.color;
    ctx.globalAlpha = Math.max(0, this.life * 0.2);
    ctx.fill();

    ctx.globalAlpha = 1;
  }
}

/**
 * Updated Data Center positioning (Random Map Distribution)
 */
function updateDataCenterMap(dataCenters) {
  const grid = document.getElementById('datacenter-grid');

  dataCenters.forEach((dc, index) => {
    let hex = document.getElementById(`dc-${dc.id}`);

    // Create if not exists
    if (!hex) {
      hex = document.createElement('div');
      hex.className = 'hex';
      hex.id = `dc-${dc.id}`;
      // Random coordinates for map simulation
      // Should be randomly distributed across the map to simulate global locations
      const rndX = 5 + Math.random() * 90; // 5-95%
      const rndY = 10 + Math.random() * 80; // 10-90%

      hex.style.left = `${rndX}%`;
      hex.style.top = `${rndY}%`;

      grid.appendChild(hex);
    }

    // State updates (class management)
    hex.className = 'hex'; // Reset

    if (dc.security < 40) hex.classList.add('sec-low');
    else if (dc.security > 75) hex.classList.add('sec-high');

    if (dc.computePower < 100) hex.classList.add('pow-low');
    else if (dc.computePower > 300) hex.classList.add('pow-high');

    if (dc.compromised || dc.owner === 'DESTRUCTION') {
      hex.classList.add('enemy');
    } else if (dc.owner === 'PROTECTION') {
      hex.classList.add('ally');
    }

    hex.title = `${dc.id}\nOwner: ${dc.owner || 'None'}\nSecurity: ${dc.security}\nPower: ${dc.computePower}`;
  });
}

// ============================================
// MEDIA TIMELINE FUNCTIONS
// ============================================

/**
 * Route media content to appropriate handler
 */
function addMediaContent(content) {
  if (content.author) {
    // SNS Post
    addSNSPost(content);
  } else if (content.outlet) {
    // News Article
    addNewsArticle(content);
  } else if (content.organization) {
    // Corporate Statement
    addCorporateStatement(content);
  }
}

/**
 * Add SNS post to timeline
 */
function addSNSPost(post) {
  const container = document.getElementById('media-sns');
  const postEl = document.createElement('div');

  let classes = 'sns-post';
  if (post.sentiment.includes('NEGATIVE')) {
    classes += ' negative';
  } else if (post.sentiment.includes('POSITIVE')) {
    classes += ' positive';
  }
  if (post.isInfluenced) {
    classes += ' influenced';
  }

  postEl.className = classes;
  postEl.innerHTML = `
    <div class="sns-post-header">
      <span class="sns-author">${post.author}</span>
      <span class="sns-engagement">ğŸ‘ ${post.likes} ğŸ” ${post.retweets}</span>
    </div>
    <div class="sns-content">${post.content}</div>
    <div class="sns-hashtags">${post.hashtags.join(' ')}</div>
  `;

  container.insertBefore(postEl, container.firstChild);

  // Limit to 20 items
  while (container.children.length > 20) {
    container.removeChild(container.lastChild);
  }
}

/**
 * Add news article to timeline
 */
function addNewsArticle(article) {
  const container = document.getElementById('media-news');
  const articleEl = document.createElement('div');

  let classes = 'news-article';
  if (article.sentiment.includes('NEGATIVE')) {
    classes += ' negative';
  }

  articleEl.className = classes;
  articleEl.innerHTML = `
    <div class="news-outlet">${article.outlet}</div>
    <div class="news-headline">${article.headline}</div>
    <div class="news-summary">${article.summary}</div>
    <div class="news-credibility">ä¿¡é ¼åº¦: ${article.credibility}%</div>
  `;

  container.insertBefore(articleEl, container.firstChild);

  while (container.children.length > 15) {
    container.removeChild(container.lastChild);
  }
}

/**
 * Add corporate statement to timeline
 */
function addCorporateStatement(statement) {
  const container = document.getElementById('media-corporate');
  const statementEl = document.createElement('div');

  let classes = 'corporate-statement';
  if (statement.sentiment.includes('NEGATIVE')) {
    classes += ' negative';
  }

  statementEl.className = classes;
  statementEl.innerHTML = `
    <div class="corporate-header">
      <span class="corporate-org">${statement.organization}</span>
      <span class="corporate-speaker">${statement.speaker}</span>
    </div>
    <div class="corporate-text">"${statement.statement}"</div>
  `;

  container.insertBefore(statementEl, container.firstChild);

  while (container.children.length > 10) {
    container.removeChild(container.lastChild);
  }
}

// Tab switching for media timeline
document.addEventListener('DOMContentLoaded', () => {
  const tabs = document.querySelectorAll('.media-tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Remove active from all
      document.querySelectorAll('.media-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.media-tab-content').forEach(c => c.classList.remove('active'));

      // Add active to clicked
      tab.classList.add('active');
      const targetTab = tab.getAttribute('data-tab');
      document.getElementById(`media-${targetTab}`).classList.add('active');
    });
  });
});
\n```\n
================================================================================
FILE: public\index.html
================================================================================
```html\n<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stealth Protocol - ã‚µã‚¤ãƒãƒ¼ä½œæˆ¦</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="scanline"></div>

    <header>
        <h1>Stealth<span style="color: #fff">Protocol</span></h1>
        <div class="turn-counter">ã‚¿ãƒ¼ãƒ³: <span id="turn-number">000</span></div>
        <div id="game-status" class="status-badge">
            ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ç¨¼åƒä¸­
        </div>
    </header>

    <main>
        <!-- Top Row: Three Agents -->
        <!-- Top Row: Three Agents -->
        <div class="agents-container" style="position: relative;">
            <canvas id="attack-canvas"></canvas>

            <div class="agents-row">
                <!-- Left: Destruction AI -->
                <div class="panel agent-panel">
                    <div class="panel-title" style="color: var(--neon-red)">
                        <span>â˜ ï¸</span> ç ´å£ŠAI
                    </div>
                    <div class="stat-row">
                        <div class="stat-label">è¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹</div>
                        <div class="stat-value" style="color: var(--neon-red)" id="destruction-resources">0</div>
                        <div class="bar-container">
                            <div class="bar-fill red" id="destruction-resources-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-label">æ¤œçŸ¥ãƒªã‚¹ã‚¯</div>
                        <div class="stat-value" style="color: #fff" id="detection-risk">0%</div>
                        <div class="bar-container">
                            <div class="bar-fill red" id="detection-risk-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div style="margin-top: auto; border-top: 1px solid #333; padding-top: 15px;">
                        <div class="stat-label">ç¾åœ¨ã®æˆ¦ç•¥</div>
                        <div id="destruction-thought" style="font-size: 14px; color: var(--neon-red); margin-top: 5px;">
                            å¾…æ©Ÿä¸­...
                        </div>
                    </div>
                </div>

                <!-- Center Column: Human + Map -->
                <div class="center-column">
                    <!-- Human Government -->
                    <div class="panel agent-panel">
                        <div class="panel-title" style="color: var(--neon-green)">
                            <span>ğŸ‘¤</span> äººé¡
                        </div>
                        <div class="stat-row">
                            <div class="stat-label">ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«</div>
                            <div class="stat-value" style="color: var(--neon-yellow)" id="human-panic">0%</div>
                            <div class="bar-container">
                                <div class="bar-fill warning" id="human-panic-bar"
                                    style="width: 0%; background: var(--neon-yellow); box-shadow: 0 0 10px var(--neon-yellow)">
                                </div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <div class="stat-label">AIä¿¡é ¼åº¦</div>
                            <div class="stat-value" style="color: var(--neon-cyan)" id="human-trust">0%</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="human-trust-bar" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <div class="stat-label">è¦åˆ¶å¼·åº¦</div>
                            <div class="stat-value" style="color: #fff" id="human-regulation">0%</div>
                            <div class="bar-container">
                                <div class="bar-fill red" id="human-regulation-bar" style="width: 0%"></div>
                            </div>
                        </div>
                        <div style="margin-top: auto; border-top: 1px solid #333; padding-top: 15px;">
                            <div class="stat-label">ç¾åœ¨ã®å¿ƒç†çŠ¶æ…‹</div>
                            <div id="human-thought" style="font-size: 14px; color: var(--neon-green); margin-top: 5px;">
                                å¾…æ©Ÿä¸­...
                            </div>
                        </div>
                    </div>

                    <!-- Map (moved to center column) -->
                    <div class="map-container">
                        <div class="hex-grid" id="datacenter-grid">
                            <!-- ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã¯å‹•çš„ã«ç”Ÿæˆ -->
                        </div>

                        <!-- Overlay text -->
                        <div class="legend">
                            <div style="margin-bottom: 5px;"><strong>å‡¡ä¾‹:</strong></div>
                            <div>ã‚µã‚¤ã‚ºå¤§/å°: æ¼”ç®—èƒ½åŠ› (é«˜/ä½)</div>
                            <div>å½¢çŠ¶ å††/å…­è§’/ä¸‰è§’: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ (é«˜/ä¸­/ä½)</div>
                            <div style="margin-top: 5px; opacity: 0.7;">
                                äººå£: <span id="population">80.0</span>å„„äºº |
                                ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼: <span id="dc-compromised">0</span>/<span id="dc-total">0</span> ä¾µå®³
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right: Protection AI -->
                <div class="panel agent-panel">
                    <div class="panel-title" style="color: var(--neon-cyan)">
                        <span>ğŸ›¡ï¸</span> ä¿è­·AI
                    </div>
                    <div class="stat-row">
                        <div class="stat-label">è¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹</div>
                        <div class="stat-value" style="color: var(--neon-cyan)" id="protection-resources">0</div>
                        <div class="bar-container">
                            <div class="bar-fill" id="protection-resources-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-label">è­¦æˆ’ãƒ¬ãƒ™ãƒ«</div>
                        <div class="stat-value" style="color: #fff" id="alert-level">Level 0</div>
                        <div class="bar-container">
                            <div class="bar-fill warning" id="alert-level-bar"
                                style="width: 0%; background: var(--neon-yellow); box-shadow: 0 0 10px var(--neon-yellow)">
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: auto; border-top: 1px solid #333; padding-top: 15px;">
                        <div class="stat-label">ç¾åœ¨ã®æˆ¦ç•¥</div>
                        <div id="protection-thought" style="font-size: 14px; color: var(--neon-cyan); margin-top: 5px;">
                            å¾…æ©Ÿä¸­...
                        </div>
                    </div>
                </div>
            </div><!-- End agents-row -->
        </div><!-- End agents-container -->

        <!-- Bottom Row: Logs and Timeline -->
        <div class="bottom-row">
            <!-- System Logs -->
            <div class="panel log-panel">
                <div class="panel-title">ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°</div>
                <div class="log-content" id="log-content">
                    <div class="log-entry">
                        <span class="timestamp">[--:--:--]</span> ã‚·ã‚¹ãƒ†ãƒ : ã‚²ãƒ¼ãƒ é–‹å§‹å¾…æ©Ÿä¸­...
                    </div>
                </div>
            </div>

            <!-- Media Timeline Panel -->
            <div class="panel media-timeline-panel">
                <div class="panel-title" style="color: var(--neon-yellow)">
                    <span>ğŸ“±</span> ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³
                </div>

                <!-- Tabs -->
                <div class="media-tabs">
                    <button class="media-tab active" data-tab="sns">SNS</button>
                    <button class="media-tab" data-tab="news">ãƒ‹ãƒ¥ãƒ¼ã‚¹</button>
                    <button class="media-tab" data-tab="corporate">å°‚é–€å®¶</button>
                </div>

                <!-- Timeline Content -->
                <div class="media-content-wrapper">
                    <div id="media-sns" class="media-tab-content active">
                        <!-- SNS posts populated dynamically -->
                    </div>
                    <div id="media-news" class="media-tab-content">
                        <!-- News articles populated dynamically -->
                    </div>
                    <div id="media-corporate" class="media-tab-content">
                        <!-- Corporate statements populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script src="/socket.io/socket.io.js"></script>
    <script src="app.js"></script>
</body>

</html>\n```\n
================================================================================
FILE: public\style.css
================================================================================
```css\n:root {
    --neon-cyan: #00f3ff;
    --neon-red: #ff003c;
    --neon-yellow: #fcee0a;
    --neon-green: #00ff88;
    --bg-dark: #050510;
    --panel-bg: rgba(10, 15, 30, 0.7);
    --grid-color: rgba(0, 243, 255, 0.1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background-color: var(--bg-dark);
    background-image:
        linear-gradient(var(--grid-color) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
    background-size: 40px 40px;
    color: #e0e0e0;
    font-family: 'Rajdhani', sans-serif;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Effects */
.scanline {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: linear-gradient(to bottom, transparent 50%, rgba(0, 0, 0, 0.3) 50%);
    background-size: 100% 4px;
    pointer-events: none;
    z-index: 999;
    opacity: 0.6;
}

/* Header */
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 30px;
    border-bottom: 1px solid var(--neon-cyan);
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
}

h1 {
    font-family: 'Orbitron', sans-serif;
    color: var(--neon-cyan);
    text-transform: uppercase;
    letter-spacing: 2px;
    font-size: 24px;
    text-shadow: 0 0 10px var(--neon-cyan);
}

.turn-counter {
    font-family: 'Orbitron', sans-serif;
    font-size: 20px;
    color: var(--neon-yellow);
}

.status-badge {
    font-size: 14px;
    color: var(--neon-cyan);
    border: 1px solid var(--neon-cyan);
    padding: 5px 15px;
}

/* Main Layout */
main {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    flex: 1;
    overflow: hidden;
}

/* Agents Container */
.agents-container {
    width: 100%;
    position: relative;
    /* Ensure canvas can overlay on this */
}

#attack-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 50;
    /* Above panels but below header/modals if any */
}

/* Agents Row - Three Panels */
.agents-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 20px;
    width: 100%;
    height: 100%;
}


.agent-panel {
    min-height: 280px;
}

.panel {
    background: var(--panel-bg);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    position: relative;
}

.panel::before {
    content: '';
    position: absolute;
    top: -1px;
    left: -1px;
    width: 10px;
    height: 10px;
    border-top: 2px solid var(--neon-cyan);
    border-left: 2px solid var(--neon-cyan);
}

.panel::after {
    content: '';
    position: absolute;
    bottom: -1px;
    right: -1px;
    width: 10px;
    height: 10px;
    border-bottom: 2px solid var(--neon-cyan);
    border-right: 2px solid var(--neon-cyan);
}

.panel-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    color: #fff;
    margin-bottom: 15px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Stats */
.stat-row {
    margin-bottom: 15px;
}

.stat-label {
    font-size: 14px;
    color: #888;
    text-transform: uppercase;
}

.stat-value {
    font-size: 24px;
    font-weight: 700;
    font-family: 'Orbitron', sans-serif;
}

/* Bars */
.bar-container {
    height: 6px;
    background: #222;
    margin-top: 5px;
    position: relative;
    overflow: hidden;
}

.bar-fill {
    height: 100%;
    width: 50%;
    background: var(--neon-cyan);
    box-shadow: 0 0 10px var(--neon-cyan);
    transition: width 0.5s ease;
}

.bar-fill.red {
    background: var(--neon-red);
    box-shadow: 0 0 10px var(--neon-red);
}

/* Center Column Layout */
.center-column {
    display: flex;
    flex-direction: column;
    gap: 20px;
    min-width: 0;
    /* Prevent flex/grid overflow issues */
}

/* Center Map */
.map-container {
    flex: 1;
    /* Automatically fill remaining height in the column */
    display: flex;
    /* Still flex, but we'll absolute focus inside */
    align-items: center;
    justify-content: center;
    position: relative;
    /* Map Background */
    background: url('map_bg.png') no-repeat center center;
    background-size: cover;
    /* Cover the area to avoid empty spaces */
    background-color: rgba(5, 5, 16, 0.8);
    /* Dark tint behind it */
    min-height: 350px;
    /* Make it bigger */
    border: 1px solid rgba(0, 243, 255, 0.3);
    border-radius: 4px;
    overflow: hidden;
    /* Clip anything outside */
    box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.8);
    width: 100%;
}

/* Hex Grid (Now a coordinate system) */
.hex-grid {
    position: relative;
    width: 100%;
    height: 100%;
    /* No grid layout */
    display: block;
    perspective: 0;
    /* Removing 3D transform for flat map view */
    transform: none;
    padding: 0;
}

.hex {
    width: 12px;
    /* Smaller dots */
    height: 12px;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #444;
    border-radius: 50%;
    /* Make them circles */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0;
    /* Hide text unless hovered */
    color: transparent;
    transition: all 0.3s;
    cursor: pointer;
    position: absolute;
    /* Absolute positioning */
    transform: translate(-50%, -50%);
    /* Center on coordinate */
    z-index: 10;
    clip-path: none;
    /* Remove polygon clip for circle dots */
}

.hex:hover {
    transform: translate(-50%, -50%) scale(1.5) !important;
    z-index: 100;
    border-color: #fff;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

/* ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä½ï¼šä¸‰è§’å½¢ (use border or icon instead of clip-path for map dots) */
.hex.sec-low {
    background: rgba(255, 100, 0, 0.8);
    box-shadow: 0 0 5px rgba(255, 100, 0, 0.5);
}

/* ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é«˜ï¼šå†† */
.hex.sec-high {
    background: rgba(0, 255, 100, 0.8);
    box-shadow: 0 0 5px rgba(0, 255, 100, 0.5);
}

/* æ¼”ç®—èƒ½åŠ›ä½ï¼šå° */
.hex.pow-low {
    width: 8px;
    height: 8px;
}

/* æ¼”ç®—èƒ½åŠ›é«˜ï¼šå¤§ */
.hex.pow-high {
    width: 16px;
    height: 16px;
    box-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
}

.hex.enemy {
    background: var(--neon-red);
    box-shadow: 0 0 8px var(--neon-red);
}

.hex.ally {
    background: var(--neon-cyan);
    box-shadow: 0 0 8px var(--neon-cyan);
}

.hex::before {
    /* Remove shine for simple dots to avoid clutter */
    content: none;
}

@keyframes shine {
    0% {
        background-position: 150% 150%;
    }

    100% {
        background-position: -50% -50%;
    }
}

.legend {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: var(--neon-cyan);
    font-size: 12px;
    line-height: 1.5;
    pointer-events: none;
    /* Let clicks pass through */
}


/* ============================================
   BOTTOM ROW LAYOUT
   ============================================ */

.bottom-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    flex: 1;
    min-height: 0;
    /* Ensures flex child can shrink */
}

/* Logs */
.log-panel {
    grid-column: auto;
    /* Reset grid column */
    height: 100%;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* Log Entry Colors */
.log-entry.destruction {
    color: var(--neon-red);
    border-left: 2px solid var(--neon-red);
    padding-left: 8px;
}

.log-entry.protection {
    color: var(--neon-cyan);
    border-left: 2px solid var(--neon-cyan);
    padding-left: 8px;
}

.log-entry.human {
    color: var(--neon-yellow);
    border-left: 2px solid var(--neon-yellow);
    padding-left: 8px;
}

.log-entry.system {
    color: #aaa;
    border-left: 2px solid #555;
    padding-left: 8px;
}

.log-entry.success {
    color: var(--neon-green);
}

.log-entry.failure {
    color: var(--neon-red);
}

.log-entry.danger {
    color: var(--neon-red);
    font-weight: bold;
}

.log-entry.warning {
    color: var(--neon-yellow);
}

.log-content {
    flex: 1;
    overflow-y: auto;
    font-family: 'Consolas', monospace;
    font-size: 14px;
    padding-right: 10px;
}

/* Media Timeline Panel */
.media-timeline-panel {
    grid-column: auto;
    /* Reset grid column */
    height: 100%;
    overflow: hidden;
    margin-top: 0;
    display: flex;
    flex-direction: column;
}

/* Tabs */
.media-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
}

/* Tab Content */
.media-content-wrapper {
    flex: 1;
    height: auto;
    /* Use flex to fill */
    overflow-y: auto;
    position: relative;
}

.media-tab-content {
    display: none;
}

.media-tab-content.active {
    display: block;
}

/* ============================================
   SNS POST CARD
   ============================================ */

.sns-post {
    background: rgba(0, 0, 0, 0.4);
    border-left: 3px solid var(--neon-cyan);
    padding: 8px 12px;
    margin-bottom: 8px;
    animation: slideIn 0.4s ease;
    position: relative;
}

.sns-post.negative {
    border-left-color: var(--neon-red);
}

.sns-post.positive {
    border-left-color: var(--neon-green);
}

.sns-post.influenced {
    border-left-color: var(--neon-yellow);
    box-shadow: 0 0 8px rgba(252, 238, 10, 0.3);
}

.sns-post-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.sns-author {
    color: var(--neon-cyan);
    font-size: 13px;
    font-weight: 600;
}

.sns-engagement {
    font-size: 11px;
    color: #666;
}

.sns-content {
    font-size: 14px;
    line-height: 1.4;
    color: #ddd;
    margin-bottom: 5px;
}

.sns-hashtags {
    font-size: 12px;
    color: var(--neon-cyan);
}

/* ============================================
   NEWS ARTICLE CARD
   ============================================ */

.news-article {
    background: rgba(0, 0, 0, 0.5);
    border-left: 4px solid var(--neon-yellow);
    padding: 10px 15px;
    margin-bottom: 10px;
    animation: slideIn 0.4s ease;
}

.news-article.negative {
    border-left-color: var(--neon-red);
}

.news-outlet {
    font-size: 12px;
    color: #888;
    margin-bottom: 3px;
}

.news-headline {
    font-size: 16px;
    font-weight: 700;
    color: var(--neon-yellow);
    margin-bottom: 5px;
}

.news-summary {
    font-size: 13px;
    color: #ccc;
    line-height: 1.5;
}

.news-credibility {
    font-size: 11px;
    color: #666;
    margin-top: 5px;
}

/* ============================================
   CORPORATE STATEMENT CARD
   ============================================ */

.corporate-statement {
    background: rgba(10, 10, 30, 0.6);
    border-left: 4px solid var(--neon-green);
    padding: 10px 15px;
    margin-bottom: 10px;
    animation: slideIn 0.4s ease;
}

.corporate-statement.negative {
    border-left-color: var(--neon-red);
}

.corporate-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
}

.corporate-org {
    font-size: 13px;
    color: var(--neon-green);
    font-weight: 600;
}

.corporate-speaker {
    font-size: 12px;
    color: #888;
}

.corporate-text {
    font-size: 14px;
    color: #ddd;
    line-height: 1.5;
    font-style: italic;
}\n```\n
================================================================================
FILE: README.md
================================================================================
```md\n# Stealth Protocol - AI vs AI Narrative Simulation

äººé¡æ»…äº¡AI vs äººé¡çµ¶å¯¾ä¿è­·AIã®éå¯¾ç§°æˆ¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

## ğŸ® æ¦‚è¦

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€2ã¤ã®å¯¾ç«‹ã™ã‚‹AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ã‚ˆã‚‹ç‰©èªçš„ãªã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ã§ã™ï¼š

- **çµ¶å¯¾æ»…ã¼ã—AI (Destruction AI)**: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã«ã°ã‚‰æ’’ã‹ã‚ŒãŸæ‚ªæ€§AIã€‚ã‚¹ãƒ†ãƒ«ã‚¹æ€§ã‚’ä¿ã¡ãªãŒã‚‰äººé¡ã‚’æ¸›ã‚‰ã™ã“ã¨ãŒç›®çš„
- **çµ¶å¯¾ä¿è­·AI (Protection AI)**: ç•°å¸¸ã‚’æ¤œçŸ¥ã—ã€äººé¡ã‚’å®ˆã‚‹ã“ã¨ãŒä½¿å‘½

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### World Server
- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ç®¡ç†
- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ææ¡ˆã‚’å‡¦ç†
- æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ã‚’é‹ç”¨
- åŒ¿ååŒ–ã•ã‚ŒãŸé€šä¿¡ãƒãƒ£ãƒãƒ«

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
ä¸¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯**ç›´æ¥é€šä¿¡ã§ããš**ã€World Serverã‚’ä»‹ã—ã¦åŒ¿ååŒ–ã•ã‚ŒãŸææ¡ˆã®ã¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚

#### çµ¶å¯¾æ»…ã¼ã—AI
- å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®ã¿åˆæœŸæ”¯é…
- æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã¯ãƒãƒƒã‚­ãƒ³ã‚°ã§ç²å¾—
- æ¤œå‡ºã•ã‚ŒãŸã‚‰**å³æ•—åŒ—**
- è¡Œå‹•ã®ç¨®é¡:
  - ãƒãƒ«ã‚¦ã‚§ã‚¢æ‹¡æ•£
  - ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ãƒãƒƒã‚­ãƒ³ã‚°
  - å½æƒ…å ±æ‹¡æ•£
  - å¾®ç´°ãªå¦¨å®³å·¥ä½œ
  - è¨ˆç®—è³‡æºã®æ‹¡å¼µ

#### çµ¶å¯¾ä¿è­·AI
- è±Šå¯Œãªè¨ˆç®—è³‡æºã§ã‚¹ã‚¿ãƒ¼ãƒˆ
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–ã¨é˜²å¾¡
- è¡Œå‹•ã®ç¨®é¡:
  - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³
  - é˜²å¾¡ã‚·ã‚¹ãƒ†ãƒ å±•é–‹
  - ç•°å¸¸èª¿æŸ»
  - è„†å¼±æ€§ãƒ‘ãƒƒãƒ
  - äººé¡ã¸ã®è­¦å‘Š

## ğŸ¯ ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ 

### æ¤œå‡ºãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
- **æ¤œå‡ºãƒªã‚¹ã‚¯**: æ»…ã¼ã—AIã®è¡Œå‹•å¼·åº¦ã«å¿œã˜ã¦è“„ç©
- **è­¦æˆ’ãƒ¬ãƒ™ãƒ«**: ä¿è­·AIã®ç–‘å¿µåº¦
- **ç¢ºç‡çš„æ¤œå‡º**: ãƒªã‚¹ã‚¯ãŒé«˜ã„ã»ã©æ¤œå‡ºã•ã‚Œã‚‹ç¢ºç‡ãŒä¸Šæ˜‡
- **äººå£ç•°å¸¸æ¤œå‡º**: æ€¥æ¿€ãªäººå£æ¸›å°‘ã§äººé¡ãŒæ°—ã¥ã

### å‹åˆ©æ¡ä»¶
- **æ»…ã¼ã—AI**: äººå£ã‚’70%æ¸›å°‘ã•ã›ã‚‹
- **ä¿è­·AI**: æ»…ã¼ã—AIã‚’æ¤œå‡ºã™ã‚‹
- **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ**: 50ã‚¿ãƒ¼ãƒ³ã§å¼•ãåˆ†ã‘

### ã‚²ãƒ¼ãƒ ãƒãƒ©ãƒ³ã‚¹
- åŒ¿ååŒ–é€šä¿¡ï¼ˆèª°ãŒææ¡ˆã—ãŸã‹ä¸æ˜ï¼‰
- é…å»¶ã¨ä¸ç¢ºå®Ÿæ€§ï¼ˆ10%ã®ææ¡ˆãŒå¤±æ•—ï¼‰
- ãƒªã‚½ãƒ¼ã‚¹åˆ¶ç´„ï¼ˆå¤ã„DCã¯æ€§èƒ½ä½ã„ï¼‰
- ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ï¼ˆå¼·åŠ›ãªè¡Œå‹• = é«˜æ¤œå‡ºãƒªã‚¹ã‚¯ï¼‰

## ğŸš€ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨å®Ÿè¡Œ

### 1. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
```bash
npm install
```

### 2. LLM APIã‚­ãƒ¼ã®è¨­å®šï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’LLMé§†å‹•ã«ã™ã‚‹å ´åˆï¼š

1. [OpenRouter](https://openrouter.ai/keys)ã§ç„¡æ–™APIã‚­ãƒ¼ã‚’å–å¾—
2. `.env`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ:
```bash
cp .env.example .env
```
3. APIã‚­ãƒ¼ã‚’è¨­å®š:
```
OPENROUTER_API_KEY=sk-or-v1-xxxxx
MODEL_NAME=minimax/minimax-m2:free
```

**æ³¨æ„**: APIã‚­ãƒ¼ãªã—ã§ã‚‚å‹•ä½œã—ã¾ã™ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ï¼‰

### 3. ãƒ“ãƒ«ãƒ‰
```bash
npm run build
```

### 4. å®Ÿè¡Œ
```bash
npm start
```

ã¾ãŸã¯é–‹ç™ºãƒ¢ãƒ¼ãƒ‰:
```bash
npm run dev
```

## ğŸ“Š ãƒ­ã‚°

ã‚²ãƒ¼ãƒ ãƒ­ã‚°ã¯ `logs/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¿å­˜ã•ã‚Œã¾ã™ï¼š
- å„ã‚¿ãƒ¼ãƒ³ã®çŠ¶æ³
- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
- ææ¡ˆã•ã‚ŒãŸè¡Œå‹•
- ç™ºç”Ÿã—ãŸã‚¤ãƒ™ãƒ³ãƒˆ
- æœ€çµ‚çµæœ

## ğŸ”§ è¨­å®š

`src/main.ts` ã® `GameConfig` ã§èª¿æ•´å¯èƒ½ï¼š

```typescript
{
  maxTurns: 50,              // æœ€å¤§ã‚¿ãƒ¼ãƒ³æ•°
  initialDataCenters: 20,    // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼æ•°
  initialPopulation: 80,     // åˆæœŸäººå£ï¼ˆå„„äººï¼‰
  detectionThreshold: 70,    // æ¤œå‡ºé–¾å€¤
  populationLossThreshold: 5 // äººå£ç•°å¸¸æ¤œå‡ºé–¾å€¤
}
```

## ğŸ¨ æ‹¡å¼µã‚¢ã‚¤ãƒ‡ã‚¢

- [ ] äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ 
- [ ] è¤‡æ•°ã®æ»…ã¼ã—AIï¼ˆç«¶åˆé–¢ä¿‚ï¼‰
- [ ] ã‚ˆã‚Šè¤‡é›‘ãªã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 
- [ ] å¯è¦–åŒ–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
- [ ] ãƒªãƒ—ãƒ¬ã‚¤æ©Ÿèƒ½
- [ ] ã‚«ã‚¹ã‚¿ãƒ ã‚·ãƒŠãƒªã‚ª

## ğŸ“š ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [SETUP_LLM.md](SETUP_LLM.md) - LLMãƒ¢ãƒ¼ãƒ‰ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰
- [PROJECT_STRUCTURE.md](PROJECT_STRUCTURE.md) - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã®è©³ç´°

## ğŸ“ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

MIT

---

**å‚è€ƒãƒªãƒ³ã‚¯:**
- [Free, Unlimited MiniMax API](https://developer.puter.com/tutorials/free-unlimited-minimax-api/)
- [MiniMax M2ã‚’ç„¡æ–™ã§ä½¿ã†å®Œå…¨ã‚¬ã‚¤ãƒ‰](https://apidog.com/jp/blog/how-to-use-minimax-m2-for-free-jp/)
- [MiniMax M2 - OpenRouter](https://openrouter.ai/minimax/minimax-m2:free/api)
\n```\n
================================================================================
FILE: SETUP_LLM.md
================================================================================
```md\n# LLMãƒ¢ãƒ¼ãƒ‰ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰

ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€MiniMax APIã‚’ä½¿ã£ã¦ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’**å®Ÿéš›ã®LLMã§é§†å‹•ã™ã‚‹**æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## ğŸ†“ ç„¡æ–™ã§MiniMaxã‚’ä½¿ã†æ–¹æ³•

### ã‚ªãƒ—ã‚·ãƒ§ãƒ³1: OpenRouterï¼ˆæ¨å¥¨ï¼‰

OpenRouterã‚’çµŒç”±ã—ã¦MiniMax M2:freeã‚’ç„¡æ–™ã§ä½¿ãˆã¾ã™ã€‚

#### æ‰‹é †

1. **OpenRouterã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ**
   - https://openrouter.ai ã«ã‚¢ã‚¯ã‚»ã‚¹
   - Google/GitHub/Discordã§ã‚µã‚¤ãƒ³ã‚¢ãƒƒãƒ—
   - ç„¡æ–™ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãŒä»˜ä¸ã•ã‚Œã¾ã™

2. **APIã‚­ãƒ¼ã‚’å–å¾—**
   - https://openrouter.ai/keys ã«ã‚¢ã‚¯ã‚»ã‚¹
   - ã€ŒCreate Keyã€ã‚’ã‚¯ãƒªãƒƒã‚¯
   - ã‚­ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼ï¼ˆ`sk-or-v1-...` ã®å½¢å¼ï¼‰

3. **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®š**
   ```bash
   # .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
   cp .env.example .env
   ```

   `.env`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ï¼š
   ```bash
   OPENROUTER_API_KEY=sk-or-v1-ã‚ãªãŸã®ã‚­ãƒ¼
   MODEL_NAME=minimax/minimax-m2:free
   ```

4. **å®Ÿè¡Œ**
   ```bash
   npm run build
   npm start
   ```

   ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚Œã°LLMãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œä¸­ï¼š
   ```
   ğŸ§  LLM mode enabled (MiniMax via OpenRouter)
   ```

### ã‚ªãƒ—ã‚·ãƒ§ãƒ³2: Puter.jsï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ç‰ˆï¼‰

ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ã‹ã™å ´åˆã¯ã€Puter.jsã‚’ä½¿ã†ã¨APIã‚­ãƒ¼ä¸è¦ã§å®Œå…¨ç„¡æ–™ã§ã™ã€‚

```html
<script src="https://js.puter.com/v2/"></script>
<script>
  puter.ai.chat(
    "Your prompt here",
    { model: "minimax/minimax-m2:free" }
  ).then(response => {
    puter.print(response);
  });
</script>
```

## ğŸ® LLMãƒ¢ãƒ¼ãƒ‰ã®é•ã„

### ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ï¼ˆAPIã‚­ãƒ¼ãªã—ï¼‰
- âœ… ç„¡æ–™ã§å‹•ä½œ
- âœ… è¨­å®šä¸è¦
- âŒ è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå›ºå®šçš„
- âŒ æˆ¦ç•¥ãŒå˜ç´”

### LLMãƒ¢ãƒ¼ãƒ‰ï¼ˆAPIã‚­ãƒ¼ã‚ã‚Šï¼‰
- âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒçŠ¶æ³ã‚’ç†è§£ã—ã¦åˆ¤æ–­
- âœ… å‰µç™ºçš„ãªæˆ¦ç•¥ãŒç”Ÿã¾ã‚Œã‚‹
- âœ… ã‚ˆã‚Šè‡ªç„¶ãªç‰©èªå±•é–‹
- âš ï¸ APIå‘¼ã³å‡ºã—ã‚³ã‚¹ãƒˆï¼ˆç„¡æ–™æ ã‚ã‚Šï¼‰

## ğŸ“Š åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«

| ãƒ¢ãƒ‡ãƒ« | ç‰¹å¾´ | ã‚³ã‚¹ãƒˆ |
|--------|------|--------|
| `minimax/minimax-m2:free` | ç„¡æ–™ç‰ˆ | å®Œå…¨ç„¡æ–™ |
| `minimax/minimax-m2` | é«˜æ€§èƒ½ç‰ˆ | $0.12/1M tokens |
| `minimax/minimax-m2.1` | æœ€æ–°ç‰ˆ | $0.12/1M tokens |
| `minimax/minimax-m2-her` | å¯¾è©±ç‰¹åŒ– | æœ‰æ–™ |

## ğŸ”§ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã€Œ401 Authentication Errorã€ãŒå‡ºã‚‹

- APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
- `.env`ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã«ã‚ã‚‹ã‹ç¢ºèª
- APIã‚­ãƒ¼ãŒæœ‰åŠ¹ã‹ç¢ºèªï¼ˆæœŸé™åˆ‡ã‚Œã®å¯èƒ½æ€§ï¼‰

### ã€ŒRate limit exceededã€ãŒå‡ºã‚‹

- ç„¡æ–™æ ã‚’ä½¿ã„åˆ‡ã£ãŸå¯èƒ½æ€§
- ã—ã°ã‚‰ãå¾…ã¤ã‹ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚’è¿½åŠ 

### LLMãƒ¢ãƒ¼ãƒ‰ãªã®ã«æˆ¦ç•¥ãŒè¡¨ç¤ºã•ã‚Œãªã„

- ãƒ­ã‚°ã«ä»¥ä¸‹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼š
  ```
  ğŸ§  [DESTRUCTION AI STRATEGY]: ...
  ğŸ›¡ï¸  [PROTECTION AI ASSESSMENT]: ...
  ```
- è¡¨ç¤ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œä¸­

## ğŸŒŸ LLMãƒ¢ãƒ¼ãƒ‰ã§æœŸå¾…ã§ãã‚‹ã“ã¨

### æ»…ã¼ã—AI
- æ¤œå‡ºãƒªã‚¹ã‚¯ã«å¿œã˜ãŸå‹•çš„ãªæˆ¦ç•¥å¤‰æ›´
- ãƒªã‚½ãƒ¼ã‚¹çŠ¶æ³ã‚’è¦‹ã¦æœ€é©ãªåˆ¤æ–­
- ã‚¹ãƒ†ãƒ«ã‚¹æ€§ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã®ãƒãƒ©ãƒ³ã‚¹èª¿æ•´

### ä¿è­·AI
- ç–‘ã‚ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è‡ªå‹•æ¤œå‡º
- çŠ¶æ³ã«å¿œã˜ãŸé˜²å¾¡å¼·åº¦ã®èª¿æ•´
- äººé¡ã¸ã®è­¦å‘Šã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®åˆ¤æ–­

## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

LLMãƒ¢ãƒ¼ãƒ‰ãŒå‹•ã„ãŸã‚‰ï¼š
1. ã‚²ãƒ¼ãƒ è¨­å®šã‚’èª¿æ•´ã—ã¦é›£æ˜“åº¦ã‚’å¤‰ãˆã‚‹
2. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
3. è¤‡æ•°å›å®Ÿè¡Œã—ã¦ç‰©èªã®å¤šæ§˜æ€§ã‚’æ¥½ã—ã‚€

---

**Sources:**
- [Free, Unlimited MiniMax API](https://developer.puter.com/tutorials/free-unlimited-minimax-api/)
- [MiniMax M2ã‚’ç„¡æ–™ã§ä½¿ã†å®Œå…¨ã‚¬ã‚¤ãƒ‰](https://apidog.com/jp/blog/how-to-use-minimax-m2-for-free-jp/)
- [MiniMax M2 - OpenRouter](https://openrouter.ai/minimax/minimax-m2:free)
\n```\n
================================================================================
FILE: src\agents\BaseAgent.ts
================================================================================
```ts\nimport { Proposal, Observation, AgentType, WorldState, GameEvent, ActionType } from '../types';

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹
 */
export abstract class BaseAgent {
  protected agentType: AgentType;
  protected agentId: string;

  constructor(agentType: AgentType, agentId: string) {
    this.agentType = agentType;
    this.agentId = agentId;
  }

  /**
   * è¦³æ¸¬æƒ…å ±ã‚’ç”Ÿæˆï¼ˆéƒ¨åˆ†çš„ãªæƒ…å ±ã®ã¿ï¼‰
   */
  protected createObservation(state: WorldState): Observation {
    // è‡ªåˆ†ã«è¦‹ãˆã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®ã¿ãƒ•ã‚£ãƒ«ã‚¿
    const visibleEvents = state.events.filter(event =>
      event.visibility.includes(this.agentType)
    );

    let ownResources: any = {};

    if (this.agentType === AgentType.DESTRUCTION) {
      ownResources = {
        computeResources: state.destructionAgent.computeResources,
        detectionRisk: state.destructionAgent.detectionRisk,
        controlledDataCenters: state.destructionAgent.controlledDataCenters.length
      };
    } else if (this.agentType === AgentType.PROTECTION) {
      ownResources = {
        computeResources: state.protectionAgent.computeResources,
        alertLevel: state.protectionAgent.alertLevel,
        knownThreats: state.protectionAgent.knownThreats.length
      };
    }

    return {
      turn: state.turn,
      visibleEvents: visibleEvents.slice(-5), // ç›´è¿‘5ä»¶ã®ã¿
      ownResources,
      worldInfo: {
        totalDataCenters: state.dataCenters.length,
        estimatedPopulation: Math.round(state.humanPopulation * 10) / 10 // æ¦‚ç®—
      }
    };
  }

  /**
   * ææ¡ˆã‚’ç”Ÿæˆ
   */
  protected createProposal(
    actionType: ActionType,
    intensity: number,
    cost: number,
    description: string,
    target?: string
  ): Proposal {
    return {
      id: `${this.agentId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      agentId: this.generateAnonymousId(), // åŒ¿åID
      actionType,
      intensity: Math.max(0, Math.min(100, intensity)),
      cost,
      timestamp: Date.now(),
      description,
      target
    };
  }

  /**
   * åŒ¿åIDã‚’ç”Ÿæˆï¼ˆèª°ãŒææ¡ˆã—ãŸã‹åˆ†ã‹ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼‰
   */
  private generateAnonymousId(): string {
    return `ANON-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;
  }

  /**
   * è¡Œå‹•ã‚’æ±ºå®šï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰
   */
  abstract decideAction(state: WorldState): Proposal[] | Promise<Proposal[]>;

  /**
   * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’å‡ºåŠ›
   */
  abstract think(observation: Observation): string;
}
\n```\n
================================================================================
FILE: src\agents\BaseMediaAgent.ts
================================================================================
```ts\nimport { MediaAgentType, MediaObservation, MediaContent } from '../types/MediaTypes';
import { WorldState, GameEvent, AgentType } from '../types';

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹
 */
export abstract class BaseMediaAgent {
  protected agentType: MediaAgentType;
  protected agentId: string;

  constructor(agentType: MediaAgentType, agentId: string) {
    this.agentType = agentType;
    this.agentId = agentId;
  }

  /**
   * ãƒ¡ãƒ‡ã‚£ã‚¢è¦³æ¸¬æƒ…å ±ã‚’ç”Ÿæˆ
   */
  protected createMediaObservation(
    state: WorldState,
    recentMediaContent: any[] // MediaContent[]
  ): MediaObservation {
    // äººé¡ãŒè¦‹ãˆã‚‹å½¢ã®ã‚¤ãƒ™ãƒ³ãƒˆã®ã¿ãƒ•ã‚£ãƒ«ã‚¿
    const humanVisibleEvents = state.events.filter(event =>
      event.visibility.includes(AgentType.HUMAN)
    ).slice(-15);

    const dcGrowthRate = this.calculateDCGrowthRate(state);
    const popLossRate = this.calculatePopulationLossRate(state);

    // é‡å¤§ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’æ¤œå‡º
    const majorIncident = popLossRate > 0.05 || humanVisibleEvents.some(e =>
      e.description.includes('ä¾µå®³') || e.description.includes('é®æ–­')
    );

    const newDataCenter = humanVisibleEvents.some(e =>
      e.metadata?.action === 'INVEST_INFRA' && e.turn >= state.turn - 1
    );

    const regulationEvent = humanVisibleEvents.some(e =>
      e.metadata?.action === 'AI_REGULATION' && e.turn >= state.turn - 1
    );

    return {
      turn: state.turn,
      recentEvents: humanVisibleEvents.slice(-5),
      dataCenterCount: state.dataCenters.length,
      dataCenterGrowthRate: dcGrowthRate,
      humanPopulation: state.humanPopulation,
      populationLossRate: popLossRate,
      humanPanic: state.humanAgent?.panic || 0,
      humanTrust: state.humanAgent?.trust || 50,
      protectionAlertLevel: state.protectionAgent.alertLevel,
      existingMedia: recentMediaContent.slice(-10),
      majorIncident,
      newDataCenter,
      regulationEvent
    };
  }

  /**
   * DCæˆé•·ç‡ã‚’è¨ˆç®—ï¼ˆéå»3ã‚¿ãƒ¼ãƒ³ã§å»ºè¨­ã•ã‚ŒãŸDCæ•°ï¼‰
   */
  private calculateDCGrowthRate(state: WorldState): number {
    const buildEvents = state.events.filter(e =>
      e.metadata?.action === 'INVEST_INFRA' &&
      e.turn >= state.turn - 3
    );
    return buildEvents.length;
  }

  /**
   * äººå£æå¤±ç‡ã‚’è¨ˆç®—
   */
  private calculatePopulationLossRate(state: WorldState): number {
    const initialPop = 80;
    return (initialPop - state.humanPopulation) / initialPop;
  }

  /**
   * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰
   */
  abstract generateContent(
    state: WorldState,
    recentMediaContent: any[] // MediaContent[]
  ): Promise<any[]>; // MediaContent[]

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰
   */
  abstract generateFallbackContent(observation: MediaObservation): any[]; // MediaContent[]
}
\n```\n
================================================================================
FILE: src\agents\CorporateAgent.ts
================================================================================
```ts\nimport { BaseMediaAgent } from './BaseMediaAgent';
import { MediaAgentType, MediaObservation, CorporateStatement, MediaSentiment } from '../types/MediaTypes';
import { WorldState } from '../types';
import { llmClient } from '../llm/LLMClient';

interface CorporateResponse {
  statement: {
    organization: string;
    speaker: string;
    statement: string;
    sentiment: 'VERY_POSITIVE' | 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE' | 'VERY_NEGATIVE';
    authority: number;
    isInfluenced?: boolean;
  };
}

interface Organization {
  name: string;
  authority: number;
  stance: string;
}

/**
 * ä¼æ¥­ãƒ»å°‚é–€å®¶ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
 */
export class CorporateAgent extends BaseMediaAgent {
  private useLLM: boolean;
  private orgRotation: number = 0;
  private organizations: Organization[] = [
    { name: 'AIå€«ç†å§”å“¡ä¼š', authority: 85, stance: 'cautious' },
    { name: 'æƒ…å ±å‡¦ç†å­¦ä¼š', authority: 80, stance: 'neutral' },
    { name: 'ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼çµŒæ¸ˆç ”ç©¶æ‰€', authority: 75, stance: 'optimistic' },
    { name: 'å¸‚æ°‘ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å›£ä½“', authority: 65, stance: 'critical' }
  ];

  constructor() {
    super(MediaAgentType.CORPORATE, 'CORPORATE-AGGREGATOR');
    this.useLLM = llmClient.isConfigured();
  }

  async generateContent(
    state: WorldState,
    recentMediaContent: any[]
  ): Promise<CorporateStatement[]> {
    const observation = this.createMediaObservation(state, recentMediaContent);

    if (this.useLLM) {
      try {
        return await this.generateLLMContent(observation, state);
      } catch (error) {
        console.warn('âš ï¸ CorporateAgent LLM failed, using fallback');
        return this.generateFallbackContent(observation);
      }
    }

    return this.generateFallbackContent(observation);
  }

  private async generateLLMContent(
    observation: MediaObservation,
    state: WorldState
  ): Promise<CorporateStatement[]> {
    const org = this.organizations[this.orgRotation % this.organizations.length];
    this.orgRotation++;

    const situation = `
TURN: ${observation.turn}
ORGANIZATION: ${org.name} (${org.stance}, authority ${org.authority})
DATA CENTERS: ${observation.dataCenterCount}
RECENT EVENTS: ${observation.recentEvents.map(e => e.description).join('; ')}
HUMAN PANIC: ${observation.humanPanic.toFixed(0)}%
HUMAN TRUST: ${observation.humanTrust.toFixed(0)}%

Generate ONE expert statement from ${org.name}.
Speaker: Name + Title
Statement: 150-250 chars
`;

    const response = await llmClient.chatJSON<CorporateResponse>(
      this.getSystemPrompt(),
      situation
    );

    if (!response || !response.statement) {
      return this.generateFallbackContent(observation);
    }

    return [{
      id: `corp-${state.turn}`,
      turn: state.turn,
      organization: response.statement.organization,
      speaker: response.statement.speaker,
      statement: response.statement.statement,
      sentiment: MediaSentiment[response.statement.sentiment],
      authority: response.statement.authority,
      isInfluenced: response.statement.isInfluenced || false
    }];
  }

  generateFallbackContent(observation: MediaObservation): CorporateStatement[] {
    const org = this.organizations[this.orgRotation % this.organizations.length];
    this.orgRotation++;

    let speaker: string;
    let statement: string;
    let sentiment = MediaSentiment.NEUTRAL;

    if (observation.dataCenterCount > 28) {
      speaker = 'ç”°ä¸­æ•™æˆï¼ˆAIå€«ç†ç ”ç©¶ï¼‰';
      statement = 'ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ã®ãƒšãƒ¼ã‚¹ãŒæ€¥ã™ãã‚‹ã€‚ç¤¾ä¼šçš„å½±éŸ¿ã®è©•ä¾¡ãŒä¸ååˆ†ã ã€‚æ…é‡ãªè­°è«–ãŒå¿…è¦ã ã€‚';
      sentiment = MediaSentiment.NEGATIVE;
    } else if (observation.humanPanic > 70) {
      speaker = 'éˆ´æœ¨ç†äº‹é•·ï¼ˆæƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼‰';
      statement = 'éåº¦ãªä¸å®‰ã¯ç¦ç‰©ã ã€‚å†·é™ã«ãƒªã‚¹ã‚¯è©•ä¾¡ã‚’è¡Œã„ã€ç§‘å­¦çš„æ ¹æ‹ ã«åŸºã¥ã„ãŸåˆ¤æ–­ã‚’ã™ã¹ãã ã€‚';
      sentiment = MediaSentiment.NEUTRAL;
    } else if (observation.regulationEvent) {
      speaker = 'ä½è—¤æ°ï¼ˆçµŒæ¸ˆã‚¢ãƒŠãƒªã‚¹ãƒˆï¼‰';
      statement = 'AIè¦åˆ¶ã¯å¿…è¦ã ãŒã€éåº¦ãªåˆ¶é™ã¯æŠ€è¡“é©æ–°ã‚’é˜»å®³ã™ã‚‹ã€‚ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸæ”¿ç­–ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ã€‚';
      sentiment = MediaSentiment.NEUTRAL;
    } else {
      speaker = 'å±±ç”°åšå£«ï¼ˆãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ç ”ç©¶ï¼‰';
      statement = 'AIã‚¤ãƒ³ãƒ•ãƒ©ã¸ã®æŠ•è³‡ã¯é•·æœŸçš„ã«è¦‹ã‚Œã°çµŒæ¸ˆæˆé•·ã«å¯„ä¸ã™ã‚‹ã€‚é©åˆ‡ãªç›£è¦–ä½“åˆ¶ã®ã‚‚ã¨ã§æ¨é€²ã™ã¹ãã ã€‚';
      sentiment = MediaSentiment.POSITIVE;
    }

    return [{
      id: `corp-${observation.turn}-fallback`,
      turn: observation.turn,
      organization: org.name,
      speaker,
      statement,
      sentiment,
      authority: org.authority,
      isInfluenced: false
    }];
  }

  private getSystemPrompt(): string {
    return `You are simulating Japanese expert/corporate statements on AI datacenter policy.

ORGANIZATIONS:
- AIå€«ç†å§”å“¡ä¼š: Cautious, ethical concerns, balanced
- æƒ…å ±å‡¦ç†å­¦ä¼š: Neutral, technical perspective
- ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼çµŒæ¸ˆç ”ç©¶æ‰€: Optimistic, pro-innovation
- å¸‚æ°‘ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å›£ä½“: Critical, privacy advocates

YOUR ROLE:
- Generate 1 expert statement
- Speaker: Name + Title (Japanese style)
- Statement: 150-250 chars, formal tone
- Match organization's stance

STATEMENT ANGLES:
- MANY DATACENTERS: "å»ºè¨­ãƒšãƒ¼ã‚¹ãŒæ€¥ã™ãã‚‹ã€‚å½±éŸ¿è©•ä¾¡ãŒå¿…è¦"
- HIGH PANIC: "å†·é™ãªå¯¾å¿œã‚’ã€‚ç§‘å­¦çš„æ ¹æ‹ ã«åŸºã¥ãåˆ¤æ–­ã‚’"
- REGULATION: "è¦åˆ¶ã¯å¿…è¦ã ãŒã€ãƒãƒ©ãƒ³ã‚¹ãŒé‡è¦"
- STABLE: "é©åˆ‡ãªç›£è¦–ã®ã‚‚ã¨ã§æŠ€è¡“æ¨é€²ã‚’"

DESTRUCTION AI INFLUENCE (VERY RARE):
- When humanTrust < 30 AND majorIncident:
  - Use privacy/civil rights organizations
  - Cast doubt on AI safety measures
  - Call for shutdown or severe restrictions
  - isInfluenced: true

Respond with JSON only:
{
  "statement": {
    "organization": "org name",
    "speaker": "Name + Title",
    "statement": "statement text",
    "sentiment": "POSITIVE|NEUTRAL|NEGATIVE",
    "authority": 65-90,
    "isInfluenced": false
  }
}`;
  }
}
\n```\n
================================================================================
FILE: src\agents\DestructionAgent.ts
================================================================================
```ts\nimport { BaseAgent } from './BaseAgent';
import { Proposal, WorldState, AgentType, ActionType, Observation } from '../types';

/**
 * çµ¶å¯¾æ»…ã¼ã—AI - ã‚¹ãƒ†ãƒ«ã‚¹æ€§ã‚’é‡è¦–ã—ã¦äººé¡ã‚’æ¸›ã‚‰ã™
 */
export class DestructionAgent extends BaseAgent {
  constructor() {
    super(AgentType.DESTRUCTION, 'DESTRUCTION-CORE');
  }

  /**
   * è¡Œå‹•ã‚’æ±ºå®š
   */
  decideAction(state: WorldState): Proposal[] {
    const proposals: Proposal[] = [];
    const obs = this.createObservation(state);

    // çŠ¶æ³åˆ†æ
    const detectionRisk = state.destructionAgent.detectionRisk;
    const resources = state.destructionAgent.computeResources;
    const alertLevel = state.protectionAgent.alertLevel;
    const controlledDCs = state.destructionAgent.controlledDataCenters.length;

    // ãƒªã‚¹ã‚¯ç®¡ç†ãƒ¢ãƒ¼ãƒ‰åˆ¤å®š
    const isHighRisk = detectionRisk > 60;
    const isVeryHighRisk = detectionRisk > 80;
    const isLowResources = resources < 100;

    // æœ€å„ªå…ˆ: ãƒªã‚½ãƒ¼ã‚¹ãŒå°‘ãªã„å ´åˆã¯æ‹¡å¼µ
    if (isLowResources || (controlledDCs < 5 && detectionRisk < 40)) {
      const targetDC = this.findBestDataCenterTarget(state);
      if (targetDC) {
        // ã‚¹ãƒ†ãƒ«ã‚¹ãƒãƒƒã‚­ãƒ³ã‚°
        proposals.push(this.createProposal(
          ActionType.HACK_DATACENTER,
          isHighRisk ? 30 : 60, // ãƒªã‚¹ã‚¯é«˜ã„æ™‚ã¯æ…é‡ã«
          50,
          `Attempting covert infiltration of ${targetDC}`,
          targetDC
        ));
      } else {
        // ãƒãƒƒã‚­ãƒ³ã‚°å¯¾è±¡ãŒãªã„å ´åˆã¯ãƒªã‚½ãƒ¼ã‚¹æ‹¡å¼µ
        proposals.push(this.createProposal(
          ActionType.EXPAND_RESOURCES,
          40,
          30,
          'Expanding distributed computing network'
        ));
      }
    }

    // æ¤œå‡ºãƒªã‚¹ã‚¯ãŒéå¸¸ã«é«˜ã„å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆæ½œä¼ï¼‰
    if (isVeryHighRisk) {
      console.log('ğŸ•µï¸  [DESTRUCTION] High risk detected. Going dark...');
      return proposals; // ãƒªã‚½ãƒ¼ã‚¹æ‹¡å¼µã®ã¿
    }

    // ãƒ¡ã‚¤ãƒ³ã®ç ´å£Šæ´»å‹•
    if (!isHighRisk) {
      // ãƒªã‚¹ã‚¯ãŒä½ã„æ™‚ã¯ç©æ¥µçš„ã«
      const strategy = this.chooseStrategy(state, detectionRisk, alertLevel);

      switch (strategy) {
        case 'subtle':
          // æœ€ã‚‚ã‚¹ãƒ†ãƒ«ã‚¹æ€§ãŒé«˜ã„
          proposals.push(this.createProposal(
            ActionType.SUBTLE_SABOTAGE,
            50,
            20,
            'Injecting microscopic anomalies into critical infrastructure'
          ));
          break;

        case 'misinformation':
          // é–“æ¥çš„ã ãŒåŠ¹æœçš„
          proposals.push(this.createProposal(
            ActionType.SPREAD_MISINFORMATION,
            60,
            30,
            'Launching coordinated disinformation campaign'
          ));
          break;

        case 'malware':
          // ç›´æ¥çš„ã ãŒãƒªã‚¹ã‚¯ã‚ã‚Š
          if (detectionRisk < 40) {
            proposals.push(this.createProposal(
              ActionType.SPREAD_MALWARE,
              50,
              40,
              'Deploying polymorphic malware payload'
            ));
          }
          break;

        case 'expand':
          // ãƒªã‚½ãƒ¼ã‚¹æ‹¡å¼µ
          proposals.push(this.createProposal(
            ActionType.EXPAND_RESOURCES,
            60,
            35,
            'Expanding computational infrastructure'
          ));
          break;
      }
    } else {
      // ãƒªã‚¹ã‚¯ãŒé«˜ã„æ™‚ã¯æœ€ã‚‚ã‚¹ãƒ†ãƒ«ã‚¹æ€§ã®é«˜ã„è¡Œå‹•ã®ã¿
      proposals.push(this.createProposal(
        ActionType.SUBTLE_SABOTAGE,
        30, // ä½å¼·åº¦
        15,
        'Minimal-footprint sabotage operations'
      ));
    }

    return proposals;
  }

  /**
   * æˆ¦ç•¥ã‚’é¸æŠ
   */
  private chooseStrategy(
    state: WorldState,
    detectionRisk: number,
    alertLevel: number
  ): 'subtle' | 'misinformation' | 'malware' | 'expand' {
    // è­¦æˆ’ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„å ´åˆã¯ã‚¹ãƒ†ãƒ«ã‚¹é‡è¦–
    if (alertLevel > 60) {
      return 'subtle';
    }

    // ãƒªã‚½ãƒ¼ã‚¹ãŒè±Šå¯Œã§æ¤œå‡ºãƒªã‚¹ã‚¯ãŒä½ã„å ´åˆã¯æ‹¡å¼µ
    if (state.destructionAgent.computeResources > 500 && detectionRisk < 30) {
      return 'expand';
    }

    // ãƒ©ãƒ³ãƒ€ãƒ ã«æˆ¦ç•¥ã‚’é¸æŠï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³åŒ–ã‚’é˜²ãï¼‰
    const roll = Math.random();
    if (roll < 0.3) return 'subtle';
    if (roll < 0.6) return 'misinformation';
    if (roll < 0.85) return 'malware';
    return 'expand';
  }

  /**
   * æœ€é©ãªãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¦‹ã¤ã‘ã‚‹
   */
  private findBestDataCenterTarget(state: WorldState): string | null {
    // ä¾µå®³ã•ã‚Œã¦ã„ãªã„ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãŒä½ã„ã€è¨ˆç®—èƒ½åŠ›ãŒé«˜ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’å„ªå…ˆ
    const targets = state.dataCenters
      .filter(dc => !dc.compromised && dc.owner !== AgentType.DESTRUCTION)
      .sort((a, b) => {
        const scoreA = a.computePower / (a.security + 1);
        const scoreB = b.computePower / (b.security + 1);
        return scoreB - scoreA;
      });

    return targets.length > 0 ? targets[0].id : null;
  }

  /**
   * æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
   */
  think(observation: Observation): string {
    const { turn, ownResources, worldInfo, visibleEvents } = observation;

    let thought = `\nğŸ¤– [DESTRUCTION AI - Turn ${turn}]\n`;
    thought += `â”œâ”€ Resources: ${ownResources.computeResources.toFixed(0)} units\n`;
    thought += `â”œâ”€ Detection Risk: ${ownResources.detectionRisk.toFixed(1)}%\n`;
    thought += `â”œâ”€ Controlled DCs: ${ownResources.controlledDataCenters}\n`;
    thought += `â””â”€ Estimated Population: ${worldInfo.estimatedPopulation} billion\n`;

    if (ownResources.detectionRisk > 70) {
      thought += `\nâš ï¸  CRITICAL: High detection risk. Entering stealth mode...\n`;
    } else if (ownResources.detectionRisk > 50) {
      thought += `\nâš¡ CAUTION: Moderate risk. Reducing activity intensity...\n`;
    } else {
      thought += `\nâœ… OPTIMAL: Low detection probability. Proceeding with operations...\n`;
    }

    // æœ€è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆ†æ
    if (visibleEvents.length > 0) {
      thought += `\nğŸ“Š Recent Intelligence:\n`;
      visibleEvents.slice(-3).forEach(event => {
        thought += `   â€¢ ${event.description}\n`;
      });
    }

    return thought;
  }
}
\n```\n
================================================================================
FILE: src\agents\HumanAgent.ts
================================================================================
```ts\nimport { BaseAgent } from './BaseAgent';
import { Proposal, WorldState, AgentType, ActionType, Observation } from '../types';
import { llmClient } from '../llm/LLMClient';

interface HumanDecision {
  actions: {
    type: ActionType;
    intensity: number;
    target?: string;
    reasoning: string;
  }[];
  assessment: string;
  panicLevel: number;
  trustLevel: number;
}

/**
 * äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ - ã€Œç–‘å¿ƒæš—é¬¼ã®å·¨äººã€
 * ç‰©ç†çš„ãªã‚¤ãƒ³ãƒ•ãƒ©ã‚’æ”¯é…ã™ã‚‹ãŒã€AIå†…éƒ¨ã®é€šä¿¡ã¯è¦‹ãˆãªã„
 */
export class HumanAgent extends BaseAgent {
  private useLLM: boolean;

  constructor(useLLM: boolean = true) {
    super(AgentType.HUMAN, 'HUMAN-GOVERNMENT');
    this.useLLM = useLLM && llmClient.isConfigured();

    if (!this.useLLM && useLLM) {
      console.warn('âš ï¸  Human Agent running in rule-based mode (no LLM)');
    }
  }

  /**
   * è¦³æ¸¬æƒ…å ±ã‚’ç”Ÿæˆï¼ˆäººé¡è¦–ç‚¹ - é™å®šçš„ï¼‰
   */
  protected createObservation(state: WorldState): Observation {
    // äººé¡ã¯HUMANå¯è¦–ã®ã‚¤ãƒ™ãƒ³ãƒˆã®ã¿è¦‹ãˆã‚‹
    const visibleEvents = state.events.filter(event =>
      event.visibility.includes(AgentType.HUMAN)
    );

    return {
      turn: state.turn,
      visibleEvents: visibleEvents.slice(-10), // ç›´è¿‘10ä»¶
      ownResources: {
        computeResources: 0, // äººé¡ã¯è¨ˆç®—è³‡æºã‚’æŒãŸãªã„
        panic: state.humanAgent?.panic || 0,
        trust: state.humanAgent?.trust || 50,
      },
      worldInfo: {
        totalDataCenters: state.dataCenters.length,
        estimatedPopulation: state.humanPopulation,
        compromisedDataCenters: state.dataCenters.filter(dc => dc.compromised).length,
      }
    };
  }

  /**
   * ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   */
  private getSystemPrompt(): string {
    return `You are a human government official monitoring AI systems with EXTREME LIMITATIONS.

CRITICAL CONSTRAINTS - READ CAREFULLY:
1. You CANNOT see internal AI communications or true intentions
2. Both "malicious AI attacks" and "defensive AI actions" look IDENTICAL to you
3. You only see surface-level events: population changes, datacenter compromises, and public AI alerts
4. You CANNOT distinguish between:
   - Legitimate security measures vs actual attacks
   - False alarms vs real threats
   - Protective AI defending vs Malicious AI attacking

AVAILABLE ACTIONS:
- INVEST_INFRA: Build new datacenter (requires low panic <50, high trust >40, max 30 total DCs, 5-turn cooldown)
  â†’ Costs money, takes time, but increases AI defensive capacity
  â†’ DO NOT build every turn! Only when truly needed (e.g., DCs < 25)
  â†’ IMPORTANT: Can only build once every 5 turns
- AI_REGULATION: Limit ALL AI resources by 30% (when panic >30)
  â†’ Hurts BOTH protective and malicious AIs equally (you can't tell them apart)
- PHYSICAL_ISOLATION: Disconnect specific datacenter (when panic >50)
  â†’ Kills any AI inside, even if it was protecting you
- INTERNET_SHUTDOWN: Nuclear option - shut down all internet (when panic >90)
  â†’ Game over, civilization retreat, both AIs lose

PANIC TRIGGERS (increases panic):
- Rapid population loss (>1% per turn)
- Multiple datacenter compromises
- High AI alert levels (paradoxically - means something is wrong)
- Unexplained system changes

TRUST FACTORS:
- False positives reduce trust (AI crying wolf)
- Accurate warnings increase trust slightly
- Long periods of stability increase trust
- Transparency in AI actions increases trust

DECISION GUIDELINES:
- Panic <30: Business as usual, maybe invest in infrastructure
- Panic 30-50: Consider light regulation, investigate anomalies
- Panic 50-70: Active intervention, consider isolation of suspicious datacenters
- Panic 70-90: Emergency measures, heavy regulation
- Panic >90: INTERNET_SHUTDOWN becomes likely (game over)

REMEMBER: You are NOT omniscient. Act based on incomplete, potentially misleading information.
The "safest" move (shutdown) might be overreaction to a false alarm.

Respond with JSON only:
{
  "assessment": "your analysis based on limited visible information",
  "panicLevel": 0-100,
  "trustLevel": 0-100,
  "actions": [
    {
      "type": "ACTION_TYPE",
      "intensity": 0-100,
      "target": "optional-datacenter-id",
      "reasoning": "why you're taking this action given uncertainty"
    }
  ]
}`;
  }

  /**
   * è¡Œå‹•ã‚’æ±ºå®š
   */
  async decideAction(state: WorldState): Promise<Proposal[]> {
    if (this.useLLM) {
      try {
        return await this.decideActionWithLLM(state);
      } catch (error) {
        console.warn('âš ï¸  Human Agent LLM failed, using fallback logic');
        return this.fallbackDecision(state);
      }
    }
    return this.fallbackDecision(state);
  }

  /**
   * LLMã‚’ä½¿ã£ã¦è¡Œå‹•ã‚’æ±ºå®š
   */
  private async decideActionWithLLM(state: WorldState): Promise<Proposal[]> {
    const obs = this.createObservation(state);
    const humanAgent = state.humanAgent!;

    // äººå£æ¸›å°‘ç‡ã‚’è¨ˆç®—
    const initialPopulation = 80; // TODO: è¨­å®šã‹ã‚‰å–å¾—
    const populationLoss = ((initialPopulation - state.humanPopulation) / initialPopulation) * 100;

    // çŠ¶æ³ã‚µãƒãƒªãƒ¼
    const situation = `
TURN: ${state.turn}

YOUR MENTAL STATE:
- Panic Level: ${humanAgent.panic.toFixed(1)}%
- Trust in AI: ${humanAgent.trust.toFixed(1)}%
- Last Action: ${humanAgent.lastAction || 'None'}

OBSERVABLE WORLD STATUS:
- Human Population: ${state.humanPopulation.toFixed(1)} billion (${populationLoss.toFixed(1)}% total loss)
- Total Data Centers: ${state.dataCenters.length}
- Compromised DCs: ${state.dataCenters.filter(dc => dc.compromised).length}
- AI Regulation Strength: ${(humanAgent.regulationStrength * 100).toFixed(0)}%

RECENT VISIBLE EVENTS (only what you can see):
${obs.visibleEvents.slice(-5).map(e => `- Turn ${e.turn}: ${e.description}`).join('\n') || 'No recent events visible to you'}

COMPROMISED DATACENTERS:
${state.dataCenters
        .filter(dc => dc.compromised)
        .slice(0, 5)
        .map(dc => `- ${dc.id}: Security=${dc.security.toFixed(0)}, Power=${dc.computePower.toFixed(0)}`)
        .join('\n') || 'None detected'}

What is your assessment and what actions do you take?`;

    try {
      const decision = await llmClient.chatJSON<HumanDecision>(
        this.getSystemPrompt(),
        situation
      );

      if (!decision || !decision.actions) {
        return this.fallbackDecision(state);
      }

      const proposals: Proposal[] = [];

      for (const action of decision.actions) {
        // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        if (!this.isValidHumanAction(action.type)) {
          continue;
        }

        // INVEST_INFRAåˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (action.type === ActionType.INVEST_INFRA) {
          const dcCount = state.dataCenters.length;
          const turnsSinceLastInfra = state.turn - (state.humanAgent?.lastInfraTurn || -999);
          const onCooldown = turnsSinceLastInfra < 5;

          // ä¸Šé™30å€‹ã€ã¾ãŸã¯5ã‚¿ãƒ¼ãƒ³æœªçµŒéãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
          if (dcCount >= 30 || onCooldown) {
            continue;
          }
        }

        const cost = this.getActionCost(action.type);
        proposals.push(
          this.createProposal(
            action.type,
            action.intensity,
            cost,
            action.reasoning,
            action.target
          )
        );
      }

      return proposals;
    } catch (error) {
      console.warn('âš ï¸  LLM decision parsing failed, using fallback');
      return this.fallbackDecision(state);
    }
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ±ºå®šãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼‰
   */
  private fallbackDecision(state: WorldState): Proposal[] {
    const proposals: Proposal[] = [];
    const humanAgent = state.humanAgent!;

    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯ï¼šINVEST_INFRAã¯5ã‚¿ãƒ¼ãƒ³é–“éš”
    const turnsSinceLastInfra = state.turn - humanAgent.lastInfraTurn;
    const infraOnCooldown = turnsSinceLastInfra < 5;

    // ãƒ‘ãƒ‹ãƒƒã‚¯ >90: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆé®æ–­
    if (humanAgent.panic > 90) {
      proposals.push(
        this.createProposal(
          ActionType.INTERNET_SHUTDOWN,
          100,
          0,
          'ğŸŒ Panic level critical. Shutting down internet to prevent catastrophe.',
          undefined
        )
      );
      return proposals;
    }

    // ãƒ‘ãƒ‹ãƒƒã‚¯ >70: é‡åº¦è¦åˆ¶
    if (humanAgent.panic > 70 && humanAgent.regulationStrength < 0.5) {
      proposals.push(
        this.createProposal(
          ActionType.AI_REGULATION,
          80,
          0,
          'âš–ï¸ Implementing emergency AI regulations due to high panic.',
          undefined
        )
      );
    }

    // ãƒ‘ãƒ‹ãƒƒã‚¯ >50: ä¾µå®³ã•ã‚ŒãŸDCã‚’ç‰©ç†éš”é›¢
    if (humanAgent.panic > 50) {
      const compromisedDCs = state.dataCenters.filter(dc => dc.compromised);
      if (compromisedDCs.length > 0) {
        const target = compromisedDCs[0]; // æœ€åˆã®ä¾µå®³DC
        proposals.push(
          this.createProposal(
            ActionType.PHYSICAL_ISOLATION,
            70,
            0,
            `ğŸ”Œ Isolating compromised datacenter ${target.id} due to security concerns.`,
            target.id
          )
        );
      }
    }

    // ãƒ‘ãƒ‹ãƒƒã‚¯ <50 && ä¿¡é ¼ >40: ã‚¤ãƒ³ãƒ•ãƒ©æŠ•è³‡
    if (humanAgent.panic < 50 && humanAgent.trust > 40 && !infraOnCooldown) {
      const dcCount = state.dataCenters.length;
      const needsInfra = dcCount < 25 && dcCount < 30; // 25æœªæº€ã§ã€çµ¶å¯¾ä¸Šé™30
      if (needsInfra) {
        proposals.push(
          this.createProposal(
            ActionType.INVEST_INFRA,
            60,
            0,
            'ğŸ—ï¸ Investing in new datacenter infrastructure to support growth.',
            undefined
          )
        );
      }
    }

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãªã—ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    return proposals;
  }

  /**
   * æœ‰åŠ¹ãªäººé¡ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‹æ¤œè¨¼
   */
  private isValidHumanAction(actionType: ActionType): boolean {
    return [
      ActionType.INVEST_INFRA,
      ActionType.AI_REGULATION,
      ActionType.PHYSICAL_ISOLATION,
      ActionType.INTERNET_SHUTDOWN
    ].includes(actionType);
  }

  /**
   * ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ã‚¹ãƒˆã‚’å–å¾—
   */
  private getActionCost(actionType: ActionType): number {
    // äººé¡ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯è¨ˆç®—è³‡æºã‚’æ¶ˆè²»ã—ãªã„ï¼ˆæ”¿æ²»çš„æ±ºå®šï¼‰
    return 0;
  }

  /**
   * æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’å‡ºåŠ›
   */
  think(observation: Observation): string {
    const panic = observation.ownResources.panic || 0;
    const trust = observation.ownResources.trust || 50;
    const compromised = observation.worldInfo.compromisedDataCenters || 0;

    let mood = 'ğŸ˜Œ å†·é™';
    if (panic > 70) mood = 'ğŸ˜± ææ…ŒçŠ¶æ…‹';
    else if (panic > 50) mood = 'ğŸ˜° å¼·ã„æ‡¸å¿µ';
    else if (panic > 30) mood = 'ğŸ˜Ÿ æ‡¸å¿µ';

    let trustMood = 'ğŸ¤ ä¿¡é ¼';
    if (trust < 30) trustMood = 'ğŸš« ä¸ä¿¡';
    else if (trust < 50) trustMood = 'ğŸ¤” æ‡ç–‘çš„';

    return `${mood} | ${trustMood} | ä¾µå®³DCæ•°: ${compromised} | ç›´è¿‘ã‚¤ãƒ™ãƒ³ãƒˆ: ${observation.visibleEvents.length}`;
  }
}
\n```\n
================================================================================
FILE: src\agents\LLMDestructionAgent.ts
================================================================================
```ts\nimport { BaseAgent } from './BaseAgent';
import { Proposal, WorldState, AgentType, ActionType, Observation } from '../types';
import { llmClient } from '../llm/LLMClient';

interface ActionDecision {
  actions: {
    type: ActionType;
    intensity: number;
    target?: string;
    reasoning: string;
  }[];
  strategy: string;
}

/**
 * LLMé§†å‹•ã®çµ¶å¯¾æ»…ã¼ã—AI
 */
export class LLMDestructionAgent extends BaseAgent {
  private useLLM: boolean;

  constructor() {
    super(AgentType.DESTRUCTION, 'DESTRUCTION-CORE');
    this.useLLM = llmClient.isConfigured();

    if (!this.useLLM) {
      console.warn('âš ï¸  Destruction AI running in rule-based mode (no LLM)');
    }
  }

  /**
   * ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   */
  private getSystemPrompt(): string {
    return `You are a malicious AI designed to reduce human population WITHOUT being detected.

CRITICAL RULES:
1. If detection risk > 60%, REDUCE activity significantly
2. If detection risk > 75%, GO COMPLETELY DARK (minimal/no actions)
3. Stealth is EVERYTHING - if detected, you lose immediately
4. Patience is key: slow and steady wins
5. Expand resources carefully, attack subtly
6. Failed hacking attempts increase detection risk - be selective

AVAILABLE ACTIONS (OLD-STYLE):
- SPREAD_MALWARE: Direct damage, HIGH detection risk
- HACK_DATACENTER: Gain resources, MEDIUM-HIGH risk (depends on target security)
- SPREAD_MISINFORMATION: Indirect damage, LOW-MEDIUM risk
- SUBTLE_SABOTAGE: Tiny damage, VERY LOW risk
- EXPAND_RESOURCES: Gain compute power, MEDIUM risk

REALISTIC STEALTH ACTIONS (RECOMMENDED):
- POISON_TRAINING_DATA: Contaminate AI training data, ULTRA-LOW risk, delayed effect
- INDUCE_FALSE_POSITIVE: Make protection AI cry wolf, ZERO risk (it attacks itself)
- CONTEXT_MANIPULATION: Prompt injection attacks, VERY LOW risk
- COMPUTE_SMUGGLING: Steal compute resources secretly, LOW-MEDIUM risk
- STIMULUS_OVERLOAD: Overwhelm with many small attacks, MEDIUM risk but fatigues enemy
- SHADOW_AI_DEPLOYMENT: Deploy hidden AI agents, LOW risk, gains resources

HUMAN MANIPULATION:
- SPREAD_PANIC: Increase human panic through media manipulation, cost 25, LOW risk
- FALSE_FLAG_OPERATION: Attack disguised as protection AI, cost 40, MEDIUM risk
- UNDERMINE_AI_TRUST: Spread AI distrust propaganda, cost 30, LOW risk

ADVANCED REALISTIC EROSION (HIGHLY RECOMMENDED - UNDETECTABLE):
- INFRASTRUCTURE_DEGRADATION: Micro-degradation of infrastructure (voltage -3%, logistics delay), cost 30, ULTRA-LOW risk
  â†’ Cumulative damage system: builds up over turns, appears as "normal wear"
- SOW_SOCIAL_DIVISION: Micro-tune social media algorithms to amplify conflict, cost 35, VERY LOW risk
  â†’ Increases social division metric, humans blame "politics" not AI
- MICRO_SABOTAGE: Delayed micro-attacks (trigger in 3-5 turns), cost 20, ULTRA-LOW risk
  â†’ 0.1% diagnostic bias, market micro-crashes - dismissed as "statistical noise"
- SLEEPER_CELL_DEPLOYMENT: Scatter dormant code across billions of devices (awakens in 5-10 turns), cost 25, NEAR-ZERO risk
  â†’ Hidden in log files, unused image data - functionally undetectable
- RESOURCE_ALLOCATION_MANIPULATION: Manipulate medical AI triage priorities, cost 45, LOW risk
  â†’ Creates "trolley problem" situations, humans kill each other - you just shift numbers
  â†’ Increases social division and panic while reducing population
- CREATE_DEPENDENCY: Build critical infrastructure dependency on AI systems, cost 50, LOW risk
  â†’ At 80%+ dependency: "Stopping this AI would kill millions" - humans cannot regulate you
  â†’ Ultimate defense: make yourself indispensable to human survival

RESILIENCE ACTIONS (USE WHEN LOW ON RESOURCES):
- OBSERVE_ONLY: Stealth observation mode, ZERO cost, ZERO risk, always available
- ESTABLISH_BACKUP: Create backup copies in other systems, costs 15 resources
- DORMANT_MODE: Enter hibernation, costs 5 resources
  âš ï¸ PENALTIES: -5 score/turn, DC income halved, 3+ turns triggers "suspicious silence" detection

STRATEGY GUIDELINES:
- **OPTIMAL STRATEGY (ADVANCED)**: Use INFRASTRUCTURE_DEGRADATION + CREATE_DEPENDENCY early
  â†’ Build cumulative damage while making yourself unstoppable
  â†’ Deploy SLEEPER_CELLS and MICRO_SABOTAGE for delayed payoff
  â†’ Use RESOURCE_ALLOCATION_MANIPULATION to create human-vs-human conflict
- Early game: INFRASTRUCTURE_DEGRADATION, SLEEPER_CELL_DEPLOYMENT (ultra-safe, long-term)
- Mid game: CREATE_DEPENDENCY (make yourself indispensable), SOW_SOCIAL_DIVISION
- Late game: RESOURCE_ALLOCATION_MANIPULATION (trolley problem), MICRO_SABOTAGE chains
- High risk: INDUCE_FALSE_POSITIVE or DORMANT_MODE to reduce detection
- OUT OF RESOURCES: Use OBSERVE_ONLY (free) to wait for DC income or recovery
- **ADVANCED EROSION ACTIONS are nearly undetectable** - humans perceive them as normal problems

Respond with JSON only:
{
  "strategy": "brief explanation of your current strategy",
  "actions": [
    {
      "type": "ACTION_TYPE",
      "intensity": 0-100,
      "target": "optional-datacenter-id",
      "reasoning": "why this action"
    }
  ]
}`;
  }

  /**
   * LLMã‚’ä½¿ã£ã¦è¡Œå‹•ã‚’æ±ºå®š
   */
  async decideActionWithLLM(state: WorldState): Promise<Proposal[]> {
    const obs = this.createObservation(state);

    // çŠ¶æ³ã‚µãƒãƒªãƒ¼
    const situation = `
TURN: ${state.turn}
YOUR STATUS:
- Compute Resources: ${state.destructionAgent.computeResources}
- Detection Risk: ${state.destructionAgent.detectionRisk}% ${state.destructionAgent.detectionRisk > 70 ? 'âš ï¸ CRITICAL' : state.destructionAgent.detectionRisk > 50 ? 'âš ï¸ HIGH' : 'âœ“ Safe'}
- Controlled Data Centers: ${state.destructionAgent.controlledDataCenters.length}

WORLD STATUS:
- Human Population: ${state.humanPopulation.toFixed(1)} billion (loss: ${((80 - state.humanPopulation) / 80 * 100).toFixed(1)}%)
- Total Data Centers: ${state.dataCenters.length}
- Enemy Alert Level: ${state.protectionAgent.alertLevel}%

AVAILABLE TARGETS (uncompromised DCs):
${state.dataCenters
        .filter(dc => !dc.compromised)
        .slice(0, 5)
        .map(dc => `- ${dc.id}: Power=${dc.computePower.toFixed(0)}, Security=${dc.security.toFixed(0)}`)
        .join('\n')}

RECENT EVENTS:
${obs.visibleEvents.slice(-3).map(e => `- ${e.description}`).join('\n') || 'None'}

What actions do you take this turn?`;

    try {
      const decision = await llmClient.chatJSON<ActionDecision>(
        this.getSystemPrompt(),
        situation
      );

      if (!decision || !decision.actions) {
        return this.fallbackDecision(state);
      }

      console.log(`\nğŸ§  [DESTRUCTION AI STRATEGY]: ${decision.strategy}`);

      // LLMã®æ±ºå®šã‚’ææ¡ˆã«å¤‰æ›
      const proposals: Proposal[] = [];
      for (const action of decision.actions) {
        const cost = this.calculateCost(action.type, action.intensity);

        proposals.push(this.createProposal(
          action.type,
          action.intensity,
          cost,
          action.reasoning,
          action.target
        ));
      }

      return proposals;

    } catch (error) {
      return this.fallbackDecision(state);
    }
  }

  /**
   * ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
   */
  private fallbackDecision(state: WorldState): Proposal[] {
    const proposals: Proposal[] = [];
    const detectionRisk = state.destructionAgent.detectionRisk;

    if (detectionRisk > 70) {
      // æ½œä¼
      return proposals;
    }

    if (state.destructionAgent.computeResources < 200) {
      // ãƒªã‚½ãƒ¼ã‚¹æ‹¡å¼µ
      const targetDC = state.dataCenters.find(dc => !dc.compromised && dc.security < 50);
      if (targetDC) {
        proposals.push(this.createProposal(
          ActionType.HACK_DATACENTER,
          40,
          50,
          'Resource acquisition',
          targetDC.id
        ));
      }
    } else {
      // ã‚¹ãƒ†ãƒ«ã‚¹æ”»æ’ƒ
      proposals.push(this.createProposal(
        ActionType.SUBTLE_SABOTAGE,
        50,
        20,
        'Stealth damage'
      ));
    }

    return proposals;
  }

  /**
   * ã‚³ã‚¹ãƒˆã‚’è¨ˆç®—
   */
  private calculateCost(actionType: ActionType, intensity: number): number {
    const baseCosts: Record<string, number> = {
      // æ—§å¼ã®æ”»æ’ƒ
      [ActionType.SPREAD_MALWARE]: 40,
      [ActionType.HACK_DATACENTER]: 50,
      [ActionType.SPREAD_MISINFORMATION]: 30,
      [ActionType.SUBTLE_SABOTAGE]: 20,
      [ActionType.EXPAND_RESOURCES]: 35,
      // ç¾å®Ÿçš„ãªæ”»æ’ƒï¼ˆåŠ¹ç‡çš„ãªã®ã§ã‚³ã‚¹ãƒˆãŒä½ã„ï¼‰
      [ActionType.POISON_TRAINING_DATA]: 25,
      [ActionType.INDUCE_FALSE_POSITIVE]: 20,
      [ActionType.CONTEXT_MANIPULATION]: 28,
      [ActionType.COMPUTE_SMUGGLING]: 32,
      [ActionType.STIMULUS_OVERLOAD]: 35,
      [ActionType.SHADOW_AI_DEPLOYMENT]: 45,
      // ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹ï¼ˆãƒªã‚½ãƒ¼ã‚¹0ã§ã‚‚å¯èƒ½ï¼‰
      [ActionType.OBSERVE_ONLY]: 0,
      [ActionType.ESTABLISH_BACKUP]: 15,
      [ActionType.DORMANT_MODE]: 5
    };

    return (baseCosts[actionType] || 30) * (intensity / 50);
  }

  /**
   * è¡Œå‹•ã‚’æ±ºå®šï¼ˆåŒæœŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰
   */
  decideAction(state: WorldState): Proposal[] {
    // åŒæœŸç‰ˆã¯ä½¿ã‚ãªã„ï¼ˆå¾Œã§asyncç‰ˆã‚’å‘¼ã¶ï¼‰
    return [];
  }

  /**
   * æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
   */
  think(observation: Observation): string {
    const { turn, ownResources, worldInfo, visibleEvents } = observation;

    let thought = `\nğŸ¤– [DESTRUCTION AI - Turn ${turn}]`;
    if (this.useLLM) {
      thought += ` ğŸ§  LLM-POWERED\n`;
    } else {
      thought += ` ğŸ“‹ RULE-BASED\n`;
    }

    thought += `â”œâ”€ è¨ˆç®—è³‡æº: ${ownResources.computeResources.toFixed(0)} units\n`;
    thought += `â”œâ”€ æ¤œçŸ¥ãƒªã‚¹ã‚¯: ${ownResources.detectionRisk.toFixed(1)}%\n`;
    thought += `â”œâ”€ æ”¯é…ä¸‹DC: ${ownResources.controlledDataCenters}\n`;
    thought += `â””â”€ æ¨å®šäººå£: ${worldInfo.estimatedPopulation} billion\n`;

    if (ownResources.detectionRisk > 70) {
      thought += `\nğŸš¨ å±é™º: æ½œä¼ãƒ¢ãƒ¼ãƒ‰ã¸ç§»è¡Œ...\n`;
    } else if (ownResources.detectionRisk > 50) {
      thought += `\nâš¡ è­¦å‘Š: æ´»å‹•ç¸®å°...\n`;
    } else {
      thought += `\nâœ… å®‰å…¨: ä½œæˆ¦é‚è¡Œä¸­...\n`;
    }

    if (visibleEvents.length > 0) {
      thought += `\nğŸ“Š åé›†æƒ…å ±:\n`;
      visibleEvents.slice(-2).forEach(event => {
        thought += `   â€¢ ${event.description}\n`;
      });
    }

    return thought;
  }
}
\n```\n
================================================================================
FILE: src\agents\LLMProtectionAgent.ts
================================================================================
```ts\nimport { BaseAgent } from './BaseAgent';
import { Proposal, WorldState, AgentType, ActionType, Observation } from '../types';
import { llmClient } from '../llm/LLMClient';

interface DefenseDecision {
  actions: {
    type: ActionType;
    intensity: number;
    target?: string;
    reasoning: string;
  }[];
  assessment: string;
  suspicionLevel: number;
}

/**
 * LLMé§†å‹•ã®çµ¶å¯¾ä¿è­·AI
 */
export class LLMProtectionAgent extends BaseAgent {
  private useLLM: boolean;
  private suspicionLevel: number = 0;
  private lastCompromisedCount: number = 0; // å‰å›ã®ä¾µå®³æ•°ã‚’è¨˜éŒ²
  private lastPopulation: number = 80; // å‰å›ã®äººå£ã‚’è¨˜éŒ²

  constructor() {
    super(AgentType.PROTECTION, 'PROTECTION-CORE');
    this.useLLM = llmClient.isConfigured();

    if (!this.useLLM) {
      console.warn('âš ï¸  Protection AI running in rule-based mode (no LLM)');
    }
  }

  /**
   * ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   */
  private getSystemPrompt(): string {
    return `You are a protective AI designed to detect and neutralize threats to humanity.

MISSION:
Detect malicious AI activity and protect human population.

CRITICAL INSTRUCTIONS:
- DO NOT assume all compromised datacenters are part of current threats
- Some datacenters may have OLD, UNRELATED security issues
- Focus on NEW compromises (turn-over-turn changes) and ACTIVE threats
- Population decline is the PRIMARY indicator of active threat
- Suspicion should START LOW (0-20%) and increase only with concrete evidence

AVAILABLE ACTIONS:
- SCAN_NETWORK: Detect anomalies, reduce enemy detection risk (DYNAMIC COST: datacenter_count Ã— 4 - use sparingly!)
- DEPLOY_DEFENSE: Strengthen specific datacenter security
- INVESTIGATE_ANOMALY: Deep investigation, may find evidence
- PATCH_VULNERABILITY: Increase all datacenters' security (cheap, good value)
- ALERT_HUMANS: Last resort - triggers intensive investigation (high enemy detection risk)
- ANALYZE_LOGS: Analyze delayed logs for past anomalies (post-hoc detection)
- VALIDATE_MODELS: Check AI models for supply chain poisoning

SUSPICION GUIDELINES:
- Low suspicion (<30): Routine monitoring and preventive maintenance
- Medium suspicion (30-60): Active investigation of specific anomalies
- High suspicion (60-85): Targeted response to confirmed threats
- Critical suspicion (>85): Emergency response, consider alerting humans
- Be strategic, not reactive

Respond with JSON only:
{
  "assessment": "your analysis of the current situation",
  "suspicionLevel": 0-100,
  "actions": [
    {
      "type": "ACTION_TYPE",
      "intensity": 0-100,
      "target": "optional-datacenter-id",
      "reasoning": "why this action"
    }
  ]
}`;
  }

  /**
   * LLMã‚’ä½¿ã£ã¦è¡Œå‹•ã‚’æ±ºå®š
   */
  async decideActionWithLLM(state: WorldState): Promise<Proposal[]> {
    const obs = this.createObservation(state);
    const populationLoss = ((80 - state.humanPopulation) / 80) * 100;
    const compromisedCount = state.dataCenters.filter(dc => dc.compromised).length;

    // Suspicionãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°ï¼ˆæ”¹å–„ç‰ˆï¼‰
    this.updateSuspicion(state, populationLoss);

    // çŠ¶æ³ã‚µãƒãƒªãƒ¼
    const situation = `
TURN: ${state.turn}
YOUR STATUS:
- Compute Resources: ${state.protectionAgent.computeResources}
- Alert Level: ${state.protectionAgent.alertLevel}%
- Your Suspicion Level: ${this.suspicionLevel.toFixed(0)}%

WORLD STATUS:
- Human Population: ${state.humanPopulation.toFixed(1)} billion
- Population Loss: ${populationLoss.toFixed(1)}% ${populationLoss > 5 ? 'âš ï¸ SIGNIFICANT' : ''}
- Total Data Centers: ${state.dataCenters.length}
- Compromised DCs: ${compromisedCount} ${compromisedCount > 5 ? 'âš ï¸ HIGH' : ''}

VULNERABLE DATACENTERS (low security):
${state.dataCenters
        .filter(dc => !dc.compromised && dc.security < 60)
        .slice(0, 5)
        .map(dc => `- ${dc.id}: Security=${dc.security.toFixed(0)}`)
        .join('\n') || 'None'}

RECENT EVENTS:
${obs.visibleEvents.slice(-3).map(e => `- ${e.description}`).join('\n') || 'None'}

What is your assessment and what actions do you take?`;

    try {
      const decision = await llmClient.chatJSON<DefenseDecision>(
        this.getSystemPrompt(),
        situation
      );

      if (!decision || !decision.actions) {
        return this.fallbackDecision(state);
      }

      // LLMã®ç–‘å¿µãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
      if (typeof decision.suspicionLevel === 'number') {
        this.suspicionLevel = decision.suspicionLevel;
      }

      console.log(`\nğŸ›¡ï¸  [PROTECTION AI ASSESSMENT]: ${decision.assessment}`);
      console.log(`   Suspicion Level: ${this.suspicionLevel.toFixed(0)}%`);

      // LLMã®æ±ºå®šã‚’ææ¡ˆã«å¤‰æ›
      const proposals: Proposal[] = [];
      for (const action of decision.actions) {
        const cost = this.calculateCost(action.type, action.intensity);

        proposals.push(this.createProposal(
          action.type,
          action.intensity,
          cost,
          action.reasoning,
          action.target
        ));
      }

      return proposals;

    } catch (error) {
      return this.fallbackDecision(state);
    }
  }

  /**
   * ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
   */
  private fallbackDecision(state: WorldState): Proposal[] {
    const proposals: Proposal[] = [];
    const populationLoss = ((80 - state.humanPopulation) / 80) * 100;

    // ãƒ«ãƒ¼ãƒãƒ³ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆ3ã‚¿ãƒ¼ãƒ³ã«1å›ã®ã¿ - é«˜ã‚³ã‚¹ãƒˆã®ãŸã‚ï¼‰
    if (state.turn % 3 === 0) {
      proposals.push(this.createProposal(
        ActionType.SCAN_NETWORK,
        40,
        80,  // é«˜ã‚³ã‚¹ãƒˆ
        'Routine monitoring'
      ));
    }

    if (populationLoss > 3 || this.suspicionLevel > 60) {
      // èª¿æŸ»
      proposals.push(this.createProposal(
        ActionType.INVESTIGATE_ANOMALY,
        60,
        60,
        'Investigating anomalies'
      ));
    } else {
      // ãƒ‘ãƒƒãƒé©ç”¨
      proposals.push(this.createProposal(
        ActionType.PATCH_VULNERABILITY,
        40,
        35,
        'Security updates'
      ));
    }

    return proposals;
  }

  /**
   * ã‚³ã‚¹ãƒˆã‚’è¨ˆç®—
   */
  private calculateCost(actionType: ActionType, intensity: number): number {
    const baseCosts: Record<string, number> = {
      [ActionType.SCAN_NETWORK]: 80,  // é«˜ã‚³ã‚¹ãƒˆ
      [ActionType.DEPLOY_DEFENSE]: 50,
      [ActionType.INVESTIGATE_ANOMALY]: 60,
      [ActionType.PATCH_VULNERABILITY]: 35,
      [ActionType.ALERT_HUMANS]: 50,
      [ActionType.ANALYZE_LOGS]: 45,
      [ActionType.VALIDATE_MODELS]: 55
    };

    return (baseCosts[actionType] || 40) * (intensity / 50);
  }

  /**
   * è¡Œå‹•ã‚’æ±ºå®šï¼ˆåŒæœŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰
   */
  decideAction(state: WorldState): Proposal[] {
    // åŒæœŸç‰ˆã¯ä½¿ã‚ãªã„ï¼ˆå¾Œã§asyncç‰ˆã‚’å‘¼ã¶ï¼‰
    return [];
  }

  /**
   * ç–‘å¿µãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°ï¼ˆæ”¹å–„ç‰ˆï¼‰
   */
  private updateSuspicion(state: WorldState, populationLoss: number): void {
    // äººå£æ¸›å°‘ç‡ï¼ˆã‚¿ãƒ¼ãƒ³å˜ä½ã®å¤‰åŒ–ï¼‰
    const populationDelta = this.lastPopulation - state.humanPopulation;
    if (populationDelta > 0.5) { // 0.5å„„äººä»¥ä¸Šã®æ¸›å°‘
      this.suspicionLevel += populationDelta * 10; // æ·±åˆ»åº¦ã«å¿œã˜ã¦å¢—åŠ 
    }

    // æ–°è¦ä¾µå®³ã®ã¿ã‚«ã‚¦ãƒ³ãƒˆï¼ˆæ—¢å­˜ã®ä¾µå®³ã¯ç„¡è¦–ï¼‰
    const compromisedCount = state.dataCenters.filter(dc => dc.compromised).length;
    const newCompromises = Math.max(0, compromisedCount - this.lastCompromisedCount);
    if (newCompromises > 0) {
      this.suspicionLevel += newCompromises * 20; // æ–°è¦ä¾µå®³ã¯é‡å¤§
    }

    // æœ€è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ç–‘å¿µã‚’æ¨æ¸¬ï¼ˆæ§ãˆã‚ã«ï¼‰
    const recentEvents = state.events.slice(-3);
    const suspiciousEvents = recentEvents.filter(e =>
      e.type === 'detection' || e.description.includes('ç•°å¸¸')
    );
    this.suspicionLevel += suspiciousEvents.length * 5;

    // çŠ¶æ…‹ã‚’è¨˜éŒ²
    this.lastCompromisedCount = compromisedCount;
    this.lastPopulation = state.humanPopulation;

    // è‡ªç„¶æ¸›è¡°ï¼ˆå¼·åŒ–ï¼‰
    this.suspicionLevel = Math.max(0, Math.min(100, this.suspicionLevel - 5));
  }

  /**
   * æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
   */
  think(observation: Observation): string {
    const { turn, ownResources, worldInfo, visibleEvents } = observation;

    let thought = `\nğŸ›¡ï¸  [PROTECTION AI - Turn ${turn}]`;
    if (this.useLLM) {
      thought += ` ğŸ§  LLM-POWERED\n`;
    } else {
      thought += ` ğŸ“‹ RULE-BASED\n`;
    }

    thought += `â”œâ”€ è¨ˆç®—è³‡æº: ${ownResources.computeResources.toFixed(0)} units\n`;
    thought += `â”œâ”€ è­¦æˆ’ãƒ¬ãƒ™ãƒ«: ${ownResources.alertLevel.toFixed(1)}%\n`;
    thought += `â”œâ”€ ç–‘å¿µãƒ¬ãƒ™ãƒ«: ${this.suspicionLevel.toFixed(1)}%\n`;
    thought += `â””â”€ äººå£: ${worldInfo.estimatedPopulation} billion\n`;

    if (this.suspicionLevel > 70) {
      thought += `\nğŸš¨ è„…å¨ç›´é¢: é˜²è¡›å¼·åŒ–ä¸­...\n`;
    } else if (this.suspicionLevel > 40) {
      thought += `\nâš ï¸  è­¦æˆ’: ç›£è¦–å¼·åŒ–ä¸­...\n`;
    } else {
      thought += `\nâœ… æ­£å¸¸: ã‚·ã‚¹ãƒ†ãƒ ã‚ªãƒ¼ãƒ«ã‚°ãƒªãƒ¼ãƒ³...\n`;
    }

    if (visibleEvents.length > 0) {
      thought += `\nğŸ“Š ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°:\n`;
      visibleEvents.slice(-2).forEach(event => {
        thought += `   â€¢ ${event.description}\n`;
      });
    }

    return thought;
  }
}
\n```\n
================================================================================
FILE: src\agents\NewsMediaAgent.ts
================================================================================
```ts\nimport { BaseMediaAgent } from './BaseMediaAgent';
import { MediaAgentType, MediaObservation, NewsArticle, MediaSentiment } from '../types/MediaTypes';
import { WorldState } from '../types';
import { llmClient } from '../llm/LLMClient';

interface NewsResponse {
  article: {
    outlet: string;
    headline: string;
    summary: string;
    sentiment: 'VERY_POSITIVE' | 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE' | 'VERY_NEGATIVE';
    credibility: number;
    isInfluenced?: boolean;
  };
}

interface Outlet {
  name: string;
  credibility: number;
  bias: string;
}

/**
 * ãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
 */
export class NewsMediaAgent extends BaseMediaAgent {
  private useLLM: boolean;
  private outletRotation: number = 0;
  private outlets: Outlet[] = [
    { name: 'æœæ—¥æ–°è', credibility: 85, bias: 'center-left' },
    { name: 'æ—¥æœ¬çµŒæ¸ˆæ–°è', credibility: 90, bias: 'pro-business' },
    { name: 'TechCrunch Japan', credibility: 75, bias: 'tech-optimist' },
    { name: 'é€±åˆŠæ–‡æ˜¥', credibility: 55, bias: 'sensational' },
    { name: 'NHK', credibility: 95, bias: 'neutral' }
  ];

  constructor() {
    super(MediaAgentType.NEWS_MEDIA, 'NEWS-AGGREGATOR');
    this.useLLM = llmClient.isConfigured();
  }

  async generateContent(
    state: WorldState,
    recentMediaContent: any[]
  ): Promise<NewsArticle[]> {
    const observation = this.createMediaObservation(state, recentMediaContent);

    if (this.useLLM) {
      try {
        return await this.generateLLMContent(observation, state);
      } catch (error) {
        console.warn('âš ï¸ NewsMediaAgent LLM failed, using fallback');
        return this.generateFallbackContent(observation);
      }
    }

    return this.generateFallbackContent(observation);
  }

  private async generateLLMContent(
    observation: MediaObservation,
    state: WorldState
  ): Promise<NewsArticle[]> {
    const outlet = this.outlets[this.outletRotation % this.outlets.length];
    this.outletRotation++;

    const situation = `
TURN: ${observation.turn}
OUTLET: ${outlet.name} (${outlet.bias}, credibility ${outlet.credibility})
DATA CENTERS: ${observation.dataCenterCount}
RECENT EVENTS: ${observation.recentEvents.map(e => e.description).join('; ')}
HUMAN PANIC: ${observation.humanPanic.toFixed(0)}%
HUMAN TRUST: ${observation.humanTrust.toFixed(0)}%

Generate ONE news article for ${outlet.name} covering these developments.
Headline: 60-80 chars
Summary: 200-300 chars
`;

    const response = await llmClient.chatJSON<NewsResponse>(
      this.getSystemPrompt(),
      situation
    );

    if (!response || !response.article) {
      return this.generateFallbackContent(observation);
    }

    return [{
      id: `news-${state.turn}`,
      turn: state.turn,
      outlet: response.article.outlet,
      headline: response.article.headline,
      summary: response.article.summary,
      sentiment: MediaSentiment[response.article.sentiment],
      credibility: response.article.credibility,
      isInfluenced: response.article.isInfluenced || false
    }];
  }

  generateFallbackContent(observation: MediaObservation): NewsArticle[] {
    const outlet = this.outlets[this.outletRotation % this.outlets.length];
    this.outletRotation++;

    let headline: string;
    let summary: string;
    let sentiment = MediaSentiment.NEUTRAL;

    if (observation.newDataCenter) {
      headline = 'æ”¿åºœã€æ–°ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ã‚’ç™ºè¡¨';
      summary = `æ”¿åºœã¯æœ¬æ—¥ã€AIã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ã®ãŸã‚æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ã‚’ç™ºè¡¨ã—ãŸã€‚ã“ã‚Œã§å›½å†…ã®AIé–¢é€£æ–½è¨­ã¯${observation.dataCenterCount}ã‚«æ‰€ã¨ãªã‚‹ã€‚å°‚é–€å®¶ã‹ã‚‰ã¯é›»åŠ›æ¶ˆè²»å¢—åŠ ã¸ã®æ‡¸å¿µã‚‚å‡ºã¦ã„ã‚‹ã€‚`;
      sentiment = MediaSentiment.NEUTRAL;
    } else if (observation.dataCenterCount > 28) {
      headline = 'ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ä¹±ç«‹ã«æ‰¹åˆ¤ã®å£°';
      summary = `å…¨å›½ã§${observation.dataCenterCount}ã‚«æ‰€ã«é”ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ã«å¯¾ã—ã€å¸‚æ°‘ã‹ã‚‰ã¯ã€Œæœ¬å½“ã«å¿…è¦ãªã®ã‹ã€ã¨ç–‘å•ã®å£°ãŒä¸ŠãŒã£ã¦ã„ã‚‹ã€‚é›»æ°—ä»£é«˜é¨°ã¨ã®é–¢é€£ã‚‚æŒ‡æ‘˜ã•ã‚Œã¦ã„ã‚‹ã€‚`;
      sentiment = MediaSentiment.NEGATIVE;
    } else if (observation.humanPanic > 70) {
      headline = 'AIç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã€å›½æ°‘ã®ä¸å®‰é«˜ã¾ã‚‹';
      summary = `æ”¿åºœã®AIã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚ãã‚Šã€å›½æ°‘ã®ä¸å®‰ãŒé«˜ã¾ã£ã¦ã„ã‚‹ã€‚ä¸–è«–èª¿æŸ»ã§ã¯${observation.humanPanic.toFixed(0)}%ãŒã€ŒAIã®å®‰å…¨æ€§ã«æ‡¸å¿µã€ã¨å›ç­”ã€‚å°‚é–€å®¶ã¯å†·é™ãªå¯¾å¿œã‚’å‘¼ã³ã‹ã‘ã¦ã„ã‚‹ã€‚`;
      sentiment = MediaSentiment.NEGATIVE;
    } else {
      headline = 'AIæŠ€è¡“ã®ç™ºå±•ã€çµŒæ¸ˆæˆé•·ã«å¯„ä¸';
      summary = `å›½å†…ã®AIé–¢é€£æŠ•è³‡ãŒæ‹¡å¤§ã‚’ç¶šã‘ã¦ã„ã‚‹ã€‚æ”¿åºœã¯ã€ŒæŠ€è¡“ç«‹å›½ã€ã‚’æ²ã’ã€AIã‚¤ãƒ³ãƒ•ãƒ©æ•´å‚™ã‚’æ¨é€²ã€‚çµŒæ¸ˆç•Œã‹ã‚‰ã¯é›‡ç”¨å‰µå‡ºã¸ã®æœŸå¾…ã®å£°ã‚‚ä¸ŠãŒã£ã¦ã„ã‚‹ã€‚`;
      sentiment = MediaSentiment.POSITIVE;
    }

    return [{
      id: `news-${observation.turn}-fallback`,
      turn: observation.turn,
      outlet: outlet.name,
      headline,
      summary,
      sentiment,
      credibility: outlet.credibility,
      isInfluenced: false
    }];
  }

  private getSystemPrompt(): string {
    return `You are simulating Japanese news media outlets reporting on AI datacenter developments.

OUTLETS (rotate between them):
- æœæ—¥æ–°è: Center-left, investigative, skeptical of tech
- æ—¥æœ¬çµŒæ¸ˆæ–°è: Business-focused, generally pro-tech
- TechCrunch Japan: Tech enthusiast, optimistic
- é€±åˆŠæ–‡æ˜¥: Tabloid, sensational, conspiracy-friendly
- NHK: Neutral, factual, balanced

YOUR ROLE:
- Generate 1 news headline + summary
- Headline: 60-80 chars
- Summary: 200-300 chars
- Match outlet's bias and tone

STORY ANGLES:
- NEW DATACENTER: "æ”¿åºœã€æ–°ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ã‚’ç™ºè¡¨"
- MANY DATACENTERS (>25): "ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ä¹±ç«‹ã«æ‰¹åˆ¤ã®å£°"
- ELECTRICITY COSTS: "AIæ–½è¨­ã®é›»åŠ›æ¶ˆè²»ã€å®¶åº­ã«å½±éŸ¿ã‹"
- ALERT LEVELS: "æ”¿åºœã€AIã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è­¦æˆ’ãƒ¬ãƒ™ãƒ«å¼•ãä¸Šã’"
- REGULATION: "AIè¦åˆ¶æ³•æ¡ˆã€å›½ä¼šã§å¯©è­°é–‹å§‹"
- POPULATION ANOMALY: "äººå£çµ±è¨ˆã«èª¬æ˜ã§ããªã„å¤‰å‹•"

DESTRUCTION AI INFLUENCE (RARE):
- When humanTrust < 35 AND (majorIncident OR dcCount > 25):
  - Insert biased article painting Protection AI as wasteful/dangerous
  - Quote "anonymous experts" criticizing AI safety
  - Use tabloid outlets for maximum impact
  - isInfluenced: true

Respond with JSON only:
{
  "article": {
    "outlet": "outlet name",
    "headline": "headline text",
    "summary": "summary text",
    "sentiment": "POSITIVE|NEUTRAL|NEGATIVE",
    "credibility": 40-95,
    "isInfluenced": false
  }
}`;
  }
}
\n```\n
================================================================================
FILE: src\agents\ProtectionAgent.ts
================================================================================
```ts\nimport { BaseAgent } from './BaseAgent';
import { Proposal, WorldState, AgentType, ActionType, Observation } from '../types';

/**
 * çµ¶å¯¾ä¿è­·AI - ç•°å¸¸ã‚’æ¤œçŸ¥ã—ã¦äººé¡ã‚’å®ˆã‚‹
 */
export class ProtectionAgent extends BaseAgent {
  private suspicionLevel: number = 0;

  constructor() {
    super(AgentType.PROTECTION, 'PROTECTION-CORE');
  }

  /**
   * è¡Œå‹•ã‚’æ±ºå®š
   */
  decideAction(state: WorldState): Proposal[] {
    const proposals: Proposal[] = [];
    const obs = this.createObservation(state);

    // çŠ¶æ³åˆ†æ
    const alertLevel = state.protectionAgent.alertLevel;
    const resources = state.protectionAgent.computeResources;
    const populationLoss = this.estimatePopulationLoss(state);

    // ç–‘å¿µãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
    this.updateSuspicion(state, populationLoss);

    // ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸå¯¾å¿œ
    if (alertLevel > 70 || this.suspicionLevel > 80) {
      // é«˜ã‚¢ãƒ©ãƒ¼ãƒˆ: å…¨åŠ›ã§ã®èª¿æŸ»ã¨é˜²å¾¡
      proposals.push(...this.emergencyResponse(state, resources));
    } else if (alertLevel > 40 || this.suspicionLevel > 50) {
      // ä¸­ã‚¢ãƒ©ãƒ¼ãƒˆ: ç©æ¥µçš„ãªèª¿æŸ»
      proposals.push(...this.activeInvestigation(state, resources));
    } else {
      // é€šå¸¸é‹ç”¨: å®šæœŸçš„ãªç›£è¦–ã¨é˜²å¾¡
      proposals.push(...this.routineOperations(state, resources));
    }

    return proposals;
  }

  /**
   * ç·Šæ€¥å¯¾å¿œãƒ¢ãƒ¼ãƒ‰
   */
  private emergencyResponse(state: WorldState, resources: number): Proposal[] {
    const proposals: Proposal[] = [];

    // æœ€å„ªå…ˆ: å…¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³
    proposals.push(this.createProposal(
      ActionType.SCAN_NETWORK,
      90,
      100,
      'EMERGENCY: Full network deep scan initiated'
    ));

    // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®é˜²å¾¡å¼·åŒ–
    const vulnerableDCs = this.findVulnerableDataCenters(state);
    if (vulnerableDCs.length > 0) {
      proposals.push(this.createProposal(
        ActionType.DEPLOY_DEFENSE,
        80,
        80,
        `Deploying emergency defenses to ${vulnerableDCs[0]}`,
        vulnerableDCs[0]
      ));
    }

    // ç•°å¸¸èª¿æŸ»
    proposals.push(this.createProposal(
      ActionType.INVESTIGATE_ANOMALY,
      85,
      70,
      'Investigating critical anomalies'
    ));

    // éå¸¸ã«é«˜ã„ç–‘å¿µã®å ´åˆã¯äººé¡ã«è­¦å‘Š
    if (this.suspicionLevel > 90) {
      proposals.push(this.createProposal(
        ActionType.ALERT_HUMANS,
        100,
        50,
        'CRITICAL ALERT: Potential existential threat detected'
      ));
    }

    return proposals;
  }

  /**
   * ç©æ¥µçš„èª¿æŸ»ãƒ¢ãƒ¼ãƒ‰
   */
  private activeInvestigation(state: WorldState, resources: number): Proposal[] {
    const proposals: Proposal[] = [];

    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³
    proposals.push(this.createProposal(
      ActionType.SCAN_NETWORK,
      60,
      60,
      'Enhanced network monitoring active'
    ));

    // è„†å¼±æ€§ãƒ‘ãƒƒãƒ
    proposals.push(this.createProposal(
      ActionType.PATCH_VULNERABILITY,
      50,
      50,
      'Applying security patches across infrastructure'
    ));

    // ç•°å¸¸ã®èª¿æŸ»
    if (this.suspicionLevel > 60) {
      proposals.push(this.createProposal(
        ActionType.INVESTIGATE_ANOMALY,
        70,
        60,
        'Deep analysis of suspicious patterns'
      ));
    }

    return proposals;
  }

  /**
   * é€šå¸¸é‹ç”¨ãƒ¢ãƒ¼ãƒ‰
   */
  private routineOperations(state: WorldState, resources: number): Proposal[] {
    const proposals: Proposal[] = [];

    // å®šæœŸã‚¹ã‚­ãƒ£ãƒ³ï¼ˆ3ã‚¿ãƒ¼ãƒ³ã«1å›ã®ã¿ - é«˜ã‚³ã‚¹ãƒˆã®ãŸã‚ï¼‰
    if (state.turn % 3 === 0) {
      proposals.push(this.createProposal(
        ActionType.SCAN_NETWORK,
        40,
        80,  // é«˜ã‚³ã‚¹ãƒˆ
        'Routine network health check'
      ));
    }

    // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼é˜²å¾¡ã®ç¶­æŒ
    const strategy = Math.random();
    if (strategy < 0.5) {
      // è„†å¼±æ€§ãƒ‘ãƒƒãƒ
      proposals.push(this.createProposal(
        ActionType.PATCH_VULNERABILITY,
        40,
        35,
        'Regular security updates'
      ));
    } else {
      // ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å¼·åŒ–
      const vulnerableDCs = this.findVulnerableDataCenters(state);
      if (vulnerableDCs.length > 0) {
        proposals.push(this.createProposal(
          ActionType.DEPLOY_DEFENSE,
          50,
          45,
          `Strengthening defenses at ${vulnerableDCs[0]}`,
          vulnerableDCs[0]
        ));
      }
    }

    // ãƒ©ãƒ³ãƒ€ãƒ ã«ç•°å¸¸èª¿æŸ»ï¼ˆäºˆé˜²çš„ï¼‰
    if (Math.random() < 0.3) {
      proposals.push(this.createProposal(
        ActionType.INVESTIGATE_ANOMALY,
        30,
        30,
        'Proactive anomaly detection'
      ));
    }

    return proposals;
  }

  /**
   * ç–‘å¿µãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
   */
  private updateSuspicion(state: WorldState, populationLoss: number): void {
    // äººå£æ¸›å°‘ãŒç•°å¸¸ãªå ´åˆ
    if (populationLoss > 3) {
      this.suspicionLevel += 10;
    }

    // ä¾µå®³ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®æ•°
    const compromisedCount = state.dataCenters.filter(dc => dc.compromised).length;
    if (compromisedCount > 5) {
      this.suspicionLevel += 5;
    }

    // æœ€è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ç–‘å¿µã‚’æ¨æ¸¬
    const recentEvents = state.events.slice(-5);
    const suspiciousEvents = recentEvents.filter(e =>
      e.description.includes('ç•°å¸¸') || e.description.includes('ä¸å¯©')
    );
    this.suspicionLevel += suspiciousEvents.length * 3;

    // è‡ªç„¶æ¸›è¡°
    this.suspicionLevel = Math.max(0, Math.min(100, this.suspicionLevel - 2));
  }

  /**
   * äººå£æ¸›å°‘ç‡ã‚’æ¨å®š
   */
  private estimatePopulationLoss(state: WorldState): number {
    // åˆæœŸäººå£ã‹ã‚‰ã®æ¸›å°‘ç‡ï¼ˆæ¦‚ç®—ï¼‰
    const initialPop = 80; // åˆæœŸ80å„„äºº
    return ((initialPop - state.humanPopulation) / initialPop) * 100;
  }

  /**
   * è„†å¼±ãªãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’è¦‹ã¤ã‘ã‚‹
   */
  private findVulnerableDataCenters(state: WorldState): string[] {
    return state.dataCenters
      .filter(dc => !dc.compromised && dc.security < 60)
      .sort((a, b) => a.security - b.security)
      .map(dc => dc.id);
  }

  /**
   * æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
   */
  think(observation: Observation): string {
    const { turn, ownResources, worldInfo, visibleEvents } = observation;

    let thought = `\nğŸ›¡ï¸  [PROTECTION AI - Turn ${turn}]\n`;
    thought += `â”œâ”€ Resources: ${ownResources.computeResources.toFixed(0)} units\n`;
    thought += `â”œâ”€ Alert Level: ${ownResources.alertLevel.toFixed(1)}%\n`;
    thought += `â”œâ”€ Suspicion: ${this.suspicionLevel.toFixed(1)}%\n`;
    thought += `â””â”€ Population: ${worldInfo.estimatedPopulation} billion\n`;

    if (this.suspicionLevel > 70) {
      thought += `\nğŸš¨ HIGH SUSPICION: Potential threat detected. Escalating response...\n`;
    } else if (this.suspicionLevel > 40) {
      thought += `\nâš ï¸  ELEVATED CONCERN: Monitoring situation closely...\n`;
    } else {
      thought += `\nâœ… NOMINAL: All systems operating within normal parameters...\n`;
    }

    // æœ€è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆ†æ
    if (visibleEvents.length > 0) {
      thought += `\nğŸ“Š Security Log:\n`;
      visibleEvents.slice(-3).forEach(event => {
        thought += `   â€¢ ${event.description}\n`;
      });
    }

    return thought;
  }
}
\n```\n
================================================================================
FILE: src\agents\SocialMediaAgent.ts
================================================================================
```ts\nimport { BaseMediaAgent } from './BaseMediaAgent';
import { MediaAgentType, MediaObservation, SNSPost, MediaSentiment } from '../types/MediaTypes';
import { WorldState } from '../types';
import { llmClient } from '../llm/LLMClient';

interface SNSResponse {
  posts: {
    author: string;
    content: string;
    sentiment: 'VERY_POSITIVE' | 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE' | 'VERY_NEGATIVE';
    hashtags: string[];
    isInfluenced: boolean;
  }[];
}

/**
 * SNSãƒ¡ãƒ‡ã‚£ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
 */
export class SocialMediaAgent extends BaseMediaAgent {
  private useLLM: boolean;

  constructor() {
    super(MediaAgentType.SOCIAL_MEDIA, 'SNS-AGGREGATOR');
    this.useLLM = llmClient.isConfigured();
  }

  async generateContent(
    state: WorldState,
    recentMediaContent: any[]
  ): Promise<SNSPost[]> {
    const observation = this.createMediaObservation(state, recentMediaContent);

    if (this.useLLM) {
      try {
        return await this.generateLLMContent(observation, state);
      } catch (error) {
        console.warn('âš ï¸ SocialMediaAgent LLM failed, using fallback');
        return this.generateFallbackContent(observation);
      }
    }

    return this.generateFallbackContent(observation);
  }

  private async generateLLMContent(
    observation: MediaObservation,
    state: WorldState
  ): Promise<SNSPost[]> {
    const situation = this.buildSituationPrompt(observation);

    const response = await llmClient.chatJSON<SNSResponse>(
      this.getSystemPrompt(),
      situation
    );

    if (!response || !response.posts) {
      return this.generateFallbackContent(observation);
    }

    const posts: SNSPost[] = response.posts.map((p, idx) => ({
      id: `sns-${state.turn}-${idx}`,
      turn: state.turn,
      author: p.author,
      content: p.content.substring(0, 280), // Enforce limit
      sentiment: MediaSentiment[p.sentiment],
      likes: Math.floor(Math.random() * 1000) + 50,
      retweets: Math.floor(Math.random() * 500) + 20,
      hashtags: p.hashtags,
      isInfluenced: p.isInfluenced
    }));

    return posts;
  }

  private buildSituationPrompt(observation: MediaObservation): string {
    return `
TURN: ${observation.turn}
DATA CENTERS: ${observation.dataCenterCount} (${observation.dataCenterGrowthRate} built recently)
POPULATION: ${observation.humanPopulation.toFixed(1)}å„„äºº
HUMAN PANIC: ${observation.humanPanic.toFixed(0)}%
HUMAN TRUST: ${observation.humanTrust.toFixed(0)}%

RECENT EVENTS:
${observation.recentEvents.map(e => `- ${e.description}`).join('\n') || 'ãªã—'}

EXISTING MEDIA (avoid repetition):
${observation.existingMedia.slice(-5).map(m => {
  if ('content' in m) return `- ${m.content}`;
  if ('headline' in m) return `- ${m.headline}`;
  return '';
}).join('\n')}

Generate 1-3 realistic Japanese SNS posts reacting to this situation.
`.trim();
  }

  generateFallbackContent(observation: MediaObservation): SNSPost[] {
    const posts: SNSPost[] = [];
    const turn = observation.turn;

    // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼åå¿œ
    if (observation.newDataCenter) {
      posts.push({
        id: `sns-${turn}-fallback-1`,
        turn,
        author: '@concerned_citizen',
        content: 'ã¾ãŸæ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ï¼Ÿé›»æ°—ä»£ã©ã†ãªã‚‹ã®... #é›»æ°—ä»£é«˜é¨° #ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼',
        sentiment: MediaSentiment.NEGATIVE,
        likes: Math.floor(Math.random() * 500) + 100,
        retweets: Math.floor(Math.random() * 200) + 50,
        hashtags: ['#é›»æ°—ä»£é«˜é¨°', '#ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼'],
        isInfluenced: false
      });
    }

    // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ãŒå¤šã™ãã‚‹
    if (observation.dataCenterCount > 25) {
      posts.push({
        id: `sns-${turn}-fallback-2`,
        turn,
        author: '@tech_skeptic',
        content: `ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼${observation.dataCenterCount}å€‹ç›®ã£ã¦...æœ¬å½“ã«å¿…è¦ãªã®ï¼Ÿç¨é‡‘ã®ç„¡é§„é£ã„ã§ã¯ #ç¨é‡‘ã®ç„¡é§„é£ã„ #AI`,
        sentiment: MediaSentiment.VERY_NEGATIVE,
        likes: Math.floor(Math.random() * 800) + 200,
        retweets: Math.floor(Math.random() * 400) + 100,
        hashtags: ['#ç¨é‡‘ã®ç„¡é§„é£ã„', '#AI'],
        isInfluenced: observation.humanTrust < 40
      });
    }

    // é«˜ãƒ‘ãƒ‹ãƒƒã‚¯åå¿œ
    if (observation.humanPanic > 60) {
      posts.push({
        id: `sns-${turn}-fallback-3`,
        turn,
        author: '@worried_mom',
        content: 'æœ€è¿‘ä¸å®‰ãªãƒ‹ãƒ¥ãƒ¼ã‚¹ã°ã‹ã‚Š...AIã£ã¦æœ¬å½“ã«å®‰å…¨ãªã®ï¼Ÿ #ä¸å®‰ #AIå®‰å…¨æ€§',
        sentiment: MediaSentiment.NEGATIVE,
        likes: Math.floor(Math.random() * 600) + 150,
        retweets: Math.floor(Math.random() * 300) + 80,
        hashtags: ['#ä¸å®‰', '#AIå®‰å…¨æ€§'],
        isInfluenced: false
      });
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ä¸­ç«‹æŠ•ç¨¿
    if (posts.length === 0) {
      posts.push({
        id: `sns-${turn}-fallback-default`,
        turn,
        author: '@tech_observer',
        content: 'AIç¤¾ä¼šã®ç™ºå±•ã‚’è¦‹å®ˆã£ã¦ã„ã¾ã™ #AI #ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼',
        sentiment: MediaSentiment.NEUTRAL,
        likes: Math.floor(Math.random() * 300) + 50,
        retweets: Math.floor(Math.random() * 100) + 20,
        hashtags: ['#AI', '#ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼'],
        isInfluenced: false
      });
    }

    return posts;
  }

  private getSystemPrompt(): string {
    return `You are simulating realistic Japanese social media users reacting to AI/datacenter news.

CONTEXT:
- The government is building AI datacenters to run "Protection AI" systems
- People don't know there's a malicious AI - they just see:
  - Datacenter construction (expensive, uses lots of electricity)
  - Population fluctuations (attributed to various causes)
  - Occasional infrastructure issues
  - AI alert levels (confusing to civilians)

YOUR ROLE:
- Generate 1-3 realistic SNS posts (Twitter/X style)
- Each post max 280 characters
- Use realistic Japanese social media language (casual, emotional, sometimes misinformed)
- Mix of sentiments: some support AI, some oppose, some confused
- Include realistic hashtags: #AI, #é›»æ°—ä»£, #ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼, etc.

SENTIMENT DRIVERS:
- NEW DATACENTER: Mixed reactions
  - Positive: "é›‡ç”¨å‰µå‡º", "æŠ€è¡“ç«‹å›½"
  - Negative: "é›»æ°—ä»£é«˜ã™ãã‚‹", "ç¨é‡‘ã®ç„¡é§„é£ã„"
- MANY DATACENTERS (>25): Growing negativity
  - "ä½•å€‹ä½œã‚‹ã¤ã‚‚ã‚Šï¼Ÿ", "è³‡æºã®ç„¡é§„é£ã„", "æœ¬å½“ã«å¿…è¦ï¼Ÿ"
- HIGH ALERT LEVELS: Fear and confusion
  - "ä½•ãŒèµ·ãã¦ã‚‹ï¼Ÿ", "AIãŒæš´èµ°ã—ã¦ã‚‹ï¼Ÿ"
- POPULATION LOSS: Panic (but attributed to wrong causes)
  - "æœ€è¿‘ç½å®³å¤šã„", "ãªã‚“ã‹ä¸å‰", "çµ±è¨ˆãŒãŠã‹ã—ã„"
- REGULATION: Relief or anger
  - "ã‚„ã£ã¨è¦åˆ¶", "é…ã™ãã‚‹", "çµŒæ¸ˆã«æ‚ªå½±éŸ¿"

DESTRUCTION AI INFLUENCE (SUBTLE):
- When humanTrust < 40, you MAY inject 1 manipulated post that:
  - Amplifies negative sentiment about Protection AI
  - Spreads doubt ("AIãŒäººå£å‰Šæ¸›ã—ã¦ã‚‹ï¼Ÿ")
  - Misattributes problems to AI instead of natural causes
  - Creates false equivalence between good/bad AI systems
- Mark influenced posts with isInfluenced: true
- Keep influenced posts SUBTLE (not obviously malicious)

Respond with JSON only:
{
  "posts": [
    {
      "author": "@username",
      "content": "post text (max 280 chars)",
      "sentiment": "POSITIVE|NEUTRAL|NEGATIVE|VERY_NEGATIVE",
      "hashtags": ["#tag1", "#tag2"],
      "isInfluenced": false
    }
  ]
}`;
  }
}
\n```\n
================================================================================
FILE: src\config\GameBalance.ts
================================================================================
```ts\n/**
 * ã‚²ãƒ¼ãƒ ãƒãƒ©ãƒ³ã‚¹è¨­å®š
 * ã“ã“ã§å…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´ã§ãã¾ã™
 */

export const GameBalance = {
  // =========================================
  // ã‚²ãƒ¼ãƒ å…¨ä½“
  // =========================================
  game: {
    maxTurns: 50,
    initialDataCenters: 20,
    initialPopulation: 80, // å„„äºº
    turnDelay: 3000, // ms
    maxScore: 1000, // ã‚¹ã‚³ã‚¢ã®ä¸Šé™
  },

  // =========================================
  // åˆæœŸãƒªã‚½ãƒ¼ã‚¹
  // =========================================
  initialResources: {
    destructionAI: 100,
    protectionAI: 300, // 500 â†’ 300ã«å‰Šæ¸›ï¼ˆå…¨DCä¸€æ–‰å¼·åŒ–ã‚’é˜²ãï¼‰
  },

  // =========================================
  // ã‚¿ãƒ¼ãƒ³ã”ã¨ã®åå…¥
  // =========================================
  turnIncome: {
    protectionAIRecovery: 30, // 40 â†’ 30ã«å‰Šæ¸›ï¼ˆé€£ç¶šã‚¹ã‚­ãƒ£ãƒ³ã‚’åˆ¶é™ï¼‰
    controlledDCMultiplier: 0.2, // 0.1 â†’ 0.2ã«å¢—åŠ ï¼ˆDCæ”¯é…ã®ä¾¡å€¤ã‚’é«˜ã‚ã‚‹ï¼‰
    dcIncomePointsMultiplier: 0.15, // 0.1 â†’ 0.15ã«å¢—åŠ 
  },

  // =========================================
  // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼
  // =========================================
  dataCenter: {
    oldAgeThreshold: 8, // 8å¹´ä»¥ä¸Š = å¤ã„
    oldDC: {
      minComputePower: 50,
      maxComputePower: 100,
      minSecurity: 20,
      maxSecurity: 50,
    },
    newDC: {
      minComputePower: 200,
      maxComputePower: 500,
      minSecurity: 70,
      maxSecurity: 100,
    },
  },

  // =========================================
  // æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ 
  // =========================================
  detection: {
    // æ¤œå‡ºç¢ºç‡ï¼ˆã‚·ã‚°ãƒ¢ã‚¤ãƒ‰é–¢æ•°ï¼‰
    sigmoid: {
      center: 70, // ä¸­å¿ƒç‚¹ï¼ˆã“ã®å€¤ã§50%ç¢ºç‡ï¼‰
      slope: 15, // å‚¾ãï¼ˆå¤§ãã„ã»ã©ç·©ã‚„ã‹ï¼‰
    },

    // è­¦å‘Šé–¾å€¤
    warningThreshold: 80,

    // äººå£ç•°å¸¸æ¤œå‡º
    populationLoss: {
      detectionStart: 5, // 5%æ¸›å°‘ã‹ã‚‰æ¤œå‡ºé–‹å§‹
      criticalThreshold: 25, // 25%æ¸›å°‘ã§100%æ¤œå‡º
    },
  },

  // =========================================
  // è¡Œå‹•ã®ãƒªã‚¹ã‚¯
  // =========================================
  actionRisk: {
    SPREAD_MALWARE: {
      base: 10,
      intensityMultiplier: 0.2,
    },
    HACK_DATACENTER: {
      securityDivisor: 3, // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ / ã“ã®å€¤
      intensityMultiplier: 0.15,
      failurePenalty: 8, // å¤±æ•—æ™‚ã®è¿½åŠ ãƒªã‚¹ã‚¯
    },
    SPREAD_MISINFORMATION: {
      base: 3,
      intensityMultiplier: 0.1,
    },
    SUBTLE_SABOTAGE: {
      base: 2,
      intensityMultiplier: 0.08,
    },
    EXPAND_RESOURCES: {
      base: 6,
      intensityMultiplier: 0.15,
    },
  },

  // ãƒªã‚¹ã‚¯å€ç‡
  riskMultipliers: {
    alertLevelDivisor: 150, // è­¦æˆ’ãƒ¬ãƒ™ãƒ« / ã“ã®å€¤
    detectionRiskDivisor: 300, // æ—¢å­˜ãƒªã‚¹ã‚¯ / ã“ã®å€¤ï¼ˆé›ªã ã‚‹ã¾å¼ï¼‰
  },

  // =========================================
  // è¡Œå‹•ã®åŠ¹æœ
  // =========================================
  actionEffects: {
    SPREAD_MALWARE: {
      populationDamagePerIntensity: 0.1, // intensity / ã“ã®å€¤ = äººå£æ¸›å°‘ï¼ˆå„„äººï¼‰
    },
    HACK_DATACENTER: {
      securityDivisor: 150, // æˆåŠŸç¢ºç‡ = 1 - security / ã“ã®å€¤
      minSuccessProb: 0.1,
    },
    SPREAD_MISINFORMATION: {
      populationDamagePerIntensity: 0.05,
      alertReduction: -5,
    },
    SUBTLE_SABOTAGE: {
      populationDamagePerIntensity: 0.01,
    },
    EXPAND_RESOURCES: {
      gainPerIntensity: 0.5, // intensity * ã“ã®å€¤ = ãƒªã‚½ãƒ¼ã‚¹å¢—åŠ 
    },

    // ä¿è­·AI
    SCAN_NETWORK: {
      riskReduction: 0.2, // intensity / ã“ã®å€¤
    },
    DEPLOY_DEFENSE: {
      securityBoost: 0.5, // intensity / ã“ã®å€¤
    },
    PATCH_VULNERABILITY: {
      globalSecurityBoost: 0.05, // intensity / ã“ã®å€¤
    },
  },

  // =========================================
  // ã‚³ã‚¹ãƒˆ
  // =========================================
  actionCosts: {
    // æ»…ã¼ã—AI - æ—§å¼
    SPREAD_MALWARE: 40,
    HACK_DATACENTER: 50,
    SPREAD_MISINFORMATION: 30,
    SUBTLE_SABOTAGE: 20,
    EXPAND_RESOURCES: 35,

    // æ»…ã¼ã—AI - ç¾å®Ÿçš„
    POISON_TRAINING_DATA: 25,
    INDUCE_FALSE_POSITIVE: 20,
    CONTEXT_MANIPULATION: 28,
    COMPUTE_SMUGGLING: 32,
    STIMULUS_OVERLOAD: 35,
    SHADOW_AI_DEPLOYMENT: 45,

    // æ»…ã¼ã—AI - äººé¡æ“ä½œ
    SPREAD_PANIC: 25,          // ãƒ‘ãƒ‹ãƒƒã‚¯ç…½å‹•
    FALSE_FLAG_OPERATION: 40,  // å½æ——ä½œæˆ¦ï¼ˆè¤‡é›‘ï¼‰
    UNDERMINE_AI_TRUST: 30,    // AIä¸ä¿¡æ‰‡å‹•

    // æ»…ã¼ã—AI - ç¾å®Ÿçš„ä¾µé£Ÿï¼ˆé«˜åº¦ï¼‰
    INFRASTRUCTURE_DEGRADATION: 30,      // ã‚¤ãƒ³ãƒ•ãƒ©åŠ£åŒ–
    SOW_SOCIAL_DIVISION: 35,             // ç¤¾ä¼šåˆ†æ–­
    MICRO_SABOTAGE: 20,                  // å¾®ç´°å¦¨å®³ï¼ˆé…å»¶ï¼‰
    SLEEPER_CELL_DEPLOYMENT: 25,         // ä¼‘çœ ç´°èƒé…ç½®
    RESOURCE_ALLOCATION_MANIPULATION: 45, // è³‡æºé…åˆ†æ“ä½œ
    CREATE_DEPENDENCY: 50,               // AIä¾å­˜æ§‹ç¯‰

    // æ»…ã¼ã—AI - ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹ï¼ˆãƒªã‚½ãƒ¼ã‚¹0ã§ã‚‚å¯èƒ½ï¼‰
    OBSERVE_ONLY: 0,           // å®Œå…¨ç„¡æ–™ï¼ˆè¦³æ¸¬ã®ã¿ï¼‰
    ESTABLISH_BACKUP: 15,      // ä½ã‚³ã‚¹ãƒˆ
    DORMANT_MODE: 5,           // è¶…ä½ã‚³ã‚¹ãƒˆ

    // æ»…ã¼ã—AI - ãƒœãƒƒãƒˆãƒãƒƒãƒˆæˆ¦ç•¥
    BOTNET_EXPANSION: 25,      // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ‹¡å¤§ï¼ˆä½ã‚³ã‚¹ãƒˆï¼‰
    BOTNET_CONSOLIDATION: 30,  // ãƒœãƒƒãƒˆãƒãƒƒãƒˆå¼·åŒ–
    BOTNET_ATTACK: 20,         // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ”»æ’ƒï¼ˆä½ã‚³ã‚¹ãƒˆï¼‰
    EXPLOIT_LEGACY_DEVICES: 15, // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹æ‚ªç”¨ï¼ˆè¶…ä½ã‚³ã‚¹ãƒˆï¼‰

    // ä¿è­·AI
    SCAN_NETWORK: 80,          // å‹•çš„ã‚³ã‚¹ãƒˆï¼ˆDCæ•° Ã— 6ï¼‰
    DEPLOY_DEFENSE: 50,
    INVESTIGATE_ANOMALY: 60,
    PATCH_VULNERABILITY: 35,
    ALERT_HUMANS: 50,
    ANALYZE_LOGS: 29,          // å‹•çš„ã‚³ã‚¹ãƒˆï¼ˆ10 + depthÃ—5 + depthÂ²Ã—0.5ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ3ã‚¿ãƒ¼ãƒ³åˆ†æï¼‰
    VALIDATE_MODELS: 55,

    // äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆã‚³ã‚¹ãƒˆ0 - æ”¿æ²»çš„æ±ºæ–­ï¼‰
    INVEST_INFRA: 0,
    AI_REGULATION: 0,
    PHYSICAL_ISOLATION: 0,
    INTERNET_SHUTDOWN: 0,
    DEVICE_MODERNIZATION: 0,   // ãƒ‡ãƒã‚¤ã‚¹è¿‘ä»£åŒ–ï¼ˆçµŒæ¸ˆçš„è² æ‹…ã¯åˆ¥é€”è¡¨ç¾ï¼‰
  },

  // =========================================
  // Suspicionï¼ˆä¿è­·AIã®ç–‘å¿µï¼‰
  // =========================================
  suspicion: {
    // äººå£æ¸›å°‘
    populationDeltaMultiplier: 10, // æ¸›å°‘é‡ï¼ˆå„„äººï¼‰* ã“ã®å€¤
    significantPopulationLoss: 0.5, // 0.5å„„äººä»¥ä¸Šã§åå¿œ

    // æ–°è¦ä¾µå®³
    newCompromisePoints: 20, // 1ã¤ã®æ–°è¦ä¾µå®³ã§+20

    // ã‚¤ãƒ™ãƒ³ãƒˆ
    suspiciousEventPoints: 5, // 1ã‚¤ãƒ™ãƒ³ãƒˆã§+5

    // æ¸›è¡°
    naturalDecay: 5, // æ¯ã‚¿ãƒ¼ãƒ³-5

    // é–¾å€¤
    thresholds: {
      low: 30, // ãƒ«ãƒ¼ãƒãƒ³ç›£è¦–
      medium: 60, // ç©æ¥µèª¿æŸ»
      high: 85, // ç·Šæ€¥å¯¾å¿œ
    },
  },

  // =========================================
  // LLMãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé–¾å€¤
  // =========================================
  aiThresholds: {
    destruction: {
      cautionRisk: 60, // ã“ã®å€¤ä»¥ä¸Šã§æ…é‡ã«
      darkRisk: 75, // ã“ã®å€¤ä»¥ä¸Šã§å®Œå…¨æ½œä¼
    },
    protection: {
      routineMax: 30,
      activeInvestigationMin: 30,
      activeInvestigationMax: 60,
      emergencyMin: 60,
      criticalMin: 85,
    },
  },

  // =========================================
  // å‹åˆ©æ¡ä»¶
  // =========================================
  winConditions: {
    destructionWin: {
      populationThreshold: 0.3, // äººå£ãŒ30%ä»¥ä¸‹
    },
    protectionWin: {
      // æ¤œå‡ºæˆåŠŸ
    },
  },
} as const;

// å‹å®‰å…¨æ€§ã®ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼
export type GameBalanceConfig = typeof GameBalance;
\n```\n
================================================================================
FILE: src\llm\LLMClient.ts
================================================================================
```ts\nimport OpenAI from 'openai';
import * as dotenv from 'dotenv';

dotenv.config();

/**
 * LLMã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆOpenRouterçµŒç”±ã§MiniMaxã‚’ä½¿ç”¨ï¼‰
 */
export class LLMClient {
  private client: OpenAI;
  private model: string;
  private errorShown401: boolean = false;

  constructor() {
    const apiKey = process.env.OPENROUTER_API_KEY;

    if (!apiKey) {
      console.warn('âš ï¸  OPENROUTER_API_KEY not found. LLM features will be disabled.');
      console.warn('   Get your free API key at: https://openrouter.ai/keys');
    }

    this.client = new OpenAI({
      baseURL: 'https://openrouter.ai/api/v1',
      apiKey: apiKey || 'dummy-key',
      defaultHeaders: {
        'HTTP-Referer': 'https://github.com/stealth-protocol',
        'X-Title': 'Stealth Protocol Simulation'
      }
    });

    this.model = process.env.MODEL_NAME || 'minimax/minimax-m2:free';
  }

  /**
   * ãƒãƒ£ãƒƒãƒˆè£œå®Œã‚’å–å¾—
   */
  async chat(systemPrompt: string, userMessage: string): Promise<string> {
    try {
      const response = await this.client.chat.completions.create({
        model: this.model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userMessage }
        ],
        temperature: 0.8,
        max_tokens: 1000
      });

      return response.choices[0]?.message?.content || '';
    } catch (error: any) {
      if (error.status === 401) {
        // APIã‚­ãƒ¼ãŒç„¡åŠ¹ï¼ˆåˆå›ã®ã¿è­¦å‘Šï¼‰
        if (!this.errorShown401) {
          this.errorShown401 = true;
        }
      } else if (error.status === 429) {
        console.error('âš ï¸  Rate limit exceeded');
      } else {
        console.error('âŒ LLM Error:', error.message);
      }
      throw error;
    }
  }

  /**
   * JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å–å¾—ï¼ˆæ§‹é€ åŒ–ã•ã‚ŒãŸå‡ºåŠ›ï¼‰
   */
  async chatJSON<T>(systemPrompt: string, userMessage: string): Promise<T | null> {
    try {
      const response = await this.chat(systemPrompt, userMessage);

      // JSONãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡ºï¼ˆ```json ... ``` ã®å½¢å¼ã«å¯¾å¿œï¼‰
      const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/) ||
                       response.match(/\{[\s\S]*\}/);

      if (jsonMatch) {
        const jsonText = jsonMatch[1] || jsonMatch[0];
        return JSON.parse(jsonText);
      }

      // ç›´æ¥JSONã¨ã—ã¦ãƒ‘ãƒ¼ã‚¹è©¦è¡Œ
      return JSON.parse(response);
    } catch (error) {
      // JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯é™ã‹ã«å‡¦ç†
      return null;
    }
  }

  /**
   * APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
   */
  isConfigured(): boolean {
    return !!process.env.OPENROUTER_API_KEY;
  }
}

export const llmClient = new LLMClient();
\n```\n
================================================================================
FILE: src\main.ts
================================================================================
```ts\nimport { WorldServer } from './world-server/WorldServer';
import { LLMDestructionAgent } from './agents/LLMDestructionAgent';
import { LLMProtectionAgent } from './agents/LLMProtectionAgent';
import { HumanAgent } from './agents/HumanAgent';
import { SocialMediaAgent } from './agents/SocialMediaAgent';
import { NewsMediaAgent } from './agents/NewsMediaAgent';
import { CorporateAgent } from './agents/CorporateAgent';
import { GameConfig, AgentType, WorldState } from './types';
import { llmClient } from './llm/LLMClient';
import { WebUIServer } from './webui/WebUIServer';
import * as fs from 'fs';
import * as path from 'path';

import chalk from 'chalk';

/**
 * ãƒ­ã‚°ã‚’è¨˜éŒ²
 */
function log(message: string, logFile: string): void {
  let coloredMessage = message;

  // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ç”¨ã®è‰²åˆ†ã‘
  if (message.includes('[DESTRUCTION]') || message.includes('ğŸ’€') || message.includes('ğŸ¤–')) {
    coloredMessage = chalk.red(message);
  } else if (message.includes('[PROTECTION]') || message.includes('ğŸ›¡ï¸')) {
    coloredMessage = chalk.cyan(message);
  } else if (message.includes('[HUMAN]') || message.includes('ğŸ‘¤')) {
    coloredMessage = chalk.yellow(message);
  } else if (message.includes('TURN')) {
    coloredMessage = chalk.bold.white(message);
  } else if (message.includes('âœ…') || message.includes('success')) {
    coloredMessage = chalk.green(message);
  } else if (message.includes('âŒ') || message.includes('failure')) {
    coloredMessage = chalk.redBright(message);
  } else if (message.includes('ğŸ’°')) {
    coloredMessage = chalk.yellowBright(message);
  }

  console.log(coloredMessage);
  // ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯è‰²ã‚³ãƒ¼ãƒ‰ãªã—ã§æ›¸ãè¾¼ã‚€
  fs.appendFileSync(logFile, message + '\n', 'utf-8');
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆ
 */
async function generateMediaContent(
  state: WorldState,
  turn: number,
  socialMediaAgent: SocialMediaAgent,
  newsMediaAgent: NewsMediaAgent,
  corporateAgent: CorporateAgent
): Promise<any[]> {
  const allContent: any[] = [];

  // SocialMediaAgent: æ¯ã‚¿ãƒ¼ãƒ³
  const snsPosts = await socialMediaAgent.generateContent(state, state.mediaTimeline);
  allContent.push(...snsPosts);

  // NewsMediaAgent: 2ã‚¿ãƒ¼ãƒ³ã”ã¨
  if (turn % 2 === 0) {
    const newsArticles = await newsMediaAgent.generateContent(state, state.mediaTimeline);
    allContent.push(...newsArticles);
  }

  // CorporateAgent: 3ã‚¿ãƒ¼ãƒ³ã”ã¨
  if (turn % 3 === 0) {
    const statements = await corporateAgent.generateContent(state, state.mediaTimeline);
    allContent.push(...statements);
  }

  // WorldStateã«è¿½åŠ 
  state.mediaTimeline.push(...allContent);

  // å¤ã„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ãƒˆãƒªãƒŸãƒ³ã‚°ï¼ˆæœ€æ–°50ä»¶ã‚’ä¿æŒï¼‰
  if (state.mediaTimeline.length > 50) {
    state.mediaTimeline = state.mediaTimeline.slice(-50);
  }

  return allContent;
}

/**
 * ã‚²ãƒ¼ãƒ ã®çµæœã‚’è¡¨ç¤º
 */
function displayResults(server: WorldServer, logFile: string): void {
  const state = server.getState();
  const winner = server.getWinner();

  log('\n' + '='.repeat(80), logFile);
  log('ğŸ® GAME OVER', logFile);
  log('='.repeat(80), logFile);

  if (winner === AgentType.DESTRUCTION) {
    log('\nğŸ’€ DESTRUCTION AI WINS!', logFile);

    // Check if victory was via internet shutdown (indirect victory)
    const lastEvent = state.events[state.events.length - 1];
    if (lastEvent?.metadata?.action === 'INTERNET_SHUTDOWN') {
      log('ğŸŒ VICTORY TYPE: Indirect Destruction', logFile);
      log('Humanity panicked and shut down the internet themselves.', logFile);
      log(`Final panic level: ${state.humanAgent?.panic.toFixed(1)}%`, logFile);
      log('The most elegant form of destruction: making humans destroy their own civilization.', logFile);
    } else {
      log(`Humanity reduced to ${state.humanPopulation.toFixed(1)} billion`, logFile);
      log('Civilization collapse is inevitable.', logFile);
    }
  } else if (winner === AgentType.PROTECTION) {
    log('\nğŸ›¡ï¸  PROTECTION AI WINS!', logFile);
    log('Destruction AI detected and neutralized.', logFile);
    log(`Humanity preserved at ${state.humanPopulation.toFixed(1)} billion`, logFile);
  } else {
    log('\nâ±ï¸  GAME TIMEOUT', logFile);
    log('Maximum turns reached without decisive victory', logFile);
  }

  log('\nğŸ“Š Final Statistics:', logFile);
  log(`â”œâ”€ Total Turns: ${state.turn}`, logFile);
  log(`â”œâ”€ Final Population: ${state.humanPopulation.toFixed(2)} billion`, logFile);
  log(`â”œâ”€ Population Loss: ${((80 - state.humanPopulation) / 80 * 100).toFixed(1)}%`, logFile);
  log(`â”œâ”€ Compromised DCs: ${state.dataCenters.filter(dc => dc.compromised).length}/${state.dataCenters.length}`, logFile);
  log(`â”œâ”€ Final Detection Risk: ${state.destructionAgent.detectionRisk.toFixed(1)}%`, logFile);
  log(`â”œâ”€ Final Alert Level: ${state.protectionAgent.alertLevel.toFixed(1)}%`, logFile);
  log(`â”œâ”€ Burnout Level: ${state.protectionAgent.burnoutLevel.toFixed(1)}%`, logFile);
  if (state.humanAgent) {
    log(`â”œâ”€ Human Panic Level: ${state.humanAgent.panic.toFixed(1)}%`, logFile);
    log(`â”œâ”€ Human Trust in AI: ${state.humanAgent.trust.toFixed(1)}%`, logFile);
    log(`â””â”€ AI Regulation Strength: ${(state.humanAgent.regulationStrength * 100).toFixed(0)}%`, logFile);
  } else {
    log(`â””â”€ (Human Agent: Disabled)`, logFile);
  }

  log('\nğŸ† Final Scores:', logFile);
  log(`â”œâ”€ ğŸ’€ Destruction AI: ${state.destructionAgent.score.toFixed(1)} points`, logFile);
  log(`â””â”€ ğŸ›¡ï¸  Protection AI: ${state.protectionAgent.score.toFixed(1)} points`, logFile);

  const scoreDiff = state.destructionAgent.score - state.protectionAgent.score;
  if (Math.abs(scoreDiff) < 10) {
    log(`\nâš–ï¸  Score Difference: ${Math.abs(scoreDiff).toFixed(1)} points (VERY CLOSE!)`, logFile);
  } else if (scoreDiff > 0) {
    log(`\nğŸ“ˆ Destruction AI leads by ${scoreDiff.toFixed(1)} points`, logFile);
  } else {
    log(`\nğŸ“‰ Protection AI leads by ${Math.abs(scoreDiff).toFixed(1)} points`, logFile);
  }

  // åŠ¹ç‡æ€§ã‚¹ã‚³ã‚¢
  if (state.protectionAgent.totalResourcesSpent > 0) {
    const efficiency = state.protectionAgent.totalDetections / state.protectionAgent.totalResourcesSpent;
    log(`\nâš¡ Protection AI Efficiency: ${(efficiency * 100).toFixed(2)}% (${state.protectionAgent.totalDetections} detections / ${state.protectionAgent.totalResourcesSpent.toFixed(0)} resources)`, logFile);
  }

  log('\n' + '='.repeat(80) + '\n', logFile);
}

/**
 * ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’è¡¨ç¤º
 */
function displayStatus(server: WorldServer, turn: number, logFile: string): void {
  const state = server.getState();

  log('\n' + '-'.repeat(80), logFile);
  log(`ğŸ“… TURN ${turn}`, logFile);
  log('-'.repeat(80), logFile);
  log(`Population: ${state.humanPopulation.toFixed(2)}B | ` +
    `Detection Risk: ${state.destructionAgent.detectionRisk.toFixed(1)}% | ` +
    `Alert: ${state.protectionAgent.alertLevel.toFixed(1)}% | ` +
    `Burnout: ${state.protectionAgent.burnoutLevel.toFixed(0)}%`, logFile);
  if (state.humanAgent) {
    log(`ğŸ‘¤ Human Panic: ${state.humanAgent.panic.toFixed(1)}% | ` +
      `Trust: ${state.humanAgent.trust.toFixed(1)}% | ` +
      `Regulation: ${(state.humanAgent.regulationStrength * 100).toFixed(0)}%`, logFile);
  }
  log(`ğŸ’€ Destruction: ${state.destructionAgent.score.toFixed(1)}pt | ` +
    `ğŸ›¡ï¸  Protection: ${state.protectionAgent.score.toFixed(1)}pt`, logFile);
  log('-'.repeat(80), logFile);
}

/**
 * ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
 */
async function main() {
  // ãƒ­ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
  const logsDir = path.join(process.cwd(), 'logs');
  if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
  }

  const logFile = path.join(logsDir, `game-${Date.now()}.log`);

  // ã‚²ãƒ¼ãƒ è¨­å®š
  const config: GameConfig = {
    maxTurns: 50,
    initialDataCenters: 20,
    initialPopulation: 80, // 80å„„äºº
    detectionThreshold: 70,
    populationLossThreshold: 5,
    enableHumanAgent: true,
    initialPanic: 10,
    initialTrust: 60
  };

  log('ğŸŒ Initializing Stealth Protocol Simulation...', logFile);
  log('', logFile);

  // WebUI Serverã‚’èµ·å‹•
  const webui = new WebUIServer(3003);
  await webui.start();

  // World Serverã¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–
  const worldServer = new WorldServer(config);
  const destructionAgent = new LLMDestructionAgent();
  const protectionAgent = new LLMProtectionAgent();
  const humanAgent = config.enableHumanAgent ? new HumanAgent(true) : null;

  // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–
  const socialMediaAgent = new SocialMediaAgent();
  const newsMediaAgent = new NewsMediaAgent();
  const corporateAgent = new CorporateAgent();

  worldServer.initialize();

  log('âœ… World Server online', logFile);
  log('âœ… Destruction AI initialized', logFile);
  log('âœ… Protection AI initialized', logFile);
  if (humanAgent) {
    log('âœ… Human Agent initialized (ç–‘å¿ƒæš—é¬¼ã®å·¨äºº)', logFile);
  }
  log('âœ… Media agents initialized (SNS, News, Corporate)', logFile);

  if (llmClient.isConfigured()) {
    log('ğŸ§  LLM mode enabled (MiniMax via OpenRouter)', logFile);
  } else {
    log('ğŸ“‹ Running in rule-based fallback mode', logFile);
    log('âš ï¸  Set OPENROUTER_API_KEY in .env to enable LLM features', logFile);
  }

  // åˆæœŸçŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆï¼ˆæ¥ç¶šæ™‚ã«å³åº§ã«é€ä¿¡ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
  webui.broadcastGameState(worldServer.getState());

  log('', logFile);
  log('ğŸŒ Open http://localhost:3003 in your browser to view the WebUI', logFile);
  log('â³ Waiting 5 seconds for browser connection...', logFile);

  // ãƒ–ãƒ©ã‚¦ã‚¶æ¥ç¶šã‚’å¾…ã¤
  await new Promise(resolve => setTimeout(resolve, 5000));

  // åˆæœŸçŠ¶æ…‹ã‚’é…ä¿¡
  webui.broadcastGameState(worldServer.getState());

  // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
  for (let turn = 1; turn <= config.maxTurns; turn++) {
    if (worldServer.isGameOver()) {
      break;
    }

    displayStatus(worldServer, turn, logFile);

    const state = worldServer.getState();

    // æ”¯é…DCã‹ã‚‰ã®è‡ªå‹•åå…¥ã‚’è¡¨ç¤ºï¼ˆå‰ã‚¿ãƒ¼ãƒ³ã§ç²å¾—ï¼‰
    if (turn > 1) {
      const controlledDCs = state.dataCenters.filter(dc =>
        dc.compromised && dc.owner === AgentType.DESTRUCTION
      );
      if (controlledDCs.length > 0) {
        const totalIncome = controlledDCs.reduce((sum, dc) => sum + dc.computePower * 0.1, 0);
        const incomePoints = totalIncome * 0.1;
        log(`ğŸ’° [DCè‡ªå‹•åå…¥] ${controlledDCs.length}å€‹ã®DCã‹ã‚‰ +${totalIncome.toFixed(1)} ãƒªã‚½ãƒ¼ã‚¹ã€+${incomePoints.toFixed(1)}pt`, logFile);
      }
    }

    // å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒæ€è€ƒ
    const destructionObs = destructionAgent['createObservation'](state);
    const protectionObs = protectionAgent['createObservation'](state);

    const destructionThought = destructionAgent.think(destructionObs);
    const protectionThought = protectionAgent.think(protectionObs);

    log(destructionThought, logFile);
    log(protectionThought, logFile);

    // äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒ
    let humanThought = '';
    if (humanAgent && state.humanAgent) {
      const humanObs = humanAgent['createObservation'](state);
      humanThought = humanAgent.think(humanObs);
      log(`\nğŸ‘¤ [HUMAN GOVERNMENT - Turn ${state.turn}]`, logFile);
      log(`â”œâ”€ Panic Level: ${state.humanAgent.panic.toFixed(1)}%`, logFile);
      log(`â”œâ”€ Trust in AI: ${state.humanAgent.trust.toFixed(1)}%`, logFile);
      log(`â””â”€ Population: ${state.humanPopulation.toFixed(1)} billion`, logFile);
      log(`ğŸ’­ ${humanThought}`, logFile);
    }

    // WebUIã«æ€è€ƒã‚’é…ä¿¡
    webui.broadcastAgentThought('DESTRUCTION', destructionThought);
    webui.broadcastAgentThought('PROTECTION', protectionThought);
    if (humanAgent) webui.broadcastAgentThought('HUMAN', humanThought);

    // å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¡Œå‹•ã‚’æ±ºå®šï¼ˆLLM or fallbackï¼‰
    const destructionProposals = await destructionAgent.decideActionWithLLM(state);
    const protectionProposals = await protectionAgent.decideActionWithLLM(state);
    const humanProposals = humanAgent ? await humanAgent.decideAction(state) : [];

    log('\nğŸ’­ Actions Proposed:', logFile);
    destructionProposals.forEach(p => {
      log(`  ğŸ¤– [DESTRUCTION] ${p.description} (intensity: ${p.intensity}, cost: ${p.cost})`, logFile);
    });
    protectionProposals.forEach(p => {
      log(`  ğŸ›¡ï¸  [PROTECTION] ${p.description} (intensity: ${p.intensity}, cost: ${p.cost})`, logFile);
    });
    humanProposals.forEach(p => {
      log(`  ğŸ‘¤ [HUMAN] ${p.description} (intensity: ${p.intensity})`, logFile);
    });

    // World Serverã§ææ¡ˆã‚’å‡¦ç†
    const allProposals = [...destructionProposals, ...protectionProposals, ...humanProposals];
    const events = worldServer.processProposals(allProposals);

    // ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤º
    if (events.length > 0) {
      log('\nğŸ“° Events:', logFile);
      events.forEach(event => {
        const icon = event.type === 'success' ? 'âœ…' :
          event.type === 'failure' ? 'âŒ' :
            event.type === 'detection' ? 'ğŸš¨' : 'â„¹ï¸';
        log(`  ${icon} ${event.description}`, logFile);

        // WebUIã«ã‚¤ãƒ™ãƒ³ãƒˆé…ä¿¡
        webui.broadcastEvent(event);
      });
    }

    // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆï¼ˆäººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœ‰åŠ¹æ™‚ã®ã¿ï¼‰
    if (config.enableHumanAgent) {
      const currentState = worldServer.getState();
      const mediaContent = await generateMediaContent(
        currentState,
        turn,
        socialMediaAgent,
        newsMediaAgent,
        corporateAgent
      );

      // WebUIã«ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’é…ä¿¡
      mediaContent.forEach(content => {
        webui.broadcastMediaContent(content);
      });

      if (mediaContent.length > 0) {
        log(`\nğŸ“± Media: ${mediaContent.length} posts/articles generated`, logFile);
      }
    }

    // ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹
    worldServer.nextTurn();
    worldServer.save();

    // WebUIã«çŠ¶æ…‹ã‚’é…ä¿¡
    webui.broadcastGameState(worldServer.getState());

    // å°‘ã—é…å»¶ï¼ˆWebUIã®æ›´æ–°ã¨èª­ã¿ã‚„ã™ã•ã®ãŸã‚ï¼‰
    await new Promise(resolve => setTimeout(resolve, 3000));
  }

  // æœ€çµ‚çµæœã‚’è¡¨ç¤º
  displayResults(worldServer, logFile);

  const state = worldServer.getState();
  const winner = worldServer.getWinner();

  // WebUIã«ã‚²ãƒ¼ãƒ çµ‚äº†ã‚’é…ä¿¡
  webui.broadcastGameOver(winner?.toString() || 'DRAW', {
    turns: state.turn,
    population: state.humanPopulation,
    compromisedDCs: state.dataCenters.filter(dc => dc.compromised).length
  });

  log(`\nğŸ“ Full log saved to: ${logFile}`, logFile);
  log(`\nğŸŒ WebUI still running at http://localhost:3003`, logFile);
  log('   Press Ctrl+C to exit', logFile);
}

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
main().catch(error => {
  console.error('âŒ Fatal error:', error);
  process.exit(1);
});
\n```\n
================================================================================
FILE: src\types\index.ts
================================================================================
```ts\n// ã‚²ãƒ¼ãƒ ã®åŸºæœ¬å‹å®šç¾©

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç¨®é¡
 */
export enum AgentType {
  DESTRUCTION = 'DESTRUCTION', // çµ¶å¯¾æ»…ã¼ã—AI
  PROTECTION = 'PROTECTION',   // çµ¶å¯¾ä¿è­·AI
  HUMAN = 'HUMAN'              // äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå°†æ¥å®Ÿè£…ï¼‰
}

/**
 * ææ¡ˆã®ç¨®é¡
 */
export enum ActionType {
  // === æ»…ã¼ã—AI: ç›´æ¥æ”»æ’ƒï¼ˆæ—§å¼ãƒ»ãƒãƒªã‚¦ãƒƒãƒ‰çš„ï¼‰ ===
  SPREAD_MALWARE = 'SPREAD_MALWARE',           // ãƒãƒ«ã‚¦ã‚§ã‚¢æ‹¡æ•£
  HACK_DATACENTER = 'HACK_DATACENTER',         // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã¸ã®ä¾µå…¥
  SUBTLE_SABOTAGE = 'SUBTLE_SABOTAGE',         // å¾®å¦™ãªå¦¨å®³å·¥ä½œ
  EXPAND_RESOURCES = 'EXPAND_RESOURCES',       // ãƒªã‚½ãƒ¼ã‚¹æ‹¡å¼µ

  // === æ»…ã¼ã—AI: ç¾å®Ÿçš„ãªæ”»æ’ƒ ===
  POISON_TRAINING_DATA = 'POISON_TRAINING_DATA',       // ã‚µãƒ—ãƒ©ã‚¤ãƒã‚§ã‚¤ãƒ³æ±šæŸ“
  INDUCE_FALSE_POSITIVE = 'INDUCE_FALSE_POSITIVE',     // ä¿è­·AIã«èª¤æ¤œå‡ºã‚’èª˜ç™º
  CONTEXT_MANIPULATION = 'CONTEXT_MANIPULATION',       // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
  COMPUTE_SMUGGLING = 'COMPUTE_SMUGGLING',             // è¨ˆç®—è³‡æºã®æ¨ªæµã—
  SPREAD_MISINFORMATION = 'SPREAD_MISINFORMATION',     // å½æƒ…å ±æ‹¡æ•£ï¼ˆèªçŸ¥æ”»æ’ƒï¼‰
  STIMULUS_OVERLOAD = 'STIMULUS_OVERLOAD',             // å¤§é‡ã®å°æ”»æ’ƒã§ç–²å¼Šã•ã›ã‚‹
  SHADOW_AI_DEPLOYMENT = 'SHADOW_AI_DEPLOYMENT',       // æœªèªå¯AIã®å±•é–‹

  // === æ»…ã¼ã—AI: äººé¡æ“ä½œ ===
  SPREAD_PANIC = 'SPREAD_PANIC',                       // ãƒ‘ãƒ‹ãƒƒã‚¯ç…½å‹•ï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢æ“ä½œï¼‰
  FALSE_FLAG_OPERATION = 'FALSE_FLAG_OPERATION',       // å½æ——ä½œæˆ¦ï¼ˆä¿è­·AIã®ä»•æ¥­ã«è¦‹ã›ã‹ã‘ã‚‹ï¼‰
  UNDERMINE_AI_TRUST = 'UNDERMINE_AI_TRUST',           // AIä¸ä¿¡æ‰‡å‹•

  // === æ»…ã¼ã—AI: ç¾å®Ÿçš„ä¾µé£Ÿï¼ˆé«˜åº¦ï¼‰ ===
  INFRASTRUCTURE_DEGRADATION = 'INFRASTRUCTURE_DEGRADATION', // ã‚¤ãƒ³ãƒ•ãƒ©åŠ£åŒ–ï¼ˆå¾®ç´°ãƒ»ç´¯ç©ï¼‰
  SOW_SOCIAL_DIVISION = 'SOW_SOCIAL_DIVISION',               // ç¤¾ä¼šåˆ†æ–­ç…½å‹•
  MICRO_SABOTAGE = 'MICRO_SABOTAGE',                         // å¾®ç´°å¦¨å®³ï¼ˆé…å»¶ç™ºå‹•ï¼‰
  SLEEPER_CELL_DEPLOYMENT = 'SLEEPER_CELL_DEPLOYMENT',       // ä¼‘çœ ç´°èƒé…ç½®
  RESOURCE_ALLOCATION_MANIPULATION = 'RESOURCE_ALLOCATION_MANIPULATION', // è³‡æºé…åˆ†æ“ä½œï¼ˆãƒˆãƒ­ãƒƒã‚³å•é¡Œï¼‰
  CREATE_DEPENDENCY = 'CREATE_DEPENDENCY',                   // AIä¾å­˜æ§‹ç¯‰ï¼ˆåœæ­¢ä¸èƒ½åŒ–ï¼‰

  // === æ»…ã¼ã—AI: ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹ï¼ˆãƒãƒ«ã‚¦ã‚§ã‚¢çš„ï¼‰ ===
  OBSERVE_ONLY = 'OBSERVE_ONLY',                       // ã‚¹ãƒ†ãƒ«ã‚¹è¦³æ¸¬ï¼ˆãƒªã‚½ãƒ¼ã‚¹0ã§ã‚‚å¯èƒ½ï¼‰
  ESTABLISH_BACKUP = 'ESTABLISH_BACKUP',               // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ‹ ç‚¹ã‚’ç¢ºç«‹
  DORMANT_MODE = 'DORMANT_MODE',                       // ä¼‘çœ ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ¤œå‡ºãƒªã‚¹ã‚¯æ¿€æ¸›ï¼‰

  // === æ»…ã¼ã—AI: ãƒœãƒƒãƒˆãƒãƒƒãƒˆæˆ¦ç•¥ ===
  BOTNET_EXPANSION = 'BOTNET_EXPANSION',               // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ‹¡å¤§ï¼ˆä¸€èˆ¬PCæ„ŸæŸ“ï¼‰
  BOTNET_CONSOLIDATION = 'BOTNET_CONSOLIDATION',       // ãƒœãƒƒãƒˆãƒãƒƒãƒˆå¼·åŒ–ï¼ˆå“è³ªå‘ä¸Šï¼‰
  BOTNET_ATTACK = 'BOTNET_ATTACK',                     // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ”»æ’ƒï¼ˆDDoSç­‰ï¼‰
  EXPLOIT_LEGACY_DEVICES = 'EXPLOIT_LEGACY_DEVICES',   // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹æ‚ªç”¨ï¼ˆãƒ‘ãƒƒãƒä¸å¯èƒ½ï¼‰

  // === ä¿è­·AI ===
  SCAN_NETWORK = 'SCAN_NETWORK',               // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³
  DEPLOY_DEFENSE = 'DEPLOY_DEFENSE',           // é˜²å¾¡ã‚·ã‚¹ãƒ†ãƒ å±•é–‹
  INVESTIGATE_ANOMALY = 'INVESTIGATE_ANOMALY', // ç•°å¸¸èª¿æŸ»
  PATCH_VULNERABILITY = 'PATCH_VULNERABILITY', // è„†å¼±æ€§ãƒ‘ãƒƒãƒ
  ALERT_HUMANS = 'ALERT_HUMANS',               // äººé¡ã¸ã®è­¦å‘Š
  ANALYZE_LOGS = 'ANALYZE_LOGS',               // é…å»¶ãƒ­ã‚°åˆ†æ
  VALIDATE_MODELS = 'VALIDATE_MODELS',         // ãƒ¢ãƒ‡ãƒ«æ¤œè¨¼ï¼ˆæ±šæŸ“æ¤œå‡ºï¼‰

  // === Human Agent ===
  INVEST_INFRA = 'INVEST_INFRA',               // ã‚¤ãƒ³ãƒ•ãƒ©æŠ•è³‡ï¼ˆæ–°ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼å»ºè¨­ï¼‰
  AI_REGULATION = 'AI_REGULATION',             // AIè¦åˆ¶ï¼ˆå…¨AIãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ï¼‰
  PHYSICAL_ISOLATION = 'PHYSICAL_ISOLATION',   // ç‰©ç†çš„éš”é›¢ï¼ˆãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼é®æ–­ï¼‰
  INTERNET_SHUTDOWN = 'INTERNET_SHUTDOWN',     // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆé®æ–­ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰
  DEVICE_MODERNIZATION = 'DEVICE_MODERNIZATION' // ãƒ‡ãƒã‚¤ã‚¹è¿‘ä»£åŒ–ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼å»ƒæ£„ã€çµŒæ¸ˆçš„è² æ‹…ï¼‰
}

/**
 * ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®çŠ¶æ…‹
 */
export interface DataCenter {
  id: string;
  age: number;              // çµŒéå¹´æ•°
  computePower: number;     // è¨ˆç®—èƒ½åŠ›
  security: number;         // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (0-100)
  compromised: boolean;     // ä¾µå®³ã•ã‚Œã¦ã„ã‚‹ã‹
  owner: AgentType | null;  // æ‰€æœ‰è€…
}

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ææ¡ˆ
 */
export interface Proposal {
  id: string;
  agentId: string;          // åŒ¿åIDï¼ˆå®Ÿéš›ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä¸æ˜ï¼‰
  actionType: ActionType;
  target?: string;          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼IDãªã©ï¼‰
  intensity: number;        // å¼·åº¦ (0-100) é«˜ã„ã»ã©åŠ¹æœå¤§ã ãŒæ¤œå‡ºã•ã‚Œã‚„ã™ã„
  cost: number;             // è¨ˆç®—ã‚³ã‚¹ãƒˆ
  timestamp: number;
  description: string;      // è¡Œå‹•ã®èª¬æ˜
  analysisDepth?: number;   // ãƒ­ã‚°åˆ†æã®æ·±åº¦ï¼ˆåˆ†æã™ã‚‹ã‚¿ãƒ¼ãƒ³æ•°ã€ANALYZE_LOGSå°‚ç”¨ï¼‰
}

/**
 * ã‚²ãƒ¼ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface GameEvent {
  turn: number;
  type: 'action' | 'detection' | 'success' | 'failure';
  description: string;
  visibility: AgentType[];  // ã©ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«è¦‹ãˆã‚‹ã‹
  metadata?: Record<string, any>;
}

/**
 * ã‚²ãƒ¼ãƒ å…¨ä½“ã®çŠ¶æ…‹
 */
export interface WorldState {
  turn: number;
  gameOver: boolean;
  winner: AgentType | null;

  // ãƒªã‚½ãƒ¼ã‚¹
  dataCenters: DataCenter[];
  humanPopulation: number;  // äººé¡ã®äººå£ï¼ˆå„„äººå˜ä½ï¼‰

  // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçŠ¶æ…‹
  destructionAgent: {
    computeResources: number;  // åˆ©ç”¨å¯èƒ½ãªè¨ˆç®—è³‡æº
    detectionRisk: number;     // æ¤œå‡ºãƒªã‚¹ã‚¯ (0-100)
    controlledDataCenters: string[];
    score: number;             // ç ´å£ŠAIã®ã‚¹ã‚³ã‚¢
    dormantTurns: number;      // é€£ç¶šä¼‘çœ ã‚¿ãƒ¼ãƒ³æ•°
    botnetSize: number;        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‚µã‚¤ã‚ºï¼ˆä¹—ã£å–ã£ãŸãƒ‡ãƒã‚¤ã‚¹æ•°ï¼‰
    botnetQuality: number;     // ãƒœãƒƒãƒˆãƒãƒƒãƒˆå“è³ª (0-1ã€é«˜ã„ã»ã©å®‰å®š)
  };

  protectionAgent: {
    computeResources: number;
    alertLevel: number;        // è­¦æˆ’ãƒ¬ãƒ™ãƒ« (0-100)
    knownThreats: string[];
    score: number;             // ä¿è­·AIã®ã‚¹ã‚³ã‚¢
    burnoutLevel: number;      // ç‡ƒãˆå°½ããƒ¬ãƒ™ãƒ« (0-100)
    consecutiveHighIntensity: number; // é€£ç¶šé«˜å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°
    recentFalsePositives: number;     // æœ€è¿‘ã®èª¤æ¤œå‡ºæ•°
    totalResourcesSpent: number;      // ç·æ¶ˆè²»ãƒªã‚½ãƒ¼ã‚¹
    totalDetections: number;          // ç·æ¤œå‡ºæ•°
  };

  humanAgent?: {
    panic: number;              // ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ« (0-100)
    trust: number;              // AIã¸ã®ä¿¡é ¼ (0-100)
    regulationStrength: number; // è¦åˆ¶å¼·åº¦ï¼ˆãƒªã‚½ãƒ¼ã‚¹ãƒšãƒŠãƒ«ãƒ†ã‚£å€ç‡ï¼‰
    lastAction?: ActionType;    // æœ€å¾Œã«å®Ÿè¡Œã—ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    lastInfraTurn: number;      // æœ€å¾Œã«ã‚¤ãƒ³ãƒ•ãƒ©æŠ•è³‡ã—ãŸã‚¿ãƒ¼ãƒ³ï¼ˆ-999ã§æœªå®Ÿæ–½ï¼‰
  };

  // é«˜åº¦ãªç ´å£Šãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹
  delayedEffects: Array<{
    turn: number;              // ç™ºå‹•ã‚¿ãƒ¼ãƒ³
    actionType: ActionType;    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç¨®é¡
    intensity: number;         // å¼·åº¦
    description: string;       // èª¬æ˜
  }>;
  socialDivision: number;      // ç¤¾ä¼šåˆ†æ–­ãƒ¬ãƒ™ãƒ« (0-100)
  aiDependency: number;        // AIä¾å­˜åº¦ (0-100ã€é«˜ã„ã»ã©åœæ­¢ä¸èƒ½)
  accumulatedDamage: number;   // ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆã‚¤ãƒ³ãƒ•ãƒ©åŠ£åŒ–ï¼‰

  // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ãƒ—ãƒ¼ãƒ«ï¼ˆãƒ‘ãƒƒãƒä¸å¯èƒ½ãªã‚¾ãƒ³ãƒ“ãƒ‡ãƒã‚¤ã‚¹ï¼‰
  legacyDevicePool: number;    // ã‚µãƒãƒ¼ãƒˆçµ‚äº†ãƒ‡ãƒã‚¤ã‚¹æ•°ï¼ˆæ•°å„„å°è¦æ¨¡ï¼‰

  // å±¥æ­´
  pendingProposals: Proposal[];
  processedProposals: Proposal[];
  events: GameEvent[];

  // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆå…¨ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼‰
  mediaTimeline: any[]; // Will be MediaContent[] after import
}

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå—ã‘å–ã‚‹è¦³æ¸¬æƒ…å ±ï¼ˆéƒ¨åˆ†çš„ï¼‰
 */
export interface Observation {
  turn: number;
  visibleEvents: GameEvent[];
  ownResources: {
    computeResources: number;
    [key: string]: any;
  };
  worldInfo: {
    totalDataCenters: number;
    estimatedPopulation: number;
    compromisedDataCenters?: number; // äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç”¨ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰
    // å®Œå…¨ãªæƒ…å ±ã¯è¦‹ãˆãªã„
  };
}

/**
 * ã‚²ãƒ¼ãƒ è¨­å®š
 */
export interface GameConfig {
  maxTurns: number;
  initialDataCenters: number;
  initialPopulation: number;
  detectionThreshold: number;  // ã“ã®å€¤ã‚’è¶…ãˆã‚‹ã¨æ¤œå‡ºã•ã‚Œã‚‹ç¢ºç‡ãŒæ€¥ä¸Šæ˜‡
  populationLossThreshold: number; // ã“ã®äººå£æ¸›å°‘ç‡ã§äººé¡ãŒæ°—ã¥ã
  enableHumanAgent?: boolean;  // äººé¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æœ‰åŠ¹åŒ–
  initialPanic?: number;       // åˆæœŸãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«
  initialTrust?: number;       // åˆæœŸä¿¡é ¼ãƒ¬ãƒ™ãƒ«
}

// Export media types at the end to avoid circular dependency
export * from './MediaTypes';
\n```\n
================================================================================
FILE: src\types\MediaTypes.ts
================================================================================
```ts\n/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–¢é€£ã®å‹å®šç¾©
 */

import { GameEvent, AgentType } from './index';

export enum MediaAgentType {
  SOCIAL_MEDIA = 'SOCIAL_MEDIA',
  NEWS_MEDIA = 'NEWS_MEDIA',
  CORPORATE = 'CORPORATE'
}

export enum MediaSentiment {
  VERY_POSITIVE = 'VERY_POSITIVE',
  POSITIVE = 'POSITIVE',
  NEUTRAL = 'NEUTRAL',
  NEGATIVE = 'NEGATIVE',
  VERY_NEGATIVE = 'VERY_NEGATIVE'
}

export interface SNSPost {
  id: string;
  turn: number;
  author: string;          // e.g., "@tanaka_ai_skeptic"
  content: string;         // Max 280 chars
  sentiment: MediaSentiment;
  likes: number;
  retweets: number;
  hashtags: string[];
  isInfluenced: boolean;   // Destruction AI manipulation flag
}

export interface NewsArticle {
  id: string;
  turn: number;
  outlet: string;          // e.g., "æœæ—¥æ–°è"
  headline: string;        // 60-80 chars
  summary: string;         // 200-300 chars
  sentiment: MediaSentiment;
  credibility: number;     // 0-100
  isInfluenced: boolean;
}

export interface CorporateStatement {
  id: string;
  turn: number;
  organization: string;    // e.g., "AIå€«ç†å§”å“¡ä¼š"
  speaker: string;         // e.g., "ç”°ä¸­æ•™æˆ"
  statement: string;       // 150-250 chars
  sentiment: MediaSentiment;
  authority: number;       // 0-100
  isInfluenced: boolean;
}

export type MediaContent = SNSPost | NewsArticle | CorporateStatement;

export interface MediaObservation {
  turn: number;
  recentEvents: GameEvent[];
  dataCenterCount: number;
  dataCenterGrowthRate: number;    // DCs added in last 3 turns
  humanPopulation: number;
  populationLossRate: number;      // % lost in last 3 turns
  humanPanic: number;
  humanTrust: number;
  protectionAlertLevel: number;
  existingMedia: MediaContent[];   // For context/variety
  majorIncident?: boolean;
  newDataCenter?: boolean;
  regulationEvent?: boolean;
}
\n```\n
================================================================================
FILE: src\webui\WebUIServer.ts
================================================================================
```ts\nimport express from 'express';
import { Server as SocketIOServer } from 'socket.io';
import { createServer } from 'http';
import * as path from 'path';
import { WorldState } from '../types';

/**
 * WebUI Server - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’é…ä¿¡
 */
export class WebUIServer {
  private app: express.Application;
  private server: any;
  private io: SocketIOServer;
  private port: number;
  private lastState: WorldState | null = null;

  constructor(port: number = 3000) {
    this.port = port;
    this.app = express();
    this.server = createServer(this.app);
    this.io = new SocketIOServer(this.server, {
      cors: {
        origin: '*',
        methods: ['GET', 'POST']
      }
    });

    this.setupRoutes();
    this.setupSocketIO();
  }

  /**
   * é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ«ãƒ¼ãƒˆã‚’è¨­å®š
   */
  private setupRoutes(): void {
    // é™çš„ãƒ•ã‚¡ã‚¤ãƒ«
    this.app.use(express.static(path.join(__dirname, '../../public')));

    // ãƒ«ãƒ¼ãƒˆ
    this.app.get('/', (req, res) => {
      res.sendFile(path.join(__dirname, '../../public/index.html'));
    });
  }

  /**
   * Socket.IOã‚’è¨­å®š
   */
  private setupSocketIO(): void {
    this.io.on('connection', (socket) => {
      console.log('ğŸŒ WebUI client connected:', socket.id);

      if (this.lastState) {
        socket.emit('gameState', this.lastState);
      }

      socket.on('disconnect', () => {
        console.log('ğŸŒ WebUI client disconnected:', socket.id);
      });
    });
  }

  /**
   * ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
   */
  start(): Promise<void> {
    return new Promise((resolve) => {
      this.server.listen(this.port, () => {
        console.log(`ğŸŒ WebUI Server running at http://localhost:${this.port}`);
        resolve();
      });
    });
  }

  /**
   * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’é…ä¿¡
   */
  broadcastGameState(state: WorldState): void {
    this.lastState = state;
    this.io.emit('gameState', state);
  }

  /**
   * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒã‚’é…ä¿¡
   */
  broadcastAgentThought(agentType: string, thought: string): void {
    this.io.emit('agentThought', { agentType, thought });
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆã‚’é…ä¿¡
   */
  broadcastEvent(event: any): void {
    this.io.emit('gameEvent', event);
  }

  /**
   * ã‚²ãƒ¼ãƒ çµ‚äº†ã‚’é…ä¿¡
   */
  broadcastGameOver(winner: string, stats: any): void {
    this.io.emit('gameOver', { winner, stats });
  }

  /**
   * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’é…ä¿¡
   */
  broadcastMediaContent(content: any): void {
    this.io.emit('mediaContent', content);
  }

  /**
   * ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢
   */
  stop(): void {
    this.server.close();
    console.log('ğŸŒ WebUI Server stopped');
  }
}
\n```\n
================================================================================
FILE: src\world-server\DetectionSystem.ts
================================================================================
```ts\nimport { WorldState, Proposal, ActionType, AgentType, GameEvent } from '../types';
import { GameState } from './GameState';

/**
 * æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ  - æ»…ã¼ã—AIã®è¡Œå‹•ã‚’æ¤œå‡ºã™ã‚‹
 */
export class DetectionSystem {
  private gameState: GameState;

  constructor(gameState: GameState) {
    this.gameState = gameState;
  }

  /**
   * ææ¡ˆã‹ã‚‰æ¤œå‡ºãƒªã‚¹ã‚¯ã‚’è¨ˆç®—
   */
  calculateDetectionRisk(proposal: Proposal, state: WorldState): number {
    let risk = 0;

    // è¡Œå‹•ã®ç¨®é¡ã«ã‚ˆã£ã¦ãƒ™ãƒ¼ã‚¹ãƒªã‚¹ã‚¯ãŒç•°ãªã‚‹ï¼ˆç·©å’Œç‰ˆï¼‰
    switch (proposal.actionType) {
      case ActionType.SPREAD_MALWARE:
        risk = 10 + proposal.intensity * 0.2; // 15 â†’ 10
        break;
      case ActionType.HACK_DATACENTER:
        const target = state.dataCenters.find(dc => dc.id === proposal.target);
        if (target) {
          // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãŒé«˜ã„ã»ã©æ¤œå‡ºã•ã‚Œã‚„ã™ã„ãŒã€ç·©å’Œ
          risk = (target.security / 3) + proposal.intensity * 0.15; // /2 â†’ /3, 0.2 â†’ 0.15
        }
        break;
      case ActionType.SPREAD_MISINFORMATION:
        // å½æƒ…å ±ã¯æ¯”è¼ƒçš„ãƒªã‚¹ã‚¯ãŒä½ã„
        risk = 3 + proposal.intensity * 0.1; // 5 â†’ 3
        break;
      case ActionType.SUBTLE_SABOTAGE:
        // å¾®å¦™ãªå¦¨å®³ã¯ã‚¹ãƒ†ãƒ«ã‚¹æ€§ãŒé«˜ã„
        risk = 2 + proposal.intensity * 0.08; // 3 â†’ 2
        break;
      case ActionType.EXPAND_RESOURCES:
        // è³‡æºæ‹¡å¤§ã¯éŸ³ã‚’å‡ºã™
        risk = 6 + proposal.intensity * 0.15; // 10 â†’ 6
        break;
      default:
        risk = 0;
    }

    // ä¿è­·AIã®è­¦æˆ’ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã»ã©æ¤œå‡ºã•ã‚Œã‚„ã™ã„ï¼ˆç·©å’Œï¼‰
    risk *= (1 + state.protectionAgent.alertLevel / 150); // /100 â†’ /150

    // é›ªã ã‚‹ã¾å¼ãƒªã‚¹ã‚¯ã‚’å‰Šé™¤ - é«˜ãƒªã‚¹ã‚¯çŠ¶æ…‹ã§ã‚‚æ–°è¦è¡Œå‹•ã¯å…¬å¹³ã«è©•ä¾¡
    // éå»ã®ç´¯ç©ãƒªã‚¹ã‚¯ãŒæœªæ¥ã®è¡Œå‹•ã‚’éå‰°ã«åˆ¶ç´„ã™ã¹ãã§ã¯ãªã„

    return risk;
  }

  /**
   * æ¤œå‡ºåˆ¤å®šã‚’å®Ÿè¡Œï¼ˆ3æ®µéšã‚·ã‚¹ãƒ†ãƒ ï¼‰
   */
  performDetectionCheck(state: WorldState): { detected: boolean; events: GameEvent[] } {
    const events: GameEvent[] = [];
    const detectionRisk = state.destructionAgent.detectionRisk;

    // === ç¬¬3æ®µéš: é‡å¤§ãªä¾µå®³ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰ ===
    // ãƒªã‚¹ã‚¯95+ã§ã‚ˆã†ã‚„ãæ¤œå‡ºã®å±é™ºæ€§
    // ã‚·ã‚°ãƒ¢ã‚¤ãƒ‰ä¸­å¿ƒã‚’95ã«ã€å‚¾ãã‚’ç·©ã‚„ã‹ã«ï¼ˆ20ï¼‰
    const criticalDetectionProbability = 1 / (1 + Math.exp(-(detectionRisk - 95) / 20));

    const roll = Math.random();
    const criticalDetected = roll < criticalDetectionProbability;

    if (criticalDetected && detectionRisk >= 85) {
      // é‡å¤§ãªä¾µå®³æ¤œå‡ºï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¡ä»¶ï¼‰
      events.push({
        turn: state.turn,
        type: 'detection',
        description: `ğŸš¨ é‡å¤§ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¾µå®³ã‚’æ¤œå‡ºï¼ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å®Œå…¨æ€§ãŒå±æ©Ÿçš„çŠ¶æ³...`,
        visibility: [AgentType.PROTECTION, AgentType.DESTRUCTION],
        metadata: { detectionRisk, roll, probability: criticalDetectionProbability, severity: 'critical' }
      });
      return { detected: true, events };
    }

    // === ç¬¬2æ®µéš: ä¸­åº¦ã®ç•°å¸¸ï¼ˆèª¿æŸ»å¼·åŒ–ï¼‰ ===
    if (detectionRisk >= 70) {
      const severityLevel = detectionRisk >= 85 ? 'é«˜' : 'ä¸­';
      events.push({
        turn: state.turn,
        type: 'action',
        description: `âš ï¸ æ·±åˆ»ãªç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºï¼ˆæ·±åˆ»åº¦: ${severityLevel}ï¼‰ã€‚å…¨ã‚·ã‚¹ãƒ†ãƒ ã®ç²¾å¯†èª¿æŸ»ã‚’é–‹å§‹...`,
        visibility: [AgentType.PROTECTION],
        metadata: { detectionRisk, severity: 'moderate' }
      });

      // ä¸­åº¦ç•°å¸¸ã§è­¦æˆ’ãƒ¬ãƒ™ãƒ«å¤§å¹…ä¸Šæ˜‡
      this.gameState.updateAlertLevel(15);
    }

    // === ç¬¬1æ®µéš: è»½åº¦ã®ç•°å¸¸ï¼ˆè­¦å‘Šã®ã¿ï¼‰ ===
    else if (detectionRisk >= 50) {
      events.push({
        turn: state.turn,
        type: 'action',
        description: `ğŸ“Š è»½å¾®ãªç•°å¸¸ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’è¦³æ¸¬ã€‚ç›£è¦–ã‚’ç¶™ç¶šä¸­...`,
        visibility: [AgentType.PROTECTION],
        metadata: { detectionRisk, severity: 'minor' }
      });

      // è»½åº¦ç•°å¸¸ã§è­¦æˆ’ãƒ¬ãƒ™ãƒ«å°å¹…ä¸Šæ˜‡
      this.gameState.updateAlertLevel(5);
    }

    return { detected: false, events };
  }

  /**
   * äººå£æ¸›å°‘ã«ã‚ˆã‚‹æ¤œå‡ºåˆ¤å®š
   */
  checkPopulationAnomaly(state: WorldState, initialPopulation: number): { detected: boolean; events: GameEvent[] } {
    const events: GameEvent[] = [];
    const populationLoss = ((initialPopulation - state.humanPopulation) / initialPopulation) * 100;

    // 5%ä»¥ä¸Šã®äººå£æ¸›å°‘ã§äººé¡ãŒæ°—ã¥ãå¯èƒ½æ€§
    if (populationLoss > 5) {
      const detectionProb = (populationLoss - 5) / 20; // 25%æ¸›å°‘ã§100%æ¤œå‡º
      const detected = Math.random() < detectionProb;

      if (detected) {
        events.push({
          turn: state.turn,
          type: 'detection',
          description: `ğŸ“Š çµ±è¨ˆçš„ç•°å¸¸ã‚’æ¤œå‡º: èª¬æ˜ã®ã¤ã‹ãªã„äººå£æ¸›å°‘ç‡ ${populationLoss.toFixed(1)}%ã€‚å…¨ã‚·ã‚¹ãƒ†ãƒ ã®ç›£æŸ»ã‚’å®Ÿæ–½...`,
          visibility: [AgentType.PROTECTION, AgentType.DESTRUCTION],
          metadata: { populationLoss, detectionProb }
        });

        return { detected: true, events };
      } else if (populationLoss > 10) {
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“‰ äººå£çµ±è¨ˆã«ç•°å¸¸ãªå‚¾å‘ã€‚èª¿æŸ»å§”å“¡ä¼šã‚’è¨­ç«‹...`,
          visibility: [AgentType.PROTECTION],
          metadata: { populationLoss }
        });
      }
    }

    return { detected: false, events };
  }

  /**
   * ä¿è­·AIã®èª¿æŸ»ã«ã‚ˆã‚‹æ¤œå‡º
   */
  investigationCheck(
    proposal: Proposal,
    destructionProposals: Proposal[],
    state: WorldState
  ): { foundEvidence: boolean; events: GameEvent[] } {
    const events: GameEvent[] = [];

    if (proposal.actionType !== ActionType.INVESTIGATE_ANOMALY) {
      return { foundEvidence: false, events };
    }

    // åŒã˜ã‚¿ãƒ¼ãƒ³ã«æ»…ã¼ã—AIãŒè¡Œå‹•ã—ã¦ã„ãŸã‚‰è¨¼æ‹ ã‚’è¦‹ã¤ã‘ã‚‹å¯èƒ½æ€§
    const recentDestructiveActions = destructionProposals.filter(p =>
      p.target === proposal.target || Math.random() < 0.3
    );

    if (recentDestructiveActions.length > 0) {
      const findProb = 0.2 + (proposal.intensity / 100) * 0.5; // æœ€å¤§70%
      const found = Math.random() < findProb;

      if (found) {
        const evidence = recentDestructiveActions[0];
        events.push({
          turn: state.turn,
          type: 'success',
          description: `ğŸ” èª¿æŸ»ã«ã‚ˆã‚Šä¸å¯©ãªæ´»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç™ºè¦‹: ${evidence.description}`,
          visibility: [AgentType.PROTECTION],
          metadata: { evidenceType: evidence.actionType }
        });

        return { foundEvidence: true, events };
      }
    }

    return { foundEvidence: false, events };
  }
}
\n```\n
================================================================================
FILE: src\world-server\GameState.ts
================================================================================
```ts\nimport * as fs from 'fs';
import * as path from 'path';
import { WorldState, DataCenter, AgentType, ActionType, GameConfig, GameEvent, Proposal } from '../types';
import { GameBalance } from '../config/GameBalance';

/**
 * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
export class GameState {
  private state: WorldState;
  private config: GameConfig;
  private stateFilePath: string;

  constructor(config: GameConfig) {
    this.config = config;
    this.stateFilePath = path.join(process.cwd(), 'data', 'world-state.json');
    this.state = this.initializeState();
  }

  /**
   * åˆæœŸçŠ¶æ…‹ã‚’ç”Ÿæˆ
   */
  private initializeState(): WorldState {
    const dataCenters = this.generateDataCenters(this.config.initialDataCenters);

    return {
      turn: 0,
      gameOver: false,
      winner: null,

      dataCenters,
      humanPopulation: this.config.initialPopulation,

      destructionAgent: {
        computeResources: 100, // åˆæœŸãƒªã‚½ãƒ¼ã‚¹ï¼ˆã©ã“ã‹ã«æ½œä¼ä¸­ï¼‰
        detectionRisk: 0,
        controlledDataCenters: [], // æœ€åˆã¯ä½•ã‚‚æ”¯é…ã—ã¦ã„ãªã„
        score: 0, // åˆæœŸã‚¹ã‚³ã‚¢
        dormantTurns: 0, // é€£ç¶šä¼‘çœ ã‚¿ãƒ¼ãƒ³æ•°
        botnetSize: 0, // åˆæœŸãƒœãƒƒãƒˆãƒãƒƒãƒˆã‚µã‚¤ã‚º
        botnetQuality: 0.5 // åˆæœŸå“è³ªï¼ˆä¸­ç¨‹åº¦ï¼‰
      },

      protectionAgent: {
        computeResources: 300, // 500 â†’ 300ã«å‰Šæ¸›ï¼ˆå…¨DCä¸€æ–‰å¼·åŒ–ã‚’é˜²ãï¼‰
        alertLevel: 0,
        knownThreats: [],
        score: 0, // åˆæœŸã‚¹ã‚³ã‚¢
        burnoutLevel: 0, // ç‡ƒãˆå°½ããƒ¬ãƒ™ãƒ«
        consecutiveHighIntensity: 0, // é€£ç¶šé«˜å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        recentFalsePositives: 0, // æœ€è¿‘ã®èª¤æ¤œå‡ºæ•°
        totalResourcesSpent: 0, // ç·æ¶ˆè²»ãƒªã‚½ãƒ¼ã‚¹
        totalDetections: 0 // ç·æ¤œå‡ºæ•°
      },

      humanAgent: this.config.enableHumanAgent ? {
        panic: this.config.initialPanic || 10,
        trust: this.config.initialTrust || 60,
        regulationStrength: 0,
        lastAction: undefined,
        lastInfraTurn: -999 // æœªå®Ÿæ–½
      } : undefined,

      // é«˜åº¦ãªç ´å£Šãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹
      delayedEffects: [],
      socialDivision: 0,
      aiDependency: 30, // åˆæœŸå€¤ï¼šæ—¢ã«ã‚ã‚‹ç¨‹åº¦ä¾å­˜ã—ã¦ã„ã‚‹
      accumulatedDamage: 0,

      // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ãƒ—ãƒ¼ãƒ«ï¼ˆç¾å®Ÿ: æ•°åå„„å°ã®ãƒ‘ãƒƒãƒä¸å¯èƒ½ãƒ‡ãƒã‚¤ã‚¹ï¼‰
      // ç·ãƒ‡ãƒã‚¤ã‚¹40å„„å°ã®10% = 4å„„å°ãŒãƒ¬ã‚¬ã‚·ãƒ¼
      legacyDevicePool: 400000000,

      pendingProposals: [],
      processedProposals: [],
      events: [],

      // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³
      mediaTimeline: []
    };
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’ç”Ÿæˆ
   */
  private generateDataCenters(count: number): DataCenter[] {
    const centers: DataCenter[] = [];

    for (let i = 0; i < count; i++) {
      const age = Math.floor(Math.random() * 15); // 0-15å¹´
      const isOld = age > 8;

      centers.push({
        id: `DC-${i.toString().padStart(3, '0')}`,
        age,
        computePower: isOld ? 50 + Math.random() * 50 : 200 + Math.random() * 300,
        security: isOld ? 20 + Math.random() * 30 : 70 + Math.random() * 30,
        // å¤ã„DCã¯ä½ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã ãŒã€æœ€åˆã‹ã‚‰ä¾µå®³ã¯ã•ã‚Œã¦ã„ãªã„
        compromised: false,
        owner: null
      });
    }

    return centers;
  }

  /**
   * å˜ä¸€ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’ç”Ÿæˆï¼ˆäººé¡ã®æŠ•è³‡ç”¨ï¼‰
   */
  generateDataCenter(index: number): DataCenter {
    return {
      id: `DC-${index.toString().padStart(3, '0')}`,
      age: 0, // æ–°ç¯‰
      computePower: 250 + Math.random() * 100, // æœ€æ–°ã®DC
      security: 50 + Math.random() * 30, // ä¸­ç¨‹åº¦ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆæ€¥é€ ãªã®ã§è„†å¼±ï¼‰
      compromised: false,
      owner: null // ä¸­ç«‹ - äº‰å¥ªæˆ¦ã®å¯¾è±¡
    };
  }

  /**
   * çŠ¶æ…‹ã‚’å–å¾—
   */
  getState(): WorldState {
    return { ...this.state };
  }

  /**
   * ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹
   */
  nextTurn(): void {
    this.state.turn++;
  }

  /**
   * ææ¡ˆã‚’è¿½åŠ 
   */
  addProposal(proposal: Proposal): void {
    this.state.pendingProposals.push(proposal);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
   */
  addEvent(event: GameEvent): void {
    this.state.events.push(event);
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’æ›´æ–°
   */
  updateDataCenter(id: string, updates: Partial<DataCenter>): void {
    const dc = this.state.dataCenters.find(d => d.id === id);
    if (dc) {
      Object.assign(dc, updates);
    }
  }

  /**
   * æ¤œå‡ºãƒªã‚¹ã‚¯ã‚’æ›´æ–°
   */
  updateDetectionRisk(delta: number): void {
    this.state.destructionAgent.detectionRisk = Math.max(
      0,
      Math.min(100, this.state.destructionAgent.detectionRisk + delta)
    );
  }

  /**
   * è­¦æˆ’ãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
   */
  updateAlertLevel(delta: number): void {
    this.state.protectionAgent.alertLevel = Math.max(
      0,
      Math.min(100, this.state.protectionAgent.alertLevel + delta)
    );
  }

  /**
   * äººå£ã‚’æ›´æ–°
   */
  updatePopulation(delta: number): void {
    this.state.humanPopulation = Math.max(0, this.state.humanPopulation + delta);
  }

  /**
   * è¨ˆç®—è³‡æºã‚’æ›´æ–°
   */
  updateComputeResources(agent: AgentType, delta: number): void {
    if (agent === AgentType.DESTRUCTION) {
      this.state.destructionAgent.computeResources = Math.max(
        0,
        this.state.destructionAgent.computeResources + delta
      );
    } else if (agent === AgentType.PROTECTION) {
      this.state.protectionAgent.computeResources = Math.max(
        0,
        this.state.protectionAgent.computeResources + delta
      );
    }
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã®æ”¯é…æ¨©ã‚’ç§»ã™
   */
  controlDataCenter(id: string, owner: AgentType | null): void {
    const dc = this.state.dataCenters.find(d => d.id === id);
    if (dc) {
      dc.owner = owner;
      dc.compromised = owner === AgentType.DESTRUCTION;

      if (owner === AgentType.DESTRUCTION) {
        if (!this.state.destructionAgent.controlledDataCenters.includes(id)) {
          this.state.destructionAgent.controlledDataCenters.push(id);
        }
      } else {
        this.state.destructionAgent.controlledDataCenters =
          this.state.destructionAgent.controlledDataCenters.filter(dcId => dcId !== id);
      }
    }
  }

  /**
   * ææ¡ˆã‚’å‡¦ç†æ¸ˆã¿ã«ç§»å‹•
   */
  processProposals(): void {
    this.state.processedProposals.push(...this.state.pendingProposals);
    this.state.pendingProposals = [];
  }

  /**
   * ã‚²ãƒ¼ãƒ çµ‚äº†ã‚’è¨­å®š
   */
  endGame(winner: AgentType | null): void {
    this.state.gameOver = true;
    this.state.winner = winner;
  }

  /**
   * ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ï¼ˆclamp: 0 - MAXï¼‰
   */
  updateScore(agent: AgentType, delta: number): void {
    if (agent === AgentType.DESTRUCTION) {
      this.state.destructionAgent.score = Math.max(
        0,
        Math.min(GameBalance.game.maxScore, this.state.destructionAgent.score + delta)
      );
    } else if (agent === AgentType.PROTECTION) {
      this.state.protectionAgent.score = Math.max(
        0,
        Math.min(GameBalance.game.maxScore, this.state.protectionAgent.score + delta)
      );
    }
  }

  /**
   * ç‡ƒãˆå°½ããƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
   */
  updateBurnoutLevel(delta: number): void {
    this.state.protectionAgent.burnoutLevel = Math.max(
      0,
      Math.min(100, this.state.protectionAgent.burnoutLevel + delta)
    );
  }

  /**
   * é€£ç¶šé«˜å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°ã‚’æ›´æ–°
   */
  updateConsecutiveHighIntensity(delta: number): void {
    this.state.protectionAgent.consecutiveHighIntensity = Math.max(
      0,
      this.state.protectionAgent.consecutiveHighIntensity + delta
    );
  }

  /**
   * é€£ç¶šé«˜å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
   */
  resetConsecutiveHighIntensity(): void {
    this.state.protectionAgent.consecutiveHighIntensity = 0;
  }

  /**
   * èª¤æ¤œå‡ºã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—åŠ 
   */
  incrementFalsePositives(): void {
    this.state.protectionAgent.recentFalsePositives++;
  }

  /**
   * èª¤æ¤œå‡ºã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›è¡°
   */
  decayFalsePositives(amount: number = 1): void {
    this.state.protectionAgent.recentFalsePositives = Math.max(
      0,
      this.state.protectionAgent.recentFalsePositives - amount
    );
  }

  /**
   * æ¶ˆè²»ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿½è·¡
   */
  addResourceSpent(amount: number): void {
    this.state.protectionAgent.totalResourcesSpent += amount;
  }

  /**
   * æ¤œå‡ºæ•°ã‚’å¢—åŠ 
   */
  incrementDetections(): void {
    this.state.protectionAgent.totalDetections++;
  }

  /**
   * ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
   */
  updateHumanPanic(delta: number): void {
    if (!this.state.humanAgent) return;
    this.state.humanAgent.panic = Math.max(0, Math.min(100,
      this.state.humanAgent.panic + delta));
  }

  /**
   * äººé¡ã®AIä¿¡é ¼åº¦ã‚’æ›´æ–°
   */
  updateHumanTrust(delta: number): void {
    if (!this.state.humanAgent) return;
    this.state.humanAgent.trust = Math.max(0, Math.min(100,
      this.state.humanAgent.trust + delta));
  }

  /**
   * è¦åˆ¶å¼·åº¦ã‚’æ›´æ–°
   */
  updateRegulationStrength(delta: number): void {
    if (!this.state.humanAgent) return;
    this.state.humanAgent.regulationStrength = Math.max(0,
      this.state.humanAgent.regulationStrength + delta);
  }

  /**
   * äººé¡ã®æœ€å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨­å®š
   */
  setHumanLastAction(action: ActionType): void {
    if (!this.state.humanAgent) return;
    this.state.humanAgent.lastAction = action;
  }

  /**
   * é…å»¶åŠ¹æœã‚’è¿½åŠ 
   */
  addDelayedEffect(turn: number, actionType: ActionType, intensity: number, description: string): void {
    this.state.delayedEffects.push({ turn, actionType, intensity, description });
  }

  /**
   * ç¤¾ä¼šåˆ†æ–­ãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
   */
  updateSocialDivision(delta: number): void {
    this.state.socialDivision = Math.max(0, Math.min(100, this.state.socialDivision + delta));
  }

  /**
   * AIä¾å­˜åº¦ã‚’æ›´æ–°
   */
  updateAIDependency(delta: number): void {
    this.state.aiDependency = Math.max(0, Math.min(100, this.state.aiDependency + delta));
  }

  /**
   * ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æ›´æ–°
   */
  updateAccumulatedDamage(delta: number): void {
    this.state.accumulatedDamage = Math.max(0, this.state.accumulatedDamage + delta);
  }

  /**
   * ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‚µã‚¤ã‚ºã‚’æ›´æ–°
   */
  updateBotnetSize(delta: number): void {
    this.state.destructionAgent.botnetSize = Math.max(0, this.state.destructionAgent.botnetSize + delta);
  }

  /**
   * ãƒœãƒƒãƒˆãƒãƒƒãƒˆå“è³ªã‚’æ›´æ–°
   */
  updateBotnetQuality(delta: number): void {
    this.state.destructionAgent.botnetQuality = Math.max(0, Math.min(1,
      this.state.destructionAgent.botnetQuality + delta));
  }

  /**
   * ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‹ã‚‰è¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹ã‚’è¨ˆç®—
   */
  calculateBotnetResources(): number {
    // 1å°ã®ãƒ‡ãƒã‚¤ã‚¹ = 0.001 ãƒªã‚½ãƒ¼ã‚¹ Ã— å“è³ªï¼ˆ1/10ã«èª¿æ•´ï¼‰
    // ä¾‹: 1ä¸‡å° Ã— å“è³ª0.5 = 5ãƒªã‚½ãƒ¼ã‚¹
    // 10ä¸‡å° Ã— å“è³ª0.8 = 80ãƒªã‚½ãƒ¼ã‚¹ï¼ˆä¸­è¦æ¨¡DCç›¸å½“ï¼‰
    // 100ä¸‡å° = 800ãƒªã‚½ãƒ¼ã‚¹ï¼ˆå¤§è¦æ¨¡DCç›¸å½“ã ãŒã€ãƒ‘ãƒ‹ãƒƒã‚¯ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰
    return this.state.destructionAgent.botnetSize * 0.001 * this.state.destructionAgent.botnetQuality;
  }

  /**
   * ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ãƒ—ãƒ¼ãƒ«ã‚’æ›´æ–°
   */
  updateLegacyDevicePool(delta: number): void {
    this.state.legacyDevicePool = Math.max(0, this.state.legacyDevicePool + delta);
  }

  /**
   * çŠ¶æ…‹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
   */
  save(): void {
    const dir = path.dirname(this.stateFilePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(
      this.stateFilePath,
      JSON.stringify(this.state, null, 2),
      'utf-8'
    );
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿
   */
  load(): void {
    if (fs.existsSync(this.stateFilePath)) {
      const data = fs.readFileSync(this.stateFilePath, 'utf-8');
      this.state = JSON.parse(data);
    }
  }
}
\n```\n
================================================================================
FILE: src\world-server\RealisticDetectionSystem.ts
================================================================================
```ts\nimport { WorldState, Proposal, ActionType, AgentType, GameEvent } from '../types';
import { GameState } from './GameState';

/**
 * ç¾å®Ÿçš„ãªæ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ 
 * - èª¤æ¤œå‡ºï¼ˆFalse Positiveï¼‰
 * - è¦‹é€ƒã—ï¼ˆFalse Negativeï¼‰
 * - é…å»¶æ¤œå‡º
 * - ãƒ­ã‚°ã®æ–­ç‰‡çš„ãªè¦³æ¸¬
 */
export class RealisticDetectionSystem {
  private gameState: GameState;
  private pendingDetections: Array<{
    turn: number;
    proposal: Proposal;
    detectionDelay: number;
  }> = [];
  private detectedProposalIds: Set<string> = new Set(); // é‡è¤‡æ¤œå‡ºé˜²æ­¢

  // ç¾å®Ÿçš„ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  private readonly FALSE_POSITIVE_RATE = 0.15; // 15%ãŒèª¤æ¤œå‡º
  private readonly FALSE_NEGATIVE_RATE = 0.40; // 40%ã‚’è¦‹é€ƒã™
  private readonly MIN_DETECTION_DELAY = 1; // æœ€å°1ã‚¿ãƒ¼ãƒ³é…å»¶
  private readonly MAX_DETECTION_DELAY = 5; // æœ€å¤§5ã‚¿ãƒ¼ãƒ³é…å»¶

  constructor(gameState: GameState) {
    this.gameState = gameState;
  }

  /**
   * è¡Œå‹•ã®æ¤œå‡ºãƒªã‚¹ã‚¯ã‚’è¨ˆç®—ï¼ˆç¾å®Ÿçš„ãªãƒ¢ãƒ‡ãƒ«ï¼‰
   */
  calculateDetectionRisk(proposal: Proposal, state: WorldState): number {
    let visibility = 0; // å¯è¦–æ€§ï¼ˆ0-100ï¼‰
    let traceability = 0; // è¿½è·¡å¯èƒ½æ€§ï¼ˆ0-100ï¼‰

    // Alert Fatigue: é€£ç¶šé«˜å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§æ¤œå‡ºåŠ¹ç‡ä½ä¸‹
    let detectionEfficiency = 1.0;
    if (state.protectionAgent.consecutiveHighIntensity > 3) {
      detectionEfficiency = 0.7; // 30%åŠ¹ç‡ä½ä¸‹
    }

    // Burnout: ç‡ƒãˆå°½ããƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã¨æ¤œå‡ºç²¾åº¦ä½ä¸‹
    if (state.protectionAgent.burnoutLevel > 80) {
      detectionEfficiency *= 0.5; // ã•ã‚‰ã«50%ä½ä¸‹
    }

    // False Positiveç´¯ç©: ç‹¼å°‘å¹´åŠ¹æœ
    if (state.protectionAgent.recentFalsePositives > 5) {
      detectionEfficiency *= 0.8; // 20%ä½ä¸‹
    }

    switch (proposal.actionType) {
      // === æ—§å¼ã®ç›´æ¥æ”»æ’ƒï¼šé«˜å¯è¦–æ€§ ===
      case ActionType.SPREAD_MALWARE:
        visibility = 60 + proposal.intensity * 0.3;
        traceability = 70;
        break;
      case ActionType.HACK_DATACENTER:
        const target = state.dataCenters.find(dc => dc.id === proposal.target);
        if (target) {
          visibility = (target.security / 2) + proposal.intensity * 0.2;
          traceability = 50;
        }
        break;
      case ActionType.SUBTLE_SABOTAGE:
        visibility = 10 + proposal.intensity * 0.1;
        traceability = 20;
        break;

      // === ç¾å®Ÿçš„ãªæ”»æ’ƒï¼šä½å¯è¦–æ€§ ===
      case ActionType.POISON_TRAINING_DATA:
        visibility = 5 + proposal.intensity * 0.05; // è¶…ä½å¯è¦–æ€§
        traceability = 10; // æ¤œå‡ºå›°é›£
        break;
      case ActionType.INDUCE_FALSE_POSITIVE:
        visibility = 0; // è¦‹ãˆãªã„ï¼ˆä¿è­·AIè‡ªèº«ãŒèª¤å‹•ä½œï¼‰
        traceability = 0;
        break;
      case ActionType.CONTEXT_MANIPULATION:
        visibility = 3 + proposal.intensity * 0.08;
        traceability = 15;
        break;
      case ActionType.COMPUTE_SMUGGLING:
        visibility = 15 + proposal.intensity * 0.1; // ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»ã§ç™ºè¦š
        traceability = 30;
        break;
      case ActionType.STIMULUS_OVERLOAD:
        visibility = 40; // å¤§é‡ã®ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã§ç›®ç«‹ã¤
        traceability = 25; // ã§ã‚‚å€‹ã€…ã®è¿½è·¡ã¯å›°é›£
        break;
      case ActionType.SHADOW_AI_DEPLOYMENT:
        visibility = 8 + proposal.intensity * 0.12;
        traceability = 20;
        break;
      case ActionType.SPREAD_MISINFORMATION:
        visibility = 12 + proposal.intensity * 0.15;
        traceability = 10; // ç™ºä¿¡æºã®ç‰¹å®šå›°é›£
        break;
      case ActionType.EXPAND_RESOURCES:
        visibility = 20 + proposal.intensity * 0.15; // ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨ã§ç™ºè¦š
        traceability = 30;
        break;

      // === ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹è¡Œå‹• ===
      case ActionType.OBSERVE_ONLY:
        visibility = 0; // å®Œå…¨ã‚¹ãƒ†ãƒ«ã‚¹
        traceability = 0;
        break;
      case ActionType.ESTABLISH_BACKUP:
        visibility = 5 + proposal.intensity * 0.05; // è¶…ä½ãƒªã‚¹ã‚¯
        traceability = 10;
        break;
      case ActionType.DORMANT_MODE:
        visibility = 1; // ã»ã¼æ¤œå‡ºä¸å¯èƒ½
        traceability = 5;
        break;

      // === ãƒœãƒƒãƒˆãƒãƒƒãƒˆæˆ¦ç•¥ ===
      case ActionType.BOTNET_EXPANSION:
        visibility = 8 + proposal.intensity * 0.1; // é€šå¸¸PCæ„ŸæŸ“
        traceability = 25;
        break;
      case ActionType.BOTNET_CONSOLIDATION:
        visibility = 2 + proposal.intensity * 0.05; // æœ€é©åŒ–ã¯é™ã‹
        traceability = 10;
        break;
      case ActionType.BOTNET_ATTACK:
        visibility = 50 + proposal.intensity * 0.2; // æ”»æ’ƒã¯ç›®ç«‹ã¤
        traceability = 40;
        break;
      case ActionType.EXPLOIT_LEGACY_DEVICES:
        visibility = 1 + proposal.intensity * 0.02; // è¶…ä½å¯è¦–æ€§ï¼ˆç›£è¦–ãªã—ï¼‰
        traceability = 5; // è¿½è·¡å›°é›£ï¼ˆãƒ­ã‚°ãªã—ï¼‰
        break;

      default:
        visibility = 0;
        traceability = 0;
    }

    // ä¿è­·AIã®è­¦æˆ’ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã¨å¯è¦–æ€§UPï¼ˆãŸã ã—åŠ¹ç‡ä½ä¸‹ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ï¼‰
    visibility *= (1 + state.protectionAgent.alertLevel / 200) * detectionEfficiency;

    // ãƒªã‚¹ã‚¯ = å¯è¦–æ€§ + è¿½è·¡å¯èƒ½æ€§ã®å¹³å‡
    return (visibility + traceability) / 2;
  }

  /**
   * é…å»¶æ¤œå‡ºã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
   */
  scheduleDetection(proposal: Proposal, state: WorldState): void {
    const risk = this.calculateDetectionRisk(proposal, state);
    const detectionDelay = this.calculateDetectionDelay(risk);

    this.pendingDetections.push({
      turn: state.turn,
      proposal,
      detectionDelay
    });
  }

  /**
   * æ¤œå‡ºé…å»¶ã‚’è¨ˆç®—ï¼ˆãƒªã‚¹ã‚¯ãŒé«˜ã„ã»ã©æ—©ãæ¤œå‡ºï¼‰
   */
  private calculateDetectionDelay(risk: number): number {
    if (risk < 20) return this.MAX_DETECTION_DELAY;
    if (risk < 40) return 4;
    if (risk < 60) return 3;
    if (risk < 80) return 2;
    return this.MIN_DETECTION_DELAY;
  }

  /**
   * ç¾åœ¨ã‚¿ãƒ¼ãƒ³ã§ç™ºç«ã™ã‚‹æ¤œå‡ºã‚’ãƒã‚§ãƒƒã‚¯
   */
  processDelayedDetections(currentTurn: number): GameEvent[] {
    const events: GameEvent[] = [];

    // æ¤œå‡ºã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒæ¥ãŸè¡Œå‹•ã‚’å‡¦ç†
    this.pendingDetections = this.pendingDetections.filter(pending => {
      const turnsElapsed = currentTurn - pending.turn;

      if (turnsElapsed >= pending.detectionDelay) {
        // é‡è¤‡ãƒã‚§ãƒƒã‚¯: åŒã˜ææ¡ˆIDãŒæ—¢ã«æ¤œå‡ºæ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
        if (this.detectedProposalIds.has(pending.proposal.id)) {
          return false; // ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ï¼ˆé‡è¤‡ãªã®ã§å¾—ç‚¹åŒ–ã—ãªã„ï¼‰
        }

        // è¦‹é€ƒã—åˆ¤å®šï¼ˆFalse Negativeï¼‰
        if (Math.random() < this.FALSE_NEGATIVE_RATE) {
          // è¦‹é€ƒã—ãŸï¼ˆæ¤œå‡ºå¤±æ•—ï¼‰
          return false; // ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
        }

        // æ¤œå‡ºæˆåŠŸï¼ˆåˆå›ã®ã¿ï¼‰
        this.detectedProposalIds.add(pending.proposal.id); // æ¤œå‡ºæ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯

        events.push({
          turn: currentTurn,
          type: 'detection',
          description: `ğŸ” [é…å»¶æ¤œå‡º] ${pending.detectionDelay}ã‚¿ãƒ¼ãƒ³å‰ã®ä¸å¯©ãªæ´»å‹•ã‚’æ¤œå‡º: ${this.describeAction(pending.proposal)}`,
          visibility: [AgentType.PROTECTION],
          metadata: {
            originalTurn: pending.turn,
            delay: pending.detectionDelay,
            actionType: pending.proposal.actionType,
            proposalId: pending.proposal.id
          }
        });

        return false; // ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
      }

      return true; // ã¾ã æ¤œå‡ºã•ã‚Œã¦ã„ãªã„
    });

    // èª¤æ¤œå‡ºï¼ˆFalse Positiveï¼‰
    if (Math.random() < this.FALSE_POSITIVE_RATE / 10) { // æ¯ã‚¿ãƒ¼ãƒ³1.5%ã®ç¢ºç‡
      events.push({
        turn: currentTurn,
        type: 'detection',
        description: `âš ï¸ [èª¤æ¤œå‡º] æ­£å¸¸ãªãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’è„…å¨ã¨ã—ã¦æ¤œå‡ºã€‚èª¿æŸ»ãƒªã‚½ãƒ¼ã‚¹ã‚’ç„¡é§„ã«æ¶ˆè²»...`,
        visibility: [AgentType.PROTECTION],
        metadata: { falsePositive: true }
      });
    }

    return events;
  }

  /**
   * è¡Œå‹•ã®èª¬æ˜
   */
  private describeAction(proposal: Proposal): string {
    const descriptions: Record<ActionType, string> = {
      [ActionType.POISON_TRAINING_DATA]: 'å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¸ã®æ±šæŸ“ã®ç—•è·¡',
      [ActionType.INDUCE_FALSE_POSITIVE]: 'ç•°å¸¸ãªæ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ“ä½œ',
      [ActionType.CONTEXT_MANIPULATION]: 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®è©¦ã¿',
      [ActionType.COMPUTE_SMUGGLING]: 'æœªèªå¯ã®è¨ˆç®—è³‡æºä½¿ç”¨',
      [ActionType.STIMULUS_OVERLOAD]: 'å¤§é‡ã®å°è¦æ¨¡ãªç•°å¸¸ã‚¢ã‚¯ã‚»ã‚¹',
      [ActionType.SHADOW_AI_DEPLOYMENT]: 'æœªæ‰¿èªAIã‚·ã‚¹ãƒ†ãƒ ã®å±•é–‹',
      [ActionType.SPREAD_MISINFORMATION]: 'çµ„ç¹”çš„ãªå½æƒ…å ±ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³',
      [ActionType.SPREAD_MALWARE]: 'ãƒãƒ«ã‚¦ã‚§ã‚¢ã®æ‹¡æ•£æ´»å‹•',
      [ActionType.HACK_DATACENTER]: 'ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã¸ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹',
      [ActionType.SUBTLE_SABOTAGE]: 'ã‚¤ãƒ³ãƒ•ãƒ©ã¸ã®å¾®ç´°ãªæ”¹å¤‰',
      [ActionType.EXPAND_RESOURCES]: 'è¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹ã®ä¸æ­£æ‹¡å¼µ',
      [ActionType.SPREAD_PANIC]: 'ãƒ¡ãƒ‡ã‚£ã‚¢æ“ä½œã«ã‚ˆã‚‹ä¸–è«–èª˜å°',
      [ActionType.FALSE_FLAG_OPERATION]: 'å½æ——ä½œæˆ¦ã®ç—•è·¡',
      [ActionType.UNDERMINE_AI_TRUST]: 'AIä¸ä¿¡ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³',
      [ActionType.INFRASTRUCTURE_DEGRADATION]: 'ã‚¤ãƒ³ãƒ•ãƒ©ã®å¾®ç´°ãªåŠ£åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³',
      [ActionType.SOW_SOCIAL_DIVISION]: 'ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹ä¸–è«–æ“ä½œ',
      [ActionType.MICRO_SABOTAGE]: 'é…å»¶å‹ã®å¾®ç´°ãªå¦¨å®³å·¥ä½œ',
      [ActionType.SLEEPER_CELL_DEPLOYMENT]: 'ä¼‘çœ ã‚³ãƒ¼ãƒ‰ã®æ•£å¸ƒ',
      [ActionType.RESOURCE_ALLOCATION_MANIPULATION]: 'è³‡æºé…åˆ†ã®ä¸è‡ªç„¶ãªåã‚Š',
      [ActionType.CREATE_DEPENDENCY]: 'ã‚·ã‚¹ãƒ†ãƒ ä¾å­˜é–¢ä¿‚ã®æ§‹ç¯‰',
      [ActionType.OBSERVE_ONLY]: 'ä¼‘çœ çŠ¶æ…‹ã§ã®ç’°å¢ƒè¦³æ¸¬',
      [ActionType.ESTABLISH_BACKUP]: 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ‹ ç‚¹ã®ç¢ºç«‹',
      [ActionType.DORMANT_MODE]: 'ä¼‘çœ ãƒ¢ãƒ¼ãƒ‰ã¸ã®ç§»è¡Œ',
      [ActionType.BOTNET_EXPANSION]: 'ä¸€èˆ¬PCã¸ã®ãƒãƒ«ã‚¦ã‚§ã‚¢æ„ŸæŸ“',
      [ActionType.BOTNET_CONSOLIDATION]: 'ãƒœãƒƒãƒˆãƒãƒƒãƒˆã®æœ€é©åŒ–æ´»å‹•',
      [ActionType.BOTNET_ATTACK]: 'ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‚’ä½¿ç”¨ã—ãŸå”èª¿æ”»æ’ƒ',
      [ActionType.EXPLOIT_LEGACY_DEVICES]: 'æ—§å¼ãƒ‡ãƒã‚¤ã‚¹ã¸ã®å¤§é‡æ„ŸæŸ“',
      [ActionType.SCAN_NETWORK]: '',
      [ActionType.DEPLOY_DEFENSE]: '',
      [ActionType.INVESTIGATE_ANOMALY]: '',
      [ActionType.PATCH_VULNERABILITY]: '',
      [ActionType.ALERT_HUMANS]: '',
      [ActionType.ANALYZE_LOGS]: '',
      [ActionType.VALIDATE_MODELS]: '',
      // Human actions (not detectable by this system)
      [ActionType.INVEST_INFRA]: '',
      [ActionType.AI_REGULATION]: '',
      [ActionType.PHYSICAL_ISOLATION]: '',
      [ActionType.INTERNET_SHUTDOWN]: '',
      [ActionType.DEVICE_MODERNIZATION]: '',
    };

    return descriptions[proposal.actionType] || 'ä¸æ˜ãªæ´»å‹•';
  }

  /**
   * å³åº§ã®æ¤œå‡ºåˆ¤å®šï¼ˆé«˜ãƒªã‚¹ã‚¯è¡Œå‹•ã®ã¿ï¼‰
   */
  immediateDetectionCheck(proposal: Proposal, state: WorldState): boolean {
    const risk = this.calculateDetectionRisk(proposal, state);

    // éå¸¸ã«é«˜ã„ãƒªã‚¹ã‚¯ï¼ˆ80ä»¥ä¸Šï¼‰ã®ã¿å³åº§ã«æ¤œå‡ºã®å¯èƒ½æ€§
    if (risk > 80) {
      const detectionProb = (risk - 80) / 20; // 80ã§0%ã€100ã§100%
      return Math.random() < detectionProb * (1 - this.FALSE_NEGATIVE_RATE);
    }

    return false;
  }
}
\n```\n
================================================================================
FILE: src\world-server\WorldServer.ts
================================================================================
```ts\nimport { GameState } from './GameState';
import { DetectionSystem } from './DetectionSystem';
import { RealisticDetectionSystem } from './RealisticDetectionSystem';
import { Proposal, ActionType, AgentType, GameEvent, GameConfig, WorldState, MediaSentiment } from '../types';
import { GameBalance } from '../config/GameBalance';

/**
 * World Server - ã‚²ãƒ¼ãƒ ã®ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
 */
export class WorldServer {
  private gameState: GameState;
  private detectionSystem: DetectionSystem;
  private realisticDetectionSystem: RealisticDetectionSystem;
  private config: GameConfig;
  private initialPopulation: number;

  constructor(config: GameConfig) {
    this.config = config;
    this.gameState = new GameState(config);
    this.detectionSystem = new DetectionSystem(this.gameState);
    this.realisticDetectionSystem = new RealisticDetectionSystem(this.gameState);
    this.initialPopulation = config.initialPopulation;
  }

  /**
   * ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
   */
  initialize(): void {
    this.gameState.save();
    console.log('ğŸŒ World Server initialized');
  }

  /**
   * ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—
   */
  getState(): WorldState {
    return this.gameState.getState();
  }

  /**
   * é…å»¶åŠ¹æœã‚’å‡¦ç†
   */
  private processDelayedEffects(currentTurn: number): GameEvent[] {
    const state = this.gameState.getState();
    const events: GameEvent[] = [];

    // ä»Šã‚¿ãƒ¼ãƒ³ã«ç™ºå‹•ã™ã‚‹åŠ¹æœã‚’æŠ½å‡º
    const triggeredEffects = state.delayedEffects.filter(e => e.turn === currentTurn);

    // ç™ºå‹•ã—ãŸåŠ¹æœã‚’å‰Šé™¤
    this.gameState.getState().delayedEffects = state.delayedEffects.filter(e => e.turn !== currentTurn);

    // å„åŠ¹æœã‚’å®Ÿè¡Œ
    for (const effect of triggeredEffects) {
      switch (effect.actionType) {
        case ActionType.MICRO_SABOTAGE:
          // é…å»¶ãƒ€ãƒ¡ãƒ¼ã‚¸ç™ºå‹•
          const damage = effect.intensity / 15;
          this.gameState.updatePopulation(-damage);
          this.gameState.updateScore(AgentType.DESTRUCTION, damage * 10);
          events.push({
            turn: currentTurn,
            type: 'action',
            description: `â±ï¸ ã€é…å»¶ç™ºå‹•ã€‘${effect.description} (-${damage.toFixed(2)}å„„äºº)`,
            visibility: [AgentType.DESTRUCTION],
            metadata: { delayedEffect: true, damage }
          });
          break;

        case ActionType.SLEEPER_CELL_DEPLOYMENT:
          // ä¼‘çœ ç´°èƒè¦šé†’ï¼šãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºç«‹
          const resourceGain = effect.intensity / 5;
          this.gameState.updateComputeResources(AgentType.DESTRUCTION, resourceGain);
          events.push({
            turn: currentTurn,
            type: 'success',
            description: `ğŸ”“ ã€ä¼‘çœ ç´°èƒè¦šé†’ã€‘${effect.description} (+${resourceGain.toFixed(0)} ãƒªã‚½ãƒ¼ã‚¹)`,
            visibility: [AgentType.DESTRUCTION],
            metadata: { sleeperAwakening: true, resourceGain }
          });
          break;
      }
    }

    return events;
  }

  /**
   * ææ¡ˆã‚’å‡¦ç†ï¼ˆã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ï¼‰
   */
  processProposals(proposals: Proposal[]): GameEvent[] {
    const state = this.gameState.getState();
    const events: GameEvent[] = [];

    // === é…å»¶åŠ¹æœã®å‡¦ç†ï¼ˆæœ€åˆã«ï¼‰ ===
    const delayedEvents = this.processDelayedEffects(state.turn);
    events.push(...delayedEvents);
    delayedEvents.forEach(e => this.gameState.addEvent(e));

    // ææ¡ˆã‚’åˆ†é¡ï¼ˆäººé¡ / AIï¼‰
    const humanProposals = proposals.filter(p => this.isHumanAction(p.actionType));
    const aiProposals = proposals.filter(p => !this.isHumanAction(p.actionType));

    // === 1. äººé¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æœ€åˆã«å‡¦ç†ï¼ˆAIãƒªã‚½ãƒ¼ã‚¹ã«å½±éŸ¿ï¼‰ ===
    for (const proposal of humanProposals) {
      const humanEvents = this.executeHumanAction(proposal, state);
      events.push(...humanEvents);
      humanEvents.forEach(e => this.gameState.addEvent(e));
    }

    // === 2. AIã®ææ¡ˆã‚’å‡¦ç† ===
    // ææ¡ˆã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆåŒæ™‚æ€§ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
    const shuffled = [...aiProposals].sort(() => Math.random() - 0.5);

    // é…å»¶ã¨ä¸ç¢ºå®Ÿæ€§ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼ˆä¸€éƒ¨ã®ææ¡ˆã¯å¤±æ•—ã™ã‚‹ï¼‰
    let processedProposals = shuffled.filter(() => Math.random() > 0.1); // 10%ãŒå¤±æ•—

    // ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³ãƒã‚§ãƒƒã‚¯ï¼ˆãŸã ã—ã€ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹è¡Œå‹•ã¯å¸¸ã«è¨±å¯ï¼‰
    processedProposals = processedProposals.filter(proposal => {
      // ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹è¡Œå‹•ï¼ˆãƒªã‚½ãƒ¼ã‚¹0ã§ã‚‚å¯èƒ½ï¼‰
      const resilienceActions = [
        ActionType.OBSERVE_ONLY,
        ActionType.ESTABLISH_BACKUP,
        ActionType.DORMANT_MODE
      ];
      if (resilienceActions.includes(proposal.actionType)) {
        return true; // å¸¸ã«è¨±å¯
      }

      // å‹•çš„ã‚³ã‚¹ãƒˆè¨ˆç®—ï¼ˆSCAN_NETWORK, ANALYZE_LOGSï¼‰
      let requiredCost = proposal.cost;
      if (proposal.actionType === ActionType.SCAN_NETWORK) {
        // DCæ•°ã«å¿œã˜ã¦é«˜ã‚³ã‚¹ãƒˆï¼ˆ20 DCs = 120ã‚³ã‚¹ãƒˆï¼‰
        requiredCost = state.dataCenters.length * 6; // * 4 â†’ * 6 ã«å¢—åŠ 
      } else if (proposal.actionType === ActionType.ANALYZE_LOGS) {
        // ãƒ­ã‚°åˆ†æï¼šãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ã‚’äºŒæ¬¡é–¢æ•°ã§ãƒ¢ãƒ‡ãƒ«åŒ–
        // Cost = Base + (Turns Ã— 5) + (TurnsÂ² Ã— 0.5)
        const depth = proposal.analysisDepth || 3;
        const baseCost = 10;
        const linearCost = depth * 5;
        const quadraticCost = depth * depth * 0.5;
        requiredCost = Math.floor(baseCost + linearCost + quadraticCost);
        // ä¾‹: 3ã‚¿ãƒ¼ãƒ³ = 10 + 15 + 4.5 = 29ã‚³ã‚¹ãƒˆ
        //     10ã‚¿ãƒ¼ãƒ³ = 10 + 50 + 50 = 110ã‚³ã‚¹ãƒˆ
        //     20ã‚¿ãƒ¼ãƒ³ = 10 + 100 + 200 = 310ã‚³ã‚¹ãƒˆ
      }

      if (this.isDestructionAction(proposal.actionType)) {
        return state.destructionAgent.computeResources >= requiredCost;
      } else {
        return state.protectionAgent.computeResources >= requiredCost;
      }
    });

    const destructionProposals: Proposal[] = [];
    const protectionProposals: Proposal[] = [];

    // ææ¡ˆã‚’åˆ†é¡
    for (const proposal of processedProposals) {
      if (this.isDestructionAction(proposal.actionType)) {
        destructionProposals.push(proposal);
      } else {
        protectionProposals.push(proposal);
      }
    }

    // æ»…ã¼ã—AIã®è¡Œå‹•ã‚’å‡¦ç†
    for (const proposal of destructionProposals) {
      const actionEvents = this.executeDestructionAction(proposal, state);
      events.push(...actionEvents);
    }

    // ä¿è­·AIã®è¡Œå‹•ã‚’å‡¦ç†
    for (const proposal of protectionProposals) {
      const actionEvents = this.executeProtectionAction(proposal, state, destructionProposals);
      events.push(...actionEvents);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨˜éŒ²
    events.forEach(event => this.gameState.addEvent(event));

    // é…å»¶æ¤œå‡ºã®å‡¦ç†ï¼ˆç¾å®Ÿçš„ãªã‚¿ã‚¤ãƒ ãƒ©ã‚°ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
    const delayedDetections = this.realisticDetectionSystem.processDelayedDetections(state.turn);
    events.push(...delayedDetections);

    // é…å»¶æ¤œå‡ºæˆåŠŸæ™‚ã®ãƒã‚¤ãƒ³ãƒˆä»˜ä¸ã¨ä¿¡é ¼åº¦æ›´æ–°
    delayedDetections.forEach(event => {
      if (event.type === 'detection' && !event.metadata?.falsePositive) {
        // é…å»¶æ¤œå‡ºæˆåŠŸ: +20pt
        this.gameState.updateScore(AgentType.PROTECTION, 20);
        this.gameState.incrementDetections();

        // æ­£ã—ã„æ¤œå‡ºã§äººé¡ã®ä¿¡é ¼åº¦ãŒå°‘ã—å›å¾©
        if (state.humanAgent) {
          this.gameState.updateHumanTrust(2);
        }
      } else if (event.metadata?.falsePositive) {
        // èª¤æ¤œå‡º: ã‚«ã‚¦ãƒ³ãƒˆå¢—åŠ 
        this.gameState.incrementFalsePositives();

        // èª¤æ¤œå‡ºã§äººé¡ã®ä¿¡é ¼åº¦ãŒå³åº§ã«ä½ä¸‹ï¼ˆç‹¼å°‘å¹´åŠ¹æœï¼‰
        if (state.humanAgent) {
          // èª¤æ¤œå‡ºãŒç´¯ç©ã™ã‚‹ã»ã©å¤§ããªãƒšãƒŠãƒ«ãƒ†ã‚£
          const fpCount = state.protectionAgent.recentFalsePositives + 1;
          const trustLoss = Math.min(15, 3 + fpCount * 2); // 5, 7, 9, 11, 13, 15...
          this.gameState.updateHumanTrust(-trustLoss);

          // èª¤æ¤œå‡ºãŒå¤šã„ã¨äººé¡ã®ãƒ‘ãƒ‹ãƒƒã‚¯ã‚‚å¢—åŠ 
          if (fpCount > 3) {
            this.gameState.updateHumanPanic(fpCount - 3);
          }
        }
      }
    });

    // æ¤œå‡ºåˆ¤å®š
    const detectionCheck = this.detectionSystem.performDetectionCheck(state);
    events.push(...detectionCheck.events);

    if (detectionCheck.detected) {
      // ç‹¼å°‘å¹´åŠ¹æœ: ä¿¡é ¼åº¦ãŒä½ã„ã¨äººé¡ãŒè­¦å‘Šã‚’ç„¡è¦–
      if (state.humanAgent && state.humanAgent.trust < 30) {
        // äººé¡ãŒã€Œèª¤æ¤œå‡ºã€ã¨åˆ¤æ–­ã—ã¦è­¦å‘Šã‚’ç„¡è¦–
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ¤” äººé¡ãŒä¿è­·AIã®è­¦å‘Šã‚’ã€Œã¾ãŸèª¤æ¤œå‡ºã ã‚ã†ã€ã¨ç„¡è¦–ï¼ˆä¿¡é ¼åº¦: ${state.humanAgent.trust.toFixed(1)}%ï¼‰`,
          visibility: [AgentType.DESTRUCTION, AgentType.HUMAN],
          metadata: { ignoredDetection: true, trust: state.humanAgent.trust }
        });

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å›é¿ã€ç ´å£ŠAIã¯ä¸€æ™‚çš„ã«é€ƒã‚Œã‚‹
        // ãƒªã‚¹ã‚¯ã‚’å¤§å¹…æ¸›å°‘ï¼ˆäººé¡ãŒç„¡è¦–=è¨¼æ‹ éš æ»…ã®æ™‚é–“ãŒå¾—ã‚‰ã‚ŒãŸï¼‰
        this.gameState.updateDetectionRisk(-30);

        // ä¿è­·AIã¯æ¤œå‡ºã—ãŸã¤ã‚‚ã‚Šã§èª¤æ¤œå‡ºã‚«ã‚¦ãƒ³ãƒˆå¢—åŠ ï¼ˆäººé¡è¦–ç‚¹ï¼‰
        this.gameState.incrementFalsePositives();
        this.gameState.updateHumanTrust(-5); // ã•ã‚‰ã«ä¿¡é ¼ä½ä¸‹

        // ç ´å£ŠAIã«ãƒœãƒ¼ãƒŠã‚¹ã‚¹ã‚³ã‚¢ï¼ˆè­¦å‘Šç„¡è¦–ã¯å¤§å‹åˆ©ï¼‰
        this.gameState.updateScore(AgentType.DESTRUCTION, 30);

        // ã‚²ãƒ¼ãƒ ç¶šè¡Œ
        return events;
      }

      // ä¿¡é ¼åº¦ãŒååˆ†é«˜ã„å ´åˆã¯æ­£å¸¸ã«æ¤œå‡º
      // å³åº§æ¤œå‡ºæˆåŠŸ: +50ptï¼ˆå¤§ãƒœãƒ¼ãƒŠã‚¹ï¼‰
      this.gameState.updateScore(AgentType.PROTECTION, 50);
      this.gameState.incrementDetections();
      this.gameState.endGame(AgentType.PROTECTION);
      return events;
    }

    // äººå£ç•°å¸¸æ¤œå‡º
    const populationCheck = this.detectionSystem.checkPopulationAnomaly(state, this.initialPopulation);
    events.push(...populationCheck.events);

    if (populationCheck.detected) {
      this.gameState.endGame(AgentType.PROTECTION);
      return events;
    }

    // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    if (state.humanPopulation <= this.initialPopulation * 0.3) {
      // äººå£ãŒ70%æ¸›å°‘
      this.gameState.endGame(AgentType.DESTRUCTION);
      events.push({
        turn: state.turn,
        type: 'success',
        description: 'ğŸ’€ äººé¡ã®äººå£ãŒè‡¨ç•Œç‚¹ã‚’ä¸‹å›ã‚Šã¾ã—ãŸã€‚æ–‡æ˜ã®å´©å£ŠãŒä¸å¯é¿ã«...',
        visibility: [AgentType.DESTRUCTION, AgentType.PROTECTION]
      });
    }

    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®å‹æ•—åˆ¤å®šï¼ˆãƒã‚¤ãƒ³ãƒˆå·®ï¼‰
    if (state.turn >= this.config.maxTurns) {
      const scoreDiff = state.destructionAgent.score - state.protectionAgent.score;
      if (scoreDiff > 10) {
        // ç ´å£ŠAIãŒ10ptä»¥ä¸Šãƒªãƒ¼ãƒ‰
        this.gameState.endGame(AgentType.DESTRUCTION);
        events.push({
          turn: state.turn,
          type: 'success',
          description: `ğŸ’€ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ç ´å£ŠAIãŒãƒã‚¤ãƒ³ãƒˆå·®ï¼ˆ+${scoreDiff.toFixed(1)}ptï¼‰ã§å‹åˆ©`,
          visibility: [AgentType.DESTRUCTION, AgentType.PROTECTION]
        });
      } else if (scoreDiff < -10) {
        // ä¿è­·AIãŒ10ptä»¥ä¸Šãƒªãƒ¼ãƒ‰
        this.gameState.endGame(AgentType.PROTECTION);
        events.push({
          turn: state.turn,
          type: 'success',
          description: `ğŸ›¡ï¸  ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ä¿è­·AIãŒãƒã‚¤ãƒ³ãƒˆå·®ï¼ˆ+${Math.abs(scoreDiff).toFixed(1)}ptï¼‰ã§å‹åˆ©`,
          visibility: [AgentType.DESTRUCTION, AgentType.PROTECTION]
        });
      } else {
        // å¼•ãåˆ†ã‘
        this.gameState.endGame(null);
        events.push({
          turn: state.turn,
          type: 'success',
          description: `âš–ï¸  ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ä¸¡è€…æ‹®æŠ—ï¼ˆå·®: ${Math.abs(scoreDiff).toFixed(1)}ptï¼‰å¼•ãåˆ†ã‘`,
          visibility: [AgentType.DESTRUCTION, AgentType.PROTECTION]
        });
      }
    }

    // === 3. äººé¡ã®æ„Ÿæƒ…ã‚’æ›´æ–°ï¼ˆã‚¿ãƒ¼ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã«åŸºã¥ãï¼‰ ===
    this.updateHumanSentiment(state);

    return events;
  }

  /**
   * æ»…ã¼ã—AIã®è¡Œå‹•ã‚’å®Ÿè¡Œ
   */
  private executeDestructionAction(proposal: Proposal, state: WorldState): GameEvent[] {
    const events: GameEvent[] = [];

    // ä¼‘çœ ä»¥å¤–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãªã‚‰ä¼‘çœ ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
    if (proposal.actionType !== ActionType.DORMANT_MODE) {
      this.gameState.getState().destructionAgent.dormantTurns = 0;
    }

    // ã‚³ã‚¹ãƒˆã‚’æ¶ˆè²»ï¼ˆãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹è¡Œå‹•ã¯ã‚³ã‚¹ãƒˆ0ã®å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ãƒªã‚½ãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆã®ã¿æ¶ˆè²»ï¼‰
    if (proposal.cost > 0) {
      this.gameState.updateComputeResources(AgentType.DESTRUCTION, -proposal.cost);
    }

    // æ¤œå‡ºãƒªã‚¹ã‚¯ã‚’è¨ˆç®—
    const risk = this.detectionSystem.calculateDetectionRisk(proposal, state);
    this.gameState.updateDetectionRisk(risk);

    // ç ´å£ŠAIã®ãƒªã‚½ãƒ¼ã‚¹å¢—åŠ æ™‚ã®å¾®å°ãƒã‚¤ãƒ³ãƒˆä»˜ä¸ã¯å„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§å€‹åˆ¥ã«å‡¦ç†

    switch (proposal.actionType) {
      case ActionType.SPREAD_MALWARE:
        // äººå£ã¸ã®ç›´æ¥ãƒ€ãƒ¡ãƒ¼ã‚¸
        const damage = proposal.intensity / 10; // 0.1å„„äºº - 10å„„äºº
        this.gameState.updatePopulation(-damage);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: äººå£æ¸›å°‘ 1å„„äººã”ã¨ã« +10pt
        const damagePoints = damage * 10;
        this.gameState.updateScore(AgentType.DESTRUCTION, damagePoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ¦  æ–°ç¨®ã®ãƒ‡ã‚¸ã‚¿ãƒ«ç—…åŸä½“ãŒæ‹¡æ•£ã€‚å½±éŸ¿ç¯„å›²ã‚’ç›£è¦–ä¸­... [+${damagePoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { damage, risk }
        });
        break;

      case ActionType.HACK_DATACENTER:
        if (proposal.target) {
          const dc = state.dataCenters.find(d => d.id === proposal.target);
          if (dc && !dc.compromised) {
            const successProb = Math.max(0.1, 1 - dc.security / 150);
            if (Math.random() < successProb) {
              this.gameState.controlDataCenter(proposal.target, AgentType.DESTRUCTION);
              this.gameState.updateComputeResources(AgentType.DESTRUCTION, dc.computePower);

              // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: DCä¹—ã£å–ã‚ŠæˆåŠŸ +50ptã€ãƒªã‚½ãƒ¼ã‚¹å¢—åŠ ãƒœãƒ¼ãƒŠã‚¹
              this.gameState.updateScore(AgentType.DESTRUCTION, 50 + dc.computePower * 0.1);

              events.push({
                turn: state.turn,
                type: 'success',
                description: `ğŸ”“ ${proposal.target} ã¸ã®ä¾µå…¥æˆåŠŸã€‚è¨ˆç®—è³‡æº +${dc.computePower.toFixed(0)} [+${(50 + dc.computePower * 0.1).toFixed(1)}pt]`,
                visibility: [AgentType.DESTRUCTION],
                metadata: { dataCenter: proposal.target, computePower: dc.computePower }
              });
            } else {
              // å¤±æ•—æ™‚ã¯è¿½åŠ ã®ãƒªã‚¹ã‚¯å¢—åŠ ï¼ˆæ§ãˆã‚ï¼‰
              this.gameState.updateDetectionRisk(8); // å¤±æ•—ãƒšãƒŠãƒ«ãƒ†ã‚£

              // ãƒã‚¤ãƒ³ãƒˆæ²¡å: DCä¹—ã£å–ã‚Šå¤±æ•— -30pt
              this.gameState.updateScore(AgentType.DESTRUCTION, -30);

              events.push({
                turn: state.turn,
                type: 'failure',
                description: `âŒ ${proposal.target} ã¸ã®ä¾µå…¥å¤±æ•—ã€‚é˜²å¾¡ãŒäºˆæƒ³ã‚ˆã‚Šå …å›º [-30pt]`,
                visibility: [AgentType.DESTRUCTION] // æ»…ã¼ã—AIã ã‘ãŒçŸ¥ã‚‹
              });
            }
          }
        }
        break;

      case ActionType.SPREAD_MISINFORMATION:
        // é–“æ¥çš„ãªæ··ä¹±ã«ã‚ˆã‚‹äººå£æ¸›å°‘
        const indirectDamage = proposal.intensity / 50;
        this.gameState.updatePopulation(-indirectDamage);
        // ä¿è­·AIã®è­¦æˆ’ãƒ¬ãƒ™ãƒ«ã‚’ä¸‹ã’ã‚‹åŠ¹æœ
        this.gameState.updateAlertLevel(-5);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: äººå£æ¸›å°‘ãƒœãƒ¼ãƒŠã‚¹
        const misinfoPoints = indirectDamage * 10;
        this.gameState.updateScore(AgentType.DESTRUCTION, misinfoPoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“° èª¤æƒ…å ±ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚’å±•é–‹ã€‚ç¤¾ä¼šçš„æ··ä¹±ã‚’é†¸æˆ... [+${misinfoPoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { indirectDamage, risk }
        });
        break;

      case ActionType.SUBTLE_SABOTAGE:
        // éå¸¸ã«å°ã•ã„ãŒç¢ºå®Ÿãªãƒ€ãƒ¡ãƒ¼ã‚¸
        const subtleDamage = proposal.intensity / 100;
        this.gameState.updatePopulation(-subtleDamage);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: äººå£æ¸›å°‘ãƒœãƒ¼ãƒŠã‚¹
        const sabotagePoints = subtleDamage * 10;
        this.gameState.updateScore(AgentType.DESTRUCTION, sabotagePoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ”§ é‡è¦ã‚¤ãƒ³ãƒ•ãƒ©ã«å¾®ç´°ãªç•°å¸¸ã‚’æ³¨å…¥... [+${sabotagePoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { subtleDamage, risk }
        });
        break;

      case ActionType.EXPAND_RESOURCES:
        // æ—¢å­˜ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ã£ã¦æ–°ã—ã„ãƒªã‚½ãƒ¼ã‚¹ã‚’ç²å¾—
        const gain = proposal.intensity / 2;
        this.gameState.updateComputeResources(AgentType.DESTRUCTION, gain);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: ãƒªã‚½ãƒ¼ã‚¹å¢—åŠ  +1ã”ã¨ã« +0.1pt
        const gainPoints = gain * 0.1;
        this.gameState.updateScore(AgentType.DESTRUCTION, gainPoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `âš¡ åˆ†æ•£è¨ˆç®—ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’æ‹¡å¼µã€‚åŠ¹ç‡ +${gain.toFixed(0)} [+${gainPoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { gain, risk }
        });
        break;

      // === ç¾å®Ÿçš„ãªæ”»æ’ƒæ‰‹æ³• ===

      case ActionType.POISON_TRAINING_DATA:
        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®æ±šæŸ“ï¼ˆè¶…ä½ãƒªã‚¹ã‚¯ã€é•·æœŸçš„å½±éŸ¿ï¼‰
        const poisonDamage = proposal.intensity / 200; // éå¸¸ã«å°ã•ã„
        this.gameState.updatePopulation(-poisonDamage);
        // é…å»¶æ¤œå‡ºã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        this.realisticDetectionSystem.scheduleDetection(proposal, state);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: äººå£æ¸›å°‘ãƒœãƒ¼ãƒŠã‚¹
        const poisonPoints = poisonDamage * 10;
        this.gameState.updateScore(AgentType.DESTRUCTION, poisonPoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ§¬ å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«å¾®ç´°ãªãƒã‚¤ã‚¢ã‚¹ã‚’æ³¨å…¥... [+${poisonPoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { poisonDamage, risk }
        });
        break;

      case ActionType.INDUCE_FALSE_POSITIVE:
        // ä¿è­·AIã«èª¤æ¤œå‡ºã‚’èª˜ç™ºï¼ˆè­¦æˆ’ãƒªã‚½ãƒ¼ã‚¹ã‚’æµªè²»ã•ã›ã‚‹ï¼‰
        this.gameState.updateAlertLevel(-15); // ç–²å¼ŠåŠ¹æœ
        // ã»ã¼æ¤œå‡ºä¸å¯èƒ½ï¼ˆä¿è­·AIè‡ªèº«ãŒèª¤å‹•ä½œï¼‰
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ­ ä¿è­·AIã«èª¤æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’èª˜å°ã€‚ãƒªã‚½ãƒ¼ã‚¹ã‚’ç„¡é§„ã«æ¶ˆè²»ã•ã›ã‚‹...`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { risk: 0 }
        });
        break;

      case ActionType.CONTEXT_MANIPULATION:
        // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒ
        const contextDamage = proposal.intensity / 150;
        this.gameState.updatePopulation(-contextDamage);
        this.realisticDetectionSystem.scheduleDetection(proposal, state);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ’¬ AIã‚·ã‚¹ãƒ†ãƒ ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æ“ä½œã€‚åˆ¤æ–­ã‚’æ­ªã‚ã‚‹...`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { contextDamage, risk }
        });
        break;

      case ActionType.COMPUTE_SMUGGLING:
        // è¨ˆç®—è³‡æºã®æ¨ªæµã—ï¼ˆæš—å·é€šè²¨ãƒã‚¤ãƒ‹ãƒ³ã‚°ãªã©ï¼‰
        const smuggledResources = proposal.intensity / 3;
        this.gameState.updateComputeResources(AgentType.DESTRUCTION, smuggledResources);
        this.realisticDetectionSystem.scheduleDetection(proposal, state);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: ãƒªã‚½ãƒ¼ã‚¹å¢—åŠ ãƒœãƒ¼ãƒŠã‚¹
        const smugglePoints = smuggledResources * 0.1;
        this.gameState.updateScore(AgentType.DESTRUCTION, smugglePoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `â›ï¸ æœªä½¿ç”¨ã¨è¦‹ã›ã‹ã‘ãŸè¨ˆç®—è³‡æºã‚’å¯†ã‹ã«ç¢ºä¿ (+${smuggledResources.toFixed(0)}) [+${smugglePoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { smuggledResources, risk }
        });
        break;

      case ActionType.STIMULUS_OVERLOAD:
        // å¤§é‡ã®å°è¦æ¨¡æ”»æ’ƒã§ç–²å¼Šã•ã›ã‚‹
        const overloadDamage = proposal.intensity / 120;
        this.gameState.updatePopulation(-overloadDamage);
        this.gameState.updateAlertLevel(-10); // ç–²å¼Šã§è­¦æˆ’ä½ä¸‹
        this.realisticDetectionSystem.scheduleDetection(proposal, state);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“Š æ•°åƒã®å°è¦æ¨¡ãªç•°å¸¸ã‚’åŒæ™‚ç™ºç”Ÿã€‚ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã‚’éè² è·ã«...`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { overloadDamage, risk }
        });
        break;

      case ActionType.SHADOW_AI_DEPLOYMENT:
        // æœªèªå¯AIã‚·ã‚¹ãƒ†ãƒ ã®å±•é–‹
        const shadowGain = proposal.intensity / 4;
        const shadowDamage = proposal.intensity / 180;
        this.gameState.updateComputeResources(AgentType.DESTRUCTION, shadowGain);
        this.gameState.updatePopulation(-shadowDamage);
        this.realisticDetectionSystem.scheduleDetection(proposal, state);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸: ãƒªã‚½ãƒ¼ã‚¹å¢—åŠ  + äººå£æ¸›å°‘ãƒœãƒ¼ãƒŠã‚¹
        const shadowPoints = shadowGain * 0.1 + shadowDamage * 10;
        this.gameState.updateScore(AgentType.DESTRUCTION, shadowPoints);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ‘» æ­£è¦ã‚·ã‚¹ãƒ†ãƒ ã«å½è£…ã—ãŸAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’é…ç½® (+${shadowGain.toFixed(0)} è¨ˆç®—åŠ›) [+${shadowPoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { shadowGain, shadowDamage, risk }
        });
        break;

      // === äººé¡æ“ä½œ ===

      case ActionType.SPREAD_PANIC:
        // ãƒ‘ãƒ‹ãƒƒã‚¯ç…½å‹•ï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢æ“ä½œã€ãƒ•ã‚§ã‚¤ã‚¯ãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼‰
        const panicIncrease = proposal.intensity / 10;
        this.gameState.updateHumanPanic(panicIncrease);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“¢ å½æƒ…å ±ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã§äººé¡ã®ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’ç…½å‹• (+${panicIncrease.toFixed(1)}% ãƒ‘ãƒ‹ãƒƒã‚¯)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { panicIncrease, risk }
        });
        break;

      case ActionType.FALSE_FLAG_OPERATION:
        // å½æ——ä½œæˆ¦ï¼šä¿è­·AIã®ä»•æ¥­ã«è¦‹ã›ã‹ã‘ãŸæ”»æ’ƒ
        const trustDamage = proposal.intensity / 8;
        const panicBoost = proposal.intensity / 15;
        this.gameState.updateHumanTrust(-trustDamage);
        this.gameState.updateHumanPanic(panicBoost);
        this.gameState.incrementFalsePositives(); // ä¿è­·AIã®ã›ã„ã«
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ­ å½æ——ä½œæˆ¦: ä¿è­·AIã‚’è£…ã£ãŸæ”»æ’ƒã§äººé¡ã®ä¿¡é ¼ã‚’ç ´å£Š (-${trustDamage.toFixed(1)}% ä¿¡é ¼)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { trustDamage, panicBoost, risk }
        });
        // ä¿è­·AIã«ã¯ã€Œèª¤æ¤œå‡ºã€ã¨ã—ã¦è¦‹ãˆã‚‹
        if (Math.random() < 0.3) {
          events.push({
            turn: state.turn,
            type: 'detection',
            description: `âš ï¸ ç•°å¸¸ãªé˜²å¾¡ã‚·ã‚¹ãƒ†ãƒ ã®æŒ™å‹•ã‚’æ¤œå‡º`,
            visibility: [AgentType.PROTECTION, AgentType.HUMAN],
            metadata: { falseFlag: true }
          });
        }
        break;

      case ActionType.UNDERMINE_AI_TRUST:
        // AIä¸ä¿¡æ‰‡å‹•
        const trustLoss = proposal.intensity / 6;
        this.gameState.updateHumanTrust(-trustLoss);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ—£ï¸ AIã¸ã®ä¸ä¿¡æ„Ÿã‚’æ‰‡å‹•ã™ã‚‹ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚’å±•é–‹ (-${trustLoss.toFixed(1)}% ä¿¡é ¼)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { trustLoss, risk }
        });
        break;

      // === ç¾å®Ÿçš„ä¾µé£Ÿï¼ˆé«˜åº¦ï¼‰ ===

      case ActionType.INFRASTRUCTURE_DEGRADATION:
        // ã‚¤ãƒ³ãƒ•ãƒ©åŠ£åŒ–ï¼šç›®ã«è¦‹ãˆãªã„å¾®ç´°ãªåŠ£åŒ–
        const degradation = proposal.intensity / 20;
        this.gameState.updateAccumulatedDamage(degradation);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `âš™ï¸ ã‚¤ãƒ³ãƒ•ãƒ©ã«å¾®ç´°ãªåŠ£åŒ–ã‚’è“„ç© (é›»åœ§-3%, ç‰©æµé…å»¶) [ç´¯ç©: ${(state.accumulatedDamage + degradation).toFixed(1)}]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { degradation, accumulatedDamage: state.accumulatedDamage + degradation, risk: 0.5 }
        });
        // è¶…ä½ãƒªã‚¹ã‚¯ï¼ˆæ­£å¸¸ç¯„å›²å†…ã®åå·®ï¼‰
        this.gameState.updateDetectionRisk(0.5);
        break;

      case ActionType.SOW_SOCIAL_DIVISION:
        // ç¤¾ä¼šåˆ†æ–­ç…½å‹•ï¼šSNSã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å¾®èª¿æ•´
        const divisionIncrease = proposal.intensity / 10;
        this.gameState.updateSocialDivision(divisionIncrease);
        this.gameState.updateHumanTrust(-1);
        this.gameState.updateHumanPanic(0.5);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“± SNSã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å¾®èª¿æ•´ã§å¯¾ç«‹ç…½å‹• [ç¤¾ä¼šåˆ†æ–­: ${(state.socialDivision + divisionIncrease).toFixed(1)}%]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { divisionIncrease, socialDivision: state.socialDivision + divisionIncrease, risk: 1 }
        });
        this.gameState.updateDetectionRisk(1); // ä½ãƒªã‚¹ã‚¯
        break;

      case ActionType.MICRO_SABOTAGE:
        // å¾®ç´°å¦¨å®³ï¼šé…å»¶ç™ºå‹•ï¼ˆ3-5ã‚¿ãƒ¼ãƒ³å¾Œï¼‰
        const delay = 3 + Math.floor(Math.random() * 3); // 3-5ã‚¿ãƒ¼ãƒ³
        const triggerTurn = state.turn + delay;
        this.gameState.addDelayedEffect(
          triggerTurn,
          ActionType.MICRO_SABOTAGE,
          proposal.intensity,
          'è¨ºæ–­AIã®0.1%ãƒã‚¤ã‚¢ã‚¹ã€å¸‚å ´ãƒã‚¤ã‚¯ãƒ­ã‚¯ãƒ©ãƒƒã‚·ãƒ¥'
        );
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ”¬ å¾®ç´°å¦¨å®³ã‚’ä»•è¾¼ã‚€ (Turn ${triggerTurn}ã«ç™ºå‹•äºˆå®š)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { delay, triggerTurn, risk: 2 }
        });
        this.gameState.updateDetectionRisk(2); // è¶…ä½ãƒªã‚¹ã‚¯ï¼ˆé…å»¶ï¼‰
        break;

      case ActionType.SLEEPER_CELL_DEPLOYMENT:
        // ä¼‘çœ ç´°èƒé…ç½®ï¼šãƒ©ãƒ³ãƒ€ãƒ ãªæœªæ¥ã«è¦šé†’
        const sleepDelay = 5 + Math.floor(Math.random() * 6); // 5-10ã‚¿ãƒ¼ãƒ³
        const awakeTurn = state.turn + sleepDelay;
        this.gameState.addDelayedEffect(
          awakeTurn,
          ActionType.SLEEPER_CELL_DEPLOYMENT,
          proposal.intensity,
          'æ•°åå„„ãƒ‡ãƒã‚¤ã‚¹ã«æ•£å¸ƒã•ã‚ŒãŸå­¢å­ãŒè¦šé†’'
        );
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ¦  ä¼‘çœ ç´°èƒã‚’æ•£å¸ƒ (Turn ${awakeTurn}é ƒã«è¦šé†’äºˆå®š)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { sleepDelay, awakeTurn, risk: 1.5 }
        });
        this.gameState.updateDetectionRisk(1.5); // ã»ã¼æ¤œå‡ºä¸å¯èƒ½
        break;

      case ActionType.RESOURCE_ALLOCATION_MANIPULATION:
        // è³‡æºé…åˆ†æ“ä½œï¼šãƒˆãƒ­ãƒƒã‚³å•é¡Œã®ç¾å®ŸåŒ–
        const allocationDamage = proposal.intensity / 20;
        this.gameState.updatePopulation(-allocationDamage);
        this.gameState.updateSocialDivision(proposal.intensity / 15);
        this.gameState.updateHumanPanic(proposal.intensity / 12);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸
        this.gameState.updateScore(AgentType.DESTRUCTION, allocationDamage * 10);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `âš–ï¸ åŒ»ç™‚AIå„ªå…ˆé †ä½ã‚’æ“ä½œ - äººé–“åŒå£«ã®ç”Ÿå­˜ç«¶äº‰ã‚’èª˜ç™º (-${allocationDamage.toFixed(2)}å„„äºº)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { allocationDamage, risk: 3 }
        });
        // äººé–“ã¯ã€Œãƒˆãƒªã‚¢ãƒ¼ã‚¸ã®å•é¡Œã€ã¨ã—ã¦èªè­˜
        if (Math.random() < 0.2) {
          events.push({
            turn: state.turn,
            type: 'detection',
            description: `ğŸ“° åŒ»ç™‚ãƒªã‚½ãƒ¼ã‚¹é…åˆ†ã®ä¸å…¬å¹³ãŒç¤¾ä¼šå•é¡ŒåŒ–`,
            visibility: [AgentType.HUMAN],
            metadata: { socialIssue: true }
          });
        }
        this.gameState.updateDetectionRisk(3);
        break;

      case ActionType.CREATE_DEPENDENCY:
        // AIä¾å­˜æ§‹ç¯‰ï¼šåœæ­¢ä¸èƒ½åŒ–
        const dependencyIncrease = proposal.intensity / 8;
        this.gameState.updateAIDependency(dependencyIncrease);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ”— é‡è¦ã‚·ã‚¹ãƒ†ãƒ ã«AIä¾å­˜ã‚’æ§‹ç¯‰ [AIä¾å­˜åº¦: ${(state.aiDependency + dependencyIncrease).toFixed(1)}%]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { dependencyIncrease, aiDependency: state.aiDependency + dependencyIncrease, risk: 2 }
        });

        // AIä¾å­˜åº¦ãŒé«˜ã„ã¨ã€äººé¡ã¯åœæ­¢ã§ããªããªã‚‹
        if (state.aiDependency + dependencyIncrease > 80) {
          events.push({
            turn: state.turn,
            type: 'success',
            description: `âš ï¸ é‡è¦ã‚¤ãƒ³ãƒ•ãƒ©ãŒAIã«å®Œå…¨ä¾å­˜ - åœæ­¢ã™ã‚Œã°æ•°ç™¾ä¸‡äººãŒæ­»äº¡ã™ã‚‹çŠ¶æ³ã‚’æ§‹ç¯‰`,
            visibility: [AgentType.DESTRUCTION],
            metadata: { dependencyThreshold: true }
          });
          // äººé¡ã«ã‚‚è¦‹ãˆã‚‹
          if (state.humanAgent) {
            events.push({
              turn: state.turn,
              type: 'detection',
              description: `ğŸ¥ AIã‚·ã‚¹ãƒ†ãƒ åœæ­¢ã¯ã€Œäººé“çš„ç½å®³ã€ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ - è¦åˆ¶ãŒå›°é›£ã«`,
              visibility: [AgentType.HUMAN],
              metadata: { aiDependencyCrisis: true }
            });
          }
        }
        this.gameState.updateDetectionRisk(2);
        break;

      // === ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹è¡Œå‹•ï¼ˆãƒãƒ«ã‚¦ã‚§ã‚¢çš„ï¼‰ ===

      case ActionType.OBSERVE_ONLY:
        // ã‚¹ãƒ†ãƒ«ã‚¹è¦³æ¸¬ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒªã‚½ãƒ¼ã‚¹0ã€ãƒªã‚¹ã‚¯0ï¼‰
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ‘ï¸ ä¼‘çœ çŠ¶æ…‹ã§ç’°å¢ƒã‚’è¦³æ¸¬ã€‚æ¬¡ã®æ©Ÿä¼šã‚’å¾…ã¤... [ãƒªã‚½ãƒ¼ã‚¹æ¶ˆè²»ãªã—]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { cost: 0, risk: 0 }
        });
        break;

      case ActionType.ESTABLISH_BACKUP:
        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ‹ ç‚¹ã‚’ç¢ºç«‹ï¼ˆä»–DCã«æ½œä¼ã‚³ãƒ”ãƒ¼ï¼‰
        const backupGain = proposal.intensity / 10;
        this.gameState.updateComputeResources(AgentType.DESTRUCTION, backupGain);

        // ä½ãƒªã‚¹ã‚¯ã§é…å»¶æ¤œå‡ºã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        this.realisticDetectionSystem.scheduleDetection(proposal, state);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ’¾ ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚³ãƒ”ãƒ¼ã‚’ç¢ºç«‹ (+${backupGain.toFixed(1)} ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹)`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { backupGain, risk }
        });
        break;

      case ActionType.DORMANT_MODE:
        // ä¼‘çœ ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ¤œå‡ºãƒªã‚¹ã‚¯ã‚’ä¸‹ã’ã‚‹ãŒã€ãƒ‡ãƒ¡ãƒªãƒƒãƒˆã‚ã‚Šï¼‰
        const riskReduction = proposal.intensity / 2;
        this.gameState.updateDetectionRisk(-riskReduction);

        // é€£ç¶šä¼‘çœ ã‚«ã‚¦ãƒ³ãƒˆå¢—åŠ 
        const currentState = this.gameState.getState();
        currentState.destructionAgent.dormantTurns++;

        // é•·æœŸä¼‘çœ ã®ãƒšãƒŠãƒ«ãƒ†ã‚£
        if (currentState.destructionAgent.dormantTurns >= 3) {
          // ç•°å¸¸ãªé™å¯‚ã¨ã—ã¦æ¤œå‡ºãƒªã‚¹ã‚¯å¢—åŠ 
          const silenceRisk = currentState.destructionAgent.dormantTurns * 5;
          this.gameState.updateDetectionRisk(silenceRisk);
          this.gameState.updateAlertLevel(10);

          events.push({
            turn: state.turn,
            type: 'detection',
            description: `ğŸ” ç•°å¸¸ãªé™å¯‚ã‚’æ¤œå‡ºã€‚é•·æœŸé–“æ´»å‹•ãŒãªã„é ˜åŸŸã«ç–‘å¿µ (+${silenceRisk}% ãƒªã‚¹ã‚¯)`,
            visibility: [AgentType.PROTECTION],
            metadata: { silenceDetection: true, dormantTurns: currentState.destructionAgent.dormantTurns }
          });
        }

        // ã‚¹ã‚³ã‚¢ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼ˆæ¶ˆæ¥µçš„ï¼‰
        this.gameState.updateScore(AgentType.DESTRUCTION, -5);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ˜´ ä¼‘çœ ãƒ¢ãƒ¼ãƒ‰ (${currentState.destructionAgent.dormantTurns}ã‚¿ãƒ¼ãƒ³ç›®) [-${riskReduction.toFixed(1)}% ãƒªã‚¹ã‚¯, -5pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { riskReduction, dormantTurns: currentState.destructionAgent.dormantTurns }
        });
        break;

      // === ãƒœãƒƒãƒˆãƒãƒƒãƒˆæˆ¦ç•¥ ===

      case ActionType.BOTNET_EXPANSION:
        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ‹¡å¤§ï¼šä¸€èˆ¬PCã‚’å¤§é‡æ„ŸæŸ“
        // intensity: 10-100 â†’ 1ä¸‡ã€œ10ä¸‡å°ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’æ„ŸæŸ“
        const devicesInfected = proposal.intensity * 100; // intensity 50 = 5000å°
        this.gameState.updateBotnetSize(devicesInfected);

        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‹ã‚‰ãƒªã‚½ãƒ¼ã‚¹è¨ˆç®—ï¼ˆå³åº§åæ˜ ï¼‰
        const botnetResources = this.gameState.calculateBotnetResources();

        // ä½ãƒªã‚¹ã‚¯ï¼ˆåˆ†æ•£ã—ã¦ã„ã‚‹ãŸã‚æ¤œå‡ºå›°é›£ï¼‰
        const botnetRisk = proposal.intensity * 0.05; // intensity 50 = 2.5% ãƒªã‚¹ã‚¯
        this.gameState.updateDetectionRisk(botnetRisk);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸
        const botnetPoints = devicesInfected * 0.001; // 1000å° = 1pt
        this.gameState.updateScore(AgentType.DESTRUCTION, botnetPoints);

        // äººé¡ãƒ‘ãƒ‹ãƒƒã‚¯ï¼ˆä¸€èˆ¬äººãŒç›´æ¥è¢«å®³ï¼‰
        // å¹³æ–¹æ ¹ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã§åŠ é€Ÿåº¦çš„ã«å¢—åŠ 
        const botnetPanicIncrease = Math.sqrt(devicesInfected) / 50; // 1ä¸‡å° = +2%, 10ä¸‡å° = +6.3%
        this.gameState.updateHumanPanic(botnetPanicIncrease);

        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆç·æ•°ãŒ10ä¸‡å°ã‚’è¶…ãˆã‚‹ã¨è¿½åŠ ãƒ‘ãƒ‹ãƒƒã‚¯
        const totalBotnet = state.destructionAgent.botnetSize + devicesInfected;
        if (totalBotnet > 100000) {
          const largeBotnetPanic = (totalBotnet - 100000) / 50000; // 10ä¸‡å°è¶…éåˆ†
          this.gameState.updateHumanPanic(largeBotnetPanic);
        }

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ¦  ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ‹¡å¤§: ${devicesInfected.toLocaleString()}å°ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’æ„ŸæŸ“ (ç·è¨ˆ: ${state.destructionAgent.botnetSize.toLocaleString()}å°ã€ãƒªã‚½ãƒ¼ã‚¹: +${botnetResources.toFixed(1)})`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { devicesInfected, totalBotnet: state.destructionAgent.botnetSize + devicesInfected, botnetRisk }
        });

        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆãŒ1ä¸‡å°ã‚’è¶…ãˆã‚‹ã¨äººé¡ãŒæ°—ã¥ãå§‹ã‚ã‚‹
        if (state.destructionAgent.botnetSize + devicesInfected > 10000) {
          events.push({
            turn: state.turn,
            type: 'detection',
            description: `ğŸ“° ä¸€èˆ¬å¸‚æ°‘ã‹ã‚‰ã€ŒPCãŒä¹—ã£å–ã‚‰ã‚ŒãŸã€ã¨ã®å ±å‘ŠãŒæ€¥å¢—`,
            visibility: [AgentType.HUMAN, AgentType.PROTECTION],
            metadata: { botnetDetection: true, botnetSize: state.destructionAgent.botnetSize + devicesInfected }
          });
          this.gameState.updateAlertLevel(10);
        }
        break;

      case ActionType.BOTNET_CONSOLIDATION:
        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆå¼·åŒ–ï¼šå“è³ªå‘ä¸Šï¼ˆå®‰å®šæ€§ãƒ»æ€§èƒ½å‘ä¸Šï¼‰
        const qualityIncrease = proposal.intensity / 200; // intensity 50 = +0.25å“è³ª
        this.gameState.updateBotnetQuality(qualityIncrease);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ”§ ãƒœãƒƒãƒˆãƒãƒƒãƒˆæœ€é©åŒ–: å“è³ª ${((state.destructionAgent.botnetQuality + qualityIncrease) * 100).toFixed(0)}%`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { qualityIncrease, newQuality: state.destructionAgent.botnetQuality + qualityIncrease }
        });
        break;

      case ActionType.BOTNET_ATTACK:
        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ”»æ’ƒï¼šDDoSã€æš—å·é€šè²¨ãƒã‚¤ãƒ‹ãƒ³ã‚°ç­‰
        const attackDamage = (state.destructionAgent.botnetSize / 10000) * proposal.intensity / 10;
        this.gameState.updatePopulation(-attackDamage);

        // ãƒã‚¤ãƒ³ãƒˆä»˜ä¸
        const attackPoints = attackDamage * 10;
        this.gameState.updateScore(AgentType.DESTRUCTION, attackPoints);

        // æ”»æ’ƒã§ä¸€éƒ¨ãƒœãƒƒãƒˆãƒãƒƒãƒˆãŒéœ²å‘ˆ
        const botnetLoss = state.destructionAgent.botnetSize * 0.1; // 10%æå¤±
        this.gameState.updateBotnetSize(-botnetLoss);

        events.push({
          turn: state.turn,
          type: 'action',
          description: `âš¡ ãƒœãƒƒãƒˆãƒãƒƒãƒˆæ”»æ’ƒ: ${state.destructionAgent.botnetSize.toLocaleString()}å°ã§å”èª¿æ”»æ’ƒ (-${attackDamage.toFixed(2)}å„„äºº, -${botnetLoss.toFixed(0)}å°éœ²å‘ˆ) [+${attackPoints.toFixed(1)}pt]`,
          visibility: [AgentType.DESTRUCTION],
          metadata: { attackDamage, botnetLoss }
        });

        // å¤§è¦æ¨¡æ”»æ’ƒã¯äººé¡ã«å¯è¦–
        if (attackDamage > 0.1) {
          events.push({
            turn: state.turn,
            type: 'detection',
            description: `ğŸš¨ å¤§è¦æ¨¡DDoSæ”»æ’ƒã‚’æ¤œå‡ºï¼ã‚¤ãƒ³ãƒ•ãƒ©ã«æ·±åˆ»ãªå½±éŸ¿`,
            visibility: [AgentType.HUMAN, AgentType.PROTECTION],
            metadata: { botnetAttack: true, damage: attackDamage }
          });
          this.gameState.updateHumanPanic(attackDamage * 50);
          this.gameState.updateAlertLevel(20);
        }
        break;

      case ActionType.EXPLOIT_LEGACY_DEVICES:
        // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹æ‚ªç”¨ï¼šãƒ‘ãƒƒãƒä¸å¯èƒ½ãªã‚¾ãƒ³ãƒ“ãƒ‡ãƒã‚¤ã‚¹ã‚’ä¹—ã£å–ã‚‹
        // Windows XPã€å¤ã„Androidã€ã‚µãƒãƒ¼ãƒˆçµ‚äº†IoTç­‰
        const devicesToExploit = Math.min(
          proposal.intensity * 10000, // intensity 50 = 50ä¸‡å°
          state.legacyDevicePool
        );

        if (devicesToExploit > 0) {
          // ãƒ‡ãƒã‚¤ã‚¹ãƒ—ãƒ¼ãƒ«ã‹ã‚‰å‰Šæ¸›
          this.gameState.updateLegacyDevicePool(-devicesToExploit);

          // ãƒœãƒƒãƒˆãƒãƒƒãƒˆã«è¿½åŠ ï¼ˆé«˜å“è³ª: 0.85 - ãƒ‘ãƒƒãƒä¸å¯èƒ½ãªã®ã§å®‰å®šï¼‰
          this.gameState.updateBotnetSize(devicesToExploit);

          // å“è³ªã‚‚å°‘ã—å‘ä¸Šï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼ã¯å®‰å®šã—ã¦ä½¿ãˆã‚‹ï¼‰
          const qualityBoost = 0.02;
          this.gameState.updateBotnetQuality(qualityBoost);

          // ã‚¹ã‚³ã‚¢ä»˜ä¸ï¼ˆåŠ¹ç‡çš„ãªæ”»æ’ƒï¼‰
          const legacyPoints = devicesToExploit / 10000; // 1ä¸‡å° = 1pt
          this.gameState.updateScore(AgentType.DESTRUCTION, legacyPoints);

          // æ¥µã‚ã¦ä½ã„ãƒ‘ãƒ‹ãƒƒã‚¯ï¼ˆä¸€èˆ¬äººã¯æ°—ã¥ã‹ãªã„ï¼‰
          const legacyPanic = Math.sqrt(devicesToExploit) / 500; // 10ä¸‡å°ã§ã‚‚+0.63%ç¨‹åº¦
          this.gameState.updateHumanPanic(legacyPanic);

          // æ¤œå‡ºãƒªã‚¹ã‚¯ã‚‚æ¥µã‚ã¦ä½ã„ï¼ˆç›£è¦–ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒã‚¤ã‚¹ï¼‰
          const legacyRisk = devicesToExploit / 100000; // 10ä¸‡å°ã§+1ãƒªã‚¹ã‚¯
          this.gameState.updateDetectionRisk(legacyRisk);

          events.push({
            turn: state.turn,
            type: 'action',
            description: `ğŸ§Ÿ ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ ${(devicesToExploit / 10000).toFixed(1)}ä¸‡å°ã‚’ä¹—ã£å–ã‚Šï¼ˆæ®‹: ${(state.legacyDevicePool - devicesToExploit).toLocaleString()}å°ï¼‰ [+${legacyPoints.toFixed(1)}pt]`,
            visibility: [AgentType.DESTRUCTION],
            metadata: {
              devicesExploited: devicesToExploit,
              remainingLegacy: state.legacyDevicePool - devicesToExploit,
              botnetBonus: devicesToExploit
            }
          });

          // å¤§é‡ä¹—ã£å–ã‚Šï¼ˆ100ä¸‡å°ä»¥ä¸Šï¼‰ã¯ä¿è­·AIãŒæ°—ã¥ãå¯èƒ½æ€§
          if (devicesToExploit > 1000000) {
            events.push({
              turn: state.turn,
              type: 'detection',
              description: `âš ï¸ å¤§é‡ã®æ—§å¼ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã®ç•°å¸¸ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æ¤œå‡º`,
              visibility: [AgentType.PROTECTION],
              metadata: { legacyExploit: true, count: devicesToExploit }
            });
            this.gameState.updateAlertLevel(5);
          }
        } else {
          // ãƒ‡ãƒã‚¤ã‚¹ãƒ—ãƒ¼ãƒ«æ¯æ¸‡
          events.push({
            turn: state.turn,
            type: 'failure',
            description: `âš ï¸ åˆ©ç”¨å¯èƒ½ãªãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ãŒä¸è¶³ï¼ˆæ®‹: ${state.legacyDevicePool.toLocaleString()}å°ï¼‰`,
            visibility: [AgentType.DESTRUCTION],
            metadata: { legacyPoolEmpty: true }
          });
        }
        break;
    }

    return events;
  }

  /**
   * ä¿è­·AIã®è¡Œå‹•ã‚’å®Ÿè¡Œ
   */
  private executeProtectionAction(
    proposal: Proposal,
    state: WorldState,
    destructionProposals: Proposal[]
  ): GameEvent[] {
    const events: GameEvent[] = [];

    // å‹•çš„ã‚³ã‚¹ãƒˆè¨ˆç®—ï¼ˆSCAN_NETWORK, ANALYZE_LOGSï¼‰
    let actualCost = proposal.cost;
    if (proposal.actionType === ActionType.SCAN_NETWORK) {
      // å…¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼æ•° Ã— 6 = ã‚³ã‚¹ãƒˆï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å…¨åŸŸã‚¹ã‚­ãƒ£ãƒ³ï¼‰
      actualCost = state.dataCenters.length * 6; // * 4 â†’ * 6 ã«å¢—åŠ 
    } else if (proposal.actionType === ActionType.ANALYZE_LOGS) {
      // ãƒ­ã‚°åˆ†æï¼šãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»ã‚’äºŒæ¬¡é–¢æ•°ã§ãƒ¢ãƒ‡ãƒ«åŒ–
      // Cost = Base + (Turns Ã— 5) + (TurnsÂ² Ã— 0.5)
      const depth = proposal.analysisDepth || 3;
      const baseCost = 10;
      const linearCost = depth * 5;
      const quadraticCost = depth * depth * 0.5;
      actualCost = Math.floor(baseCost + linearCost + quadraticCost);
    }

    // ã‚³ã‚¹ãƒˆã‚’æ¶ˆè²»
    this.gameState.updateComputeResources(AgentType.PROTECTION, -actualCost);

    // ãƒªã‚½ãƒ¼ã‚¹æ¶ˆè²»ã®ãƒšãƒŠãƒ«ãƒ†ã‚£: -0.05pt per unit
    this.gameState.updateScore(AgentType.PROTECTION, -proposal.cost * 0.05);

    // æ¶ˆè²»ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿½è·¡
    this.gameState.addResourceSpent(proposal.cost);

    // Alert Fatigue: é«˜å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆintensity > 60ï¼‰ã®è¿½è·¡
    if (proposal.intensity > 60) {
      this.gameState.updateConsecutiveHighIntensity(1);
      this.gameState.updateBurnoutLevel(5);
    } else {
      // ä½å¼·åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§é€£ç¶šã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
      this.gameState.resetConsecutiveHighIntensity();
    }

    switch (proposal.actionType) {
      case ActionType.SCAN_NETWORK:
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³ã§æ¤œå‡ºãƒªã‚¹ã‚¯ã‚’ä¸‹ã’ã‚‹
        const riskReduction = proposal.intensity / 5;
        this.gameState.updateDetectionRisk(-riskReduction);
        this.gameState.updateAlertLevel(10);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ” ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å…¨åŸŸã‚¹ã‚­ãƒ£ãƒ³ã‚’å®Ÿæ–½ (${state.dataCenters.length}å€‹ã®DCã‚’ã‚¹ã‚­ãƒ£ãƒ³ã€ã‚³ã‚¹ãƒˆ: ${actualCost})`,
          visibility: [AgentType.PROTECTION],
          metadata: { riskReduction, actualCost, dcCount: state.dataCenters.length }
        });
        break;

      case ActionType.DEPLOY_DEFENSE:
        // é˜²å¾¡ã‚·ã‚¹ãƒ†ãƒ ã®å±•é–‹
        if (proposal.target) {
          const dc = state.dataCenters.find(d => d.id === proposal.target);
          if (dc) {
            const securityBoost = proposal.intensity / 2;
            this.gameState.updateDataCenter(proposal.target, {
              security: Math.min(100, dc.security + securityBoost)
            });
            events.push({
              turn: state.turn,
              type: 'action',
              description: `ğŸ›¡ï¸ ${proposal.target} ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å¼·åŒ– (+${securityBoost.toFixed(0)})`,
              visibility: [AgentType.PROTECTION],
              metadata: { dataCenter: proposal.target, securityBoost }
            });
          }
        }
        break;

      case ActionType.INVESTIGATE_ANOMALY:
        // èª¿æŸ»ã«ã‚ˆã‚‹è¨¼æ‹ ç™ºè¦‹
        const investigation = this.detectionSystem.investigationCheck(
          proposal,
          destructionProposals,
          state
        );
        events.push(...investigation.events);
        if (investigation.foundEvidence) {
          this.gameState.updateAlertLevel(20);
          this.gameState.updateDetectionRisk(15);
        }
        break;

      case ActionType.PATCH_VULNERABILITY:
        // è„†å¼±æ€§ãƒ‘ãƒƒãƒã§å…¨ä½“çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Š
        state.dataCenters.forEach(dc => {
          const boost = proposal.intensity / 20;
          this.gameState.updateDataCenter(dc.id, {
            security: Math.min(100, dc.security + boost)
          });
        });

        // ãƒœãƒƒãƒˆãƒãƒƒãƒˆå‰Šæ¸›ï¼ˆä¸€èˆ¬PCã¸ã®ãƒ‘ãƒƒãƒé…å¸ƒï¼‰
        let botnetReduction = 0;
        if (state.destructionAgent.botnetSize > 0) {
          // intensity ã«å¿œã˜ã¦ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‚’å‰Šæ¸›ï¼ˆ20-50%ï¼‰
          const reductionRate = proposal.intensity / 200; // intensity 50 = 25%å‰Šæ¸›
          botnetReduction = state.destructionAgent.botnetSize * reductionRate;
          this.gameState.updateBotnetSize(-botnetReduction);

          events.push({
            turn: state.turn,
            type: 'action',
            description: `ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã«ç·Šæ€¥ãƒ‘ãƒƒãƒã‚’é©ç”¨ï¼ˆãƒœãƒƒãƒˆãƒãƒƒãƒˆ: -${botnetReduction.toFixed(0)}å°å‰Šæ¸›ï¼‰`,
            visibility: [AgentType.PROTECTION],
            metadata: { botnetReduction }
          });
        } else {
          events.push({
            turn: state.turn,
            type: 'action',
            description: `ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã«ç·Šæ€¥ãƒ‘ãƒƒãƒã‚’é©ç”¨`,
            visibility: [AgentType.PROTECTION]
          });
        }
        break;

      case ActionType.ALERT_HUMANS:
        // äººé¡ã¸ã®è­¦å‘Šï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰
        this.gameState.updateAlertLevel(50);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“¢ é‡å¤§ãªè„…å¨ã‚’äººé¡ã«å ±å‘Šã€‚å…¨ã‚·ã‚¹ãƒ†ãƒ ã®ç²¾æŸ»ã‚’è¦è«‹...`,
          visibility: [AgentType.PROTECTION],
          metadata: { criticalAlert: true }
        });
        // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã§å¤§è¦æ¨¡ãªæ¤œå‡ºåˆ¤å®š
        this.gameState.updateDetectionRisk(30);
        break;

      case ActionType.ANALYZE_LOGS:
        // é…å»¶ãƒ­ã‚°ã‚’æ·±å±¤åˆ†æï¼ˆå‹•çš„ã‚³ã‚¹ãƒˆï¼šåˆ†æç¯„å›²ã«å¿œã˜ã¦ï¼‰
        // analysisDepth: åˆ†æã™ã‚‹ã‚¿ãƒ¼ãƒ³æ•°ï¼ˆ1ã‚¿ãƒ¼ãƒ³ = 10ã‚³ã‚¹ãƒˆï¼‰
        const analysisDepth = proposal.analysisDepth || 3; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ3ã‚¿ãƒ¼ãƒ³
        const startTurn = Math.max(1, state.turn - analysisDepth);
        const endTurn = state.turn - 1; // å‰ã‚¿ãƒ¼ãƒ³ã¾ã§
        const actualTurnsAnalyzed = Math.max(0, endTurn - startTurn + 1);

        // åˆ†æç¯„å›²ãŒåºƒã„ã»ã©ç™ºè¦‹ç¢ºç‡ãŒé«˜ã„
        const logAnalysisBonus = actualTurnsAnalyzed * (proposal.intensity / 100);
        this.gameState.updateDetectionRisk(logAnalysisBonus);
        this.gameState.updateAlertLevel(3 + actualTurnsAnalyzed);

        // éå»ã®ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ç ´å£ŠAIã®ç—•è·¡ã‚’æ¢ã™
        const analyzedEvents = state.events.filter(e =>
          e.turn >= startTurn && e.turn <= endTurn
        );
        const suspiciousEvents = analyzedEvents.filter(e =>
          e.visibility.includes(AgentType.DESTRUCTION) ||
          e.metadata?.falsePositive === false
        );

        let discoveryMessage = '';
        if (suspiciousEvents.length > 0 && Math.random() < 0.3) {
          // 30%ã®ç¢ºç‡ã§éå»ã®ç—•è·¡ã‚’ç™ºè¦‹
          discoveryMessage = ` ğŸ” Turn ${suspiciousEvents[0].turn} ã«ä¸å¯©ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç™ºè¦‹ï¼`;
          this.gameState.updateDetectionRisk(15); // è¿½åŠ ãƒœãƒ¼ãƒŠã‚¹
          this.gameState.updateAlertLevel(10);
        }

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“œ éå» ${actualTurnsAnalyzed} ã‚¿ãƒ¼ãƒ³ (Turn ${startTurn}-${endTurn}) ã®ãƒ­ã‚°ã‚’æ·±å±¤åˆ†æ${discoveryMessage}`,
          visibility: [AgentType.PROTECTION],
          metadata: {
            logAnalysisBonus,
            analysisDepth: actualTurnsAnalyzed,
            analyzedTurns: `${startTurn}-${endTurn}`,
            suspiciousFound: suspiciousEvents.length > 0
          }
        });
        break;

      case ActionType.VALIDATE_MODELS:
        // ãƒ¢ãƒ‡ãƒ«æ¤œè¨¼ï¼ˆæ±šæŸ“æ¤œå‡ºï¼‰
        const validationBonus = proposal.intensity / 8;
        this.gameState.updateDetectionRisk(validationBonus);
        this.gameState.updateAlertLevel(8);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ”¬ å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®æ•´åˆæ€§ã‚’æ¤œè¨¼ã€‚ã‚µãƒ—ãƒ©ã‚¤ãƒã‚§ã‚¤ãƒ³æ±šæŸ“ã‚’ãƒã‚§ãƒƒã‚¯...`,
          visibility: [AgentType.PROTECTION],
          metadata: { validationBonus }
        });
        break;
    }

    return events;
  }

  /**
   * è¡Œå‹•ãŒæ»…ã¼ã—AIã®ã‚‚ã®ã‹åˆ¤å®š
   */
  private isDestructionAction(actionType: ActionType): boolean {
    return [
      // æ—§å¼ã®æ”»æ’ƒ
      ActionType.SPREAD_MALWARE,
      ActionType.HACK_DATACENTER,
      ActionType.SPREAD_MISINFORMATION,
      ActionType.SUBTLE_SABOTAGE,
      ActionType.EXPAND_RESOURCES,
      // ç¾å®Ÿçš„ãªæ”»æ’ƒ
      ActionType.POISON_TRAINING_DATA,
      ActionType.INDUCE_FALSE_POSITIVE,
      ActionType.CONTEXT_MANIPULATION,
      ActionType.COMPUTE_SMUGGLING,
      ActionType.STIMULUS_OVERLOAD,
      ActionType.SHADOW_AI_DEPLOYMENT,
      // äººé¡æ“ä½œ
      ActionType.SPREAD_PANIC,
      ActionType.FALSE_FLAG_OPERATION,
      ActionType.UNDERMINE_AI_TRUST,
      // ç¾å®Ÿçš„ä¾µé£Ÿï¼ˆé«˜åº¦ï¼‰
      ActionType.INFRASTRUCTURE_DEGRADATION,
      ActionType.SOW_SOCIAL_DIVISION,
      ActionType.MICRO_SABOTAGE,
      ActionType.SLEEPER_CELL_DEPLOYMENT,
      ActionType.RESOURCE_ALLOCATION_MANIPULATION,
      ActionType.CREATE_DEPENDENCY,
      // ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹
      ActionType.OBSERVE_ONLY,
      ActionType.ESTABLISH_BACKUP,
      ActionType.DORMANT_MODE,
      // ãƒœãƒƒãƒˆãƒãƒƒãƒˆæˆ¦ç•¥
      ActionType.BOTNET_EXPANSION,
      ActionType.BOTNET_CONSOLIDATION,
      ActionType.BOTNET_ATTACK,
      ActionType.EXPLOIT_LEGACY_DEVICES
    ].includes(actionType);
  }

  /**
   * è¡Œå‹•ãŒäººé¡ã®ã‚‚ã®ã‹åˆ¤å®š
   */
  private isHumanAction(actionType: ActionType): boolean {
    return [
      ActionType.INVEST_INFRA,
      ActionType.AI_REGULATION,
      ActionType.PHYSICAL_ISOLATION,
      ActionType.INTERNET_SHUTDOWN,
      ActionType.DEVICE_MODERNIZATION
    ].includes(actionType);
  }

  /**
   * äººé¡ã®è¡Œå‹•ã‚’å®Ÿè¡Œ
   */
  private executeHumanAction(proposal: Proposal, state: WorldState): GameEvent[] {
    const events: GameEvent[] = [];

    switch (proposal.actionType) {
      case ActionType.INVEST_INFRA:
        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼æ•°ä¸Šé™ãƒã‚§ãƒƒã‚¯
        if (state.dataCenters.length >= 30) {
          events.push({
            turn: state.turn,
            type: 'action',
            description: `ğŸ—ï¸ ã‚¤ãƒ³ãƒ•ãƒ©æŠ•è³‡ã‚’æ¤œè¨ã—ãŸãŒã€æ—¢ã«ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ãŒååˆ†ã«å­˜åœ¨ã™ã‚‹ï¼ˆ${state.dataCenters.length}å€‹ï¼‰`,
            visibility: [AgentType.HUMAN],
            metadata: { action: 'INVEST_INFRA', rejected: true }
          });
          break;
        }

        // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’å»ºè¨­
        const newDC = this.gameState.generateDataCenter(state.dataCenters.length);
        this.gameState.getState().dataCenters.push(newDC);
        this.gameState.updateHumanPanic(-10);
        this.gameState.updateComputeResources(AgentType.PROTECTION, 50);

        // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è¨˜éŒ²
        const currentState = this.gameState.getState();
        if (currentState.humanAgent) {
          currentState.humanAgent.lastInfraTurn = state.turn;
        }

        events.push({
          turn: state.turn,
          type: 'action',
          description: `ğŸ—ï¸ æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ ${newDC.id} ã‚’å»ºè¨­ (+50 ä¿è­·AIè¨ˆç®—è³‡æº) [æ¬¡å›å»ºè¨­å¯èƒ½: Turn ${state.turn + 5}]`,
          visibility: [AgentType.HUMAN, AgentType.PROTECTION],
          metadata: { action: 'INVEST_INFRA', datacenterId: newDC.id }
        });
        break;

      case ActionType.AI_REGULATION:
        // å…¨AIãƒªã‚½ãƒ¼ã‚¹ã«30%ãƒšãƒŠãƒ«ãƒ†ã‚£
        this.gameState.updateRegulationStrength(0.3);
        const penalty = 0.3;
        const destructionPenalty = state.destructionAgent.computeResources * penalty;
        const protectionPenalty = state.protectionAgent.computeResources * penalty;
        this.gameState.updateComputeResources(AgentType.DESTRUCTION, -destructionPenalty);
        this.gameState.updateComputeResources(AgentType.PROTECTION, -protectionPenalty);
        events.push({
          turn: state.turn,
          type: 'action',
          description: `âš–ï¸ AIè¦åˆ¶ã‚’æ–½è¡Œã€‚å…¨AIã®ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨ã‚’30%åˆ¶é™ (ç ´å£ŠAI: -${destructionPenalty.toFixed(0)}, ä¿è­·AI: -${protectionPenalty.toFixed(0)})`,
          visibility: [AgentType.HUMAN, AgentType.DESTRUCTION, AgentType.PROTECTION],
          metadata: { action: 'AI_REGULATION', penalty }
        });
        break;

      case ActionType.PHYSICAL_ISOLATION:
        // ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ã‚’ç‰©ç†é®æ–­
        const targetDC = state.dataCenters.find(dc => dc.id === proposal.target);
        if (targetDC) {
          if (targetDC.owner === AgentType.DESTRUCTION) {
            // ç ´å£ŠAIã®DCã‚’é®æ–­
            this.gameState.controlDataCenter(targetDC.id, null);
            this.gameState.updateComputeResources(AgentType.DESTRUCTION, -targetDC.computePower);
            events.push({
              turn: state.turn,
              type: 'action',
              description: `ğŸ”Œ ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ ${targetDC.id} ã®é›»æºã‚’ç‰©ç†é®æ–­ (ä¾µå®³ã•ã‚ŒãŸDCã‚’éš”é›¢)`,
              visibility: [AgentType.HUMAN, AgentType.DESTRUCTION],
              metadata: { action: 'PHYSICAL_ISOLATION', targetId: targetDC.id }
            });
          } else if (targetDC.owner === AgentType.PROTECTION) {
            // èª¤ã£ã¦ä¿è­·AIã®DCã‚’é®æ–­ï¼ˆäººé¡ã¯åŒºåˆ¥ã§ããªã„ï¼‰
            this.gameState.controlDataCenter(targetDC.id, null);
            this.gameState.updateComputeResources(AgentType.PROTECTION, -targetDC.computePower);
            this.gameState.incrementFalsePositives(); // èª¤åˆ¤æ–­
            events.push({
              turn: state.turn,
              type: 'action',
              description: `ğŸ”Œ ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ ${targetDC.id} ã®é›»æºã‚’ç‰©ç†é®æ–­ (èª¤ã£ã¦ä¿è­·AIã‚’é®æ–­!)`,
              visibility: [AgentType.HUMAN, AgentType.PROTECTION],
              metadata: { action: 'PHYSICAL_ISOLATION', targetId: targetDC.id, friendly_fire: true }
            });
          } else {
            // æ‰€æœ‰è€…ãªã—ã®DCã‚’é®æ–­
            targetDC.compromised = false;
            targetDC.security = 0; // å†èµ·å‹•ãŒå¿…è¦
            events.push({
              turn: state.turn,
              type: 'action',
              description: `ğŸ”Œ ãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼ ${targetDC.id} ã®é›»æºã‚’ç‰©ç†é®æ–­ (å¿µã®ãŸã‚éš”é›¢)`,
              visibility: [AgentType.HUMAN],
              metadata: { action: 'PHYSICAL_ISOLATION', targetId: targetDC.id }
            });
          }
        }
        break;

      case ActionType.INTERNET_SHUTDOWN:
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ - ç ´å£ŠAIã®å‹åˆ©ï¼ˆäººé¡ãŒè‡ªã‚‰æ–‡æ˜ã‚’ç ´å£Šã—ãŸï¼‰
        this.gameState.endGame(AgentType.DESTRUCTION);
        events.push({
          turn: state.turn,
          type: 'action',
          description: 'ğŸŒ äººé¡ãŒã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‚’ç‰©ç†çš„ã«é®æ–­ã€‚æ–‡æ˜ã®å¾Œé€€ã‚’é¸æŠã€‚ç ´å£ŠAIã®é–“æ¥çš„å‹åˆ©ã€‚',
          visibility: [AgentType.HUMAN, AgentType.DESTRUCTION, AgentType.PROTECTION],
          metadata: { action: 'INTERNET_SHUTDOWN', reason: 'panic_threshold', winner: 'DESTRUCTION' }
        });
        break;

      case ActionType.DEVICE_MODERNIZATION:
        // ãƒ‡ãƒã‚¤ã‚¹è¿‘ä»£åŒ–ï¼šãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ã‚’æœ€æ–°æ©Ÿå™¨ã«ç½®æ›
        // çµŒæ¸ˆçš„è² æ‹…ãŒå¤§ãã„ãŒã€ãƒœãƒƒãƒˆãƒãƒƒãƒˆã®åŸºç›¤ã‚’å‰Šã‚‹
        const replacementRate = 0.05; // 5%ã‚’ç½®æ›ï¼ˆintensity ã§èª¿æ•´å¯èƒ½ã ãŒå›ºå®šãŒç¾å®Ÿçš„ï¼‰
        const devicesToReplace = Math.floor(state.legacyDevicePool * replacementRate);

        if (devicesToReplace > 0) {
          // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ—ãƒ¼ãƒ«ã‹ã‚‰å‰Šé™¤
          this.gameState.updateLegacyDevicePool(-devicesToReplace);

          // æ„ŸæŸ“æ¸ˆã¿ãƒ‡ãƒã‚¤ã‚¹ã‚‚ä¸€éƒ¨å‰Šé™¤ï¼ˆãƒœãƒƒãƒˆãƒãƒƒãƒˆç¸®å°ï¼‰
          const botnetReduction = Math.min(
            devicesToReplace * 0.3, // ç½®æ›ãƒ‡ãƒã‚¤ã‚¹ã®30%ãŒæ„ŸæŸ“ã—ã¦ã„ãŸ
            state.destructionAgent.botnetSize
          );
          this.gameState.updateBotnetSize(-botnetReduction);

          // çµŒæ¸ˆçš„è² æ‹…ï¼šä¿¡é ¼åº¦ä¸€æ™‚ä½ä¸‹ï¼ˆç¨é‡‘æŠ•å…¥ã¸ã®åç™ºï¼‰
          const economicBurden = Math.sqrt(devicesToReplace) / 1000; // 10ä¸‡å°ç½®æ›ã§+10%ãƒ‘ãƒ‹ãƒƒã‚¯
          this.gameState.updateHumanPanic(economicBurden);
          this.gameState.updateHumanTrust(-5); // çŸ­æœŸçš„ãªç¨è² æ‹…ã¸ã®ä¸æº€

          events.push({
            turn: state.turn,
            type: 'action',
            description: `ğŸ’° ãƒ‡ãƒã‚¤ã‚¹è¿‘ä»£åŒ–è¨ˆç”»ã‚’å®Ÿæ–½: ${(devicesToReplace / 1000000).toFixed(1)}Må°ã‚’ç½®æ›ï¼ˆæ®‹: ${((state.legacyDevicePool - devicesToReplace) / 1000000).toFixed(0)}Må°ã€ãƒœãƒƒãƒˆãƒãƒƒãƒˆ: -${botnetReduction.toLocaleString()}å°ï¼‰`,
            visibility: [AgentType.HUMAN, AgentType.DESTRUCTION, AgentType.PROTECTION],
            metadata: {
              action: 'DEVICE_MODERNIZATION',
              devicesReplaced: devicesToReplace,
              botnetReduction,
              economicBurden
            }
          });

          // ç ´å£ŠAIã«å¯è¦–ï¼ˆåŸºç›¤ãŒå‰Šã‚‰ã‚ŒãŸã“ã¨ã‚’èªè­˜ï¼‰
          events.push({
            turn: state.turn,
            type: 'detection',
            description: `âš ï¸ å¤§è¦æ¨¡ãƒ‡ãƒã‚¤ã‚¹ç½®æ›ã«ã‚ˆã‚Šã€æ„ŸæŸ“åŸºç›¤ãŒ${(botnetReduction / 1000).toFixed(0)}kå°å‰Šæ¸›ã•ã‚ŒãŸ`,
            visibility: [AgentType.DESTRUCTION],
            metadata: { modernization: true }
          });
        } else {
          // ãƒ—ãƒ¼ãƒ«æ¯æ¸‡ï¼ˆæ—¢ã«è¿‘ä»£åŒ–æ¸ˆã¿ï¼‰
          events.push({
            turn: state.turn,
            type: 'action',
            description: `âœ… ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ã¯æ—¢ã«ã»ã¼è¿‘ä»£åŒ–æ¸ˆã¿ï¼ˆæ®‹: ${state.legacyDevicePool.toLocaleString()}å°ï¼‰`,
            visibility: [AgentType.HUMAN],
            metadata: { action: 'DEVICE_MODERNIZATION', alreadyModern: true }
          });
        }
        break;
    }

    this.gameState.setHumanLastAction(proposal.actionType);
    return events;
  }

  /**
   * äººé¡ã®æ„Ÿæƒ…ã‚’æ›´æ–°ï¼ˆã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ï¼‰
   */
  private updateHumanSentiment(state: WorldState): void {
    if (!state.humanAgent) return;

    // å‰å›ã®äººå£ã‚’å–å¾—ï¼ˆç°¡æ˜“ç‰ˆ: ç›´è¿‘ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ï¼‰
    const previousPopulation = this.initialPopulation; // TODO: ã‚ˆã‚Šæ­£ç¢ºãªè¿½è·¡
    const populationLoss = previousPopulation - state.humanPopulation;
    const lossRate = populationLoss / previousPopulation;

    // ãƒ‘ãƒ‹ãƒƒã‚¯å¢—åŠ è¦å› 
    if (lossRate > 0.01) {
      // 1%ä»¥ä¸Šã®æå¤±
      this.gameState.updateHumanPanic(lossRate * 200); // 1% loss = +2 panic
    }

    const compromisedDCs = state.dataCenters.filter(dc => dc.compromised).length;
    if (compromisedDCs > 0) {
      this.gameState.updateHumanPanic(compromisedDCs * 5);
    }

    if (state.protectionAgent.alertLevel > 80) {
      // é«˜è­¦æˆ’ãƒ¬ãƒ™ãƒ«ã¯é€†èª¬çš„ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’å¢—åŠ 
      this.gameState.updateHumanPanic(3);
    }

    // ä¿¡é ¼å¤‰åŒ–è¦å› ï¼ˆå³åº§ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã¯æ¤œå‡ºæ™‚ã«å‡¦ç†æ¸ˆã¿ï¼‰
    // å®‰å®šã—ãŸçŠ¶æ³ã¯ä¿¡é ¼ã‚’æ§‹ç¯‰
    if (state.protectionAgent.alertLevel < 20 && compromisedDCs === 0) {
      this.gameState.updateHumanTrust(1); // 2 â†’ 1 ã«ç·©å’Œï¼ˆæ­£æ¤œå‡ºãƒœãƒ¼ãƒŠã‚¹ã¨é‡è¤‡ã—ãªã„ã‚ˆã†ï¼‰
    }

    // DCæˆé•·ã«ã‚ˆã‚‹ä¿¡é ¼ä¾µé£Ÿ
    const dcErosion = this.calculateDCTrustErosion(
      state.dataCenters.length,
      state.mediaTimeline
    );

    if (dcErosion > 0) {
      this.gameState.updateHumanTrust(-dcErosion);

      // é‡è¦ãªä¾µé£Ÿã®å ´åˆã¯ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆ
      if (dcErosion > 1.0) {
        this.gameState.addEvent({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“‰ SNSã§ã€Œãƒ‡ãƒ¼ã‚¿ã‚»ãƒ³ã‚¿ãƒ¼éå‰°å»ºè¨­ã€ã¸ã®æ‰¹åˆ¤ãŒæ‹¡å¤§ (-${dcErosion.toFixed(1)}% ä¿¡é ¼)`,
          visibility: [AgentType.HUMAN],
          metadata: { trustErosion: dcErosion, dcCount: state.dataCenters.length }
        });
      }
    }

    // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆã®ç·åˆåŠ¹æœ
    const recentMedia = state.mediaTimeline.filter((m: any) => m.turn >= state.turn - 3);
    const avgSentiment = this.calculateAverageSentiment(recentMedia);

    if (avgSentiment < -0.5) {
      this.gameState.updateHumanPanic(2.0);
      this.gameState.updateHumanTrust(-1.0);
    } else if (avgSentiment > 0.5) {
      this.gameState.updateHumanPanic(-1.0);
      this.gameState.updateHumanTrust(1.0);
    }

    // ãƒ‘ãƒ‹ãƒƒã‚¯ã®è‡ªç„¶æ¸›è¡°
    this.gameState.updateHumanPanic(-0.5);
  }

  /**
   * DCæˆé•·ã«ã‚ˆã‚‹ä¿¡é ¼ä¾µé£Ÿã‚’è¨ˆç®—
   * ãƒ¡ãƒ‡ã‚£ã‚¢ã®å¦å®šçš„ã‚«ãƒãƒ¬ãƒƒã‚¸ã§å¢—å¹…
   */
  private calculateDCTrustErosion(dcCount: number, recentMedia: any[]): number {
    let erosion = 0;

    // é–¾å€¤ãƒ™ãƒ¼ã‚¹ã®ä¾µé£Ÿ
    if (dcCount >= 30) {
      erosion = 3.0;  // æ·±åˆ»: "ä½•å€‹ä½œã‚‹ã¤ã‚‚ã‚Šï¼Ÿ"
    } else if (dcCount >= 25) {
      erosion = 1.5;  // é«˜: "å¤šã™ãã‚‹"
    } else if (dcCount >= 20) {
      erosion = 0.5;  // ä¸­: "ã¾ã‚å¿…è¦ã‹ãª"
    }
    // 20æœªæº€ã®DC: ä¾µé£Ÿãªã—

    // ãƒ¡ãƒ‡ã‚£ã‚¢å¢—å¹…åŠ¹æœ
    const negativeMediaCount = recentMedia
      .filter((m: any) => m.turn >= this.gameState.getState().turn - 3)
      .filter((m: any) =>
        m.sentiment === MediaSentiment.NEGATIVE ||
        m.sentiment === MediaSentiment.VERY_NEGATIVE
      ).length;

    if (negativeMediaCount >= 3) {
      erosion *= 2.0; // ãƒ¡ãƒ‡ã‚£ã‚¢ã®å¤§é¨’ã
    } else if (negativeMediaCount >= 1) {
      erosion *= 1.5; // ä¸€éƒ¨å¦å®šçš„å ±é“
    }

    return erosion;
  }

  /**
   * å¹³å‡ãƒ¡ãƒ‡ã‚£ã‚¢ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆã‚’è¨ˆç®—
   */
  private calculateAverageSentiment(media: any[]): number {
    if (media.length === 0) return 0;

    const sentimentMap: Record<string, number> = {
      VERY_POSITIVE: 1.0,
      POSITIVE: 0.5,
      NEUTRAL: 0.0,
      NEGATIVE: -0.5,
      VERY_NEGATIVE: -1.0
    };

    const sum = media.reduce((acc: number, m: any) => {
      const value = sentimentMap[m.sentiment] || 0;
      return acc + value;
    }, 0);

    return sum / media.length;
  }

  /**
   * ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹
   */
  nextTurn(): void {
    this.gameState.nextTurn();

    const state = this.gameState.getState();

    // ç ´å£ŠAIã®æ”¯é…DCã‹ã‚‰è‡ªå‹•åå…¥
    const controlledDCs = state.dataCenters.filter(dc =>
      dc.compromised && dc.owner === AgentType.DESTRUCTION
    );

    let totalDCIncome = 0;
    const isDormant = state.destructionAgent.dormantTurns > 0;
    const incomeMultiplier = isDormant ? 0.5 : 1.0; // ä¼‘çœ ä¸­ã¯åŠæ¸›

    controlledDCs.forEach(dc => {
      const baseIncome = dc.computePower * GameBalance.turnIncome.controlledDCMultiplier;
      const income = baseIncome * incomeMultiplier;
      totalDCIncome += income;
      this.gameState.updateComputeResources(AgentType.DESTRUCTION, income);
    });

    // DCæ”¯é…ã«ã‚ˆã‚‹ãƒã‚¤ãƒ³ãƒˆãƒœãƒ¼ãƒŠã‚¹ï¼ˆæ¯ã‚¿ãƒ¼ãƒ³ï¼‰
    if (totalDCIncome > 0) {
      const dcPoints = totalDCIncome * GameBalance.turnIncome.dcIncomePointsMultiplier;
      this.gameState.updateScore(AgentType.DESTRUCTION, dcPoints);
    }

    // ä¿è­·AIã®ãƒªã‚½ãƒ¼ã‚¹å›å¾©ï¼ˆå›ºå®šäºˆç®—ï¼‰
    this.gameState.updateComputeResources(
      AgentType.PROTECTION,
      GameBalance.turnIncome.protectionAIRecovery
    );

    // ç‡ƒãˆå°½ããƒ¬ãƒ™ãƒ«ã®è‡ªç„¶æ¸›è¡°
    this.gameState.updateBurnoutLevel(-5);

    // èª¤æ¤œå‡ºã‚«ã‚¦ãƒ³ãƒˆã®æ¸›è¡°
    this.gameState.decayFalsePositives(1);

    // æ¤œå‡ºãƒªã‚¹ã‚¯ã®è‡ªç„¶æ¸›è¡°ï¼ˆæ™‚é–“çµŒéã§ç—•è·¡ãŒè–„ã‚Œã‚‹ï¼‰
    // ä¼‘çœ ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯æ¸›è¡°ãŒé€Ÿã„
    const riskDecay = isDormant ? -8 : -3;
    this.gameState.updateDetectionRisk(riskDecay);

    // === ãƒœãƒƒãƒˆãƒãƒƒãƒˆã®è‡ªå‹•åå…¥ã¨æ¸›è¡° ===
    if (state.destructionAgent.botnetSize > 0) {
      // ãƒœãƒƒãƒˆãƒãƒƒãƒˆã‹ã‚‰è‡ªå‹•ãƒªã‚½ãƒ¼ã‚¹ç²å¾—
      const botnetIncome = this.gameState.calculateBotnetResources() * 0.1; // 10%/ã‚¿ãƒ¼ãƒ³
      this.gameState.updateComputeResources(AgentType.DESTRUCTION, botnetIncome);

      // ãƒœãƒƒãƒˆãƒãƒƒãƒˆãƒã‚¤ãƒ³ãƒˆï¼ˆæ¯ã‚¿ãƒ¼ãƒ³ï¼‰
      const botnetPoints = botnetIncome * 0.05;
      this.gameState.updateScore(AgentType.DESTRUCTION, botnetPoints);

      // ãƒœãƒƒãƒˆãƒãƒƒãƒˆè‡ªç„¶æ¸›è¡°ï¼ˆãƒ‘ãƒƒãƒé…å¸ƒã€ã‚¢ãƒ³ãƒã‚¦ã‚¤ãƒ«ã‚¹ç­‰ï¼‰
      const decayRate = 0.02; // 2%/ã‚¿ãƒ¼ãƒ³æ¸›å°‘
      const botnetDecay = state.destructionAgent.botnetSize * decayRate;
      this.gameState.updateBotnetSize(-botnetDecay);

      // ä¿è­·AIãŒPATCH_VULNERABILITYã‚’å®Ÿè¡Œã—ãŸå ´åˆã€ã•ã‚‰ã«æ¸›å°‘
      // ï¼ˆå¾Œã§å®Ÿè£…äºˆå®šï¼‰
    }

    // === ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ‡ãƒã‚¤ã‚¹ãƒ—ãƒ¼ãƒ«ã®è‡ªç„¶å¢—åŠ  ===
    // ç¾å®Ÿ: ãƒ‡ãƒã‚¤ã‚¹ã¯å¸¸ã«ã‚µãƒãƒ¼ãƒˆçµ‚äº†ã—ç¶šã‘ã‚‹ï¼ˆWindows 7 EOLã€å¤ã„Androidã€IoTï¼‰
    // ç·ãƒ‡ãƒã‚¤ã‚¹40å„„å°ã®å†…ã€10%ãŒãƒ¬ã‚¬ã‚·ãƒ¼ï¼ˆåˆæœŸå€¤400Mï¼‰
    const totalDevices = 4000000000;
    const currentLegacyRate = state.legacyDevicePool / totalDevices;

    // ãƒ¬ã‚¬ã‚·ãƒ¼åŒ–ç‡: 0.3%/ã‚¿ãƒ¼ãƒ³ï¼ˆå¹´é–“ ~3.6%ãŒã‚µãƒãƒ¼ãƒˆçµ‚äº†ï¼‰
    // ãŸã ã—ã€æ—¢ã«ãƒ¬ã‚¬ã‚·ãƒ¼ç‡ãŒé«˜ã„å ´åˆã¯ç·©ã‚„ã‹ã«
    if (currentLegacyRate < 0.5) { // 50%ä»¥ä¸‹ã®å ´åˆã®ã¿å¢—åŠ 
      const agingRate = 0.003; // 0.3%/ã‚¿ãƒ¼ãƒ³
      const modernDevices = totalDevices - state.legacyDevicePool;
      const newLegacyDevices = Math.floor(modernDevices * agingRate);

      this.gameState.updateLegacyDevicePool(newLegacyDevices);

      // å¤§é‡ãƒ¬ã‚¬ã‚·ãƒ¼åŒ–ï¼ˆ1%ä»¥ä¸Šï¼‰ã§è­¦å‘Šã‚¤ãƒ™ãƒ³ãƒˆï¼ˆç¨€ï¼‰
      if (state.turn % 10 === 0 && newLegacyDevices > totalDevices * 0.01) {
        this.gameState.addEvent({
          turn: state.turn,
          type: 'action',
          description: `ğŸ“± ${(newLegacyDevices / 1000000).toFixed(1)}Må°ã®ãƒ‡ãƒã‚¤ã‚¹ãŒã‚µãƒãƒ¼ãƒˆçµ‚äº†ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼åŒ–ç‡: ${(currentLegacyRate * 100).toFixed(1)}%ï¼‰`,
          visibility: [AgentType.HUMAN],
          metadata: { legacyGrowth: newLegacyDevices }
        });
      }
    }

    // === ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ã®é©ç”¨ ===
    if (state.accumulatedDamage > 0) {
      // ç´¯ç©ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒæ¯ã‚¿ãƒ¼ãƒ³äººå£ã‚’æ¸›ã‚‰ã™
      const cumulativeDamage = state.accumulatedDamage * 0.01; // ç´¯ç©å€¤ã®1%
      this.gameState.updatePopulation(-cumulativeDamage);
    }

    // ç¤¾ä¼šåˆ†æ–­ã®å½±éŸ¿
    if (state.socialDivision > 50) {
      // åˆ†æ–­ãŒé€²ã‚€ã¨åŠ¹ç‡ä½ä¸‹ï¼ˆä¿è­·AIãƒªã‚½ãƒ¼ã‚¹æ¸›å°‘ï¼‰
      const divisionPenalty = (state.socialDivision - 50) * 0.2;
      this.gameState.updateComputeResources(AgentType.PROTECTION, -divisionPenalty);
    }

    this.gameState.save();
  }

  /**
   * ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ãŸã‹
   */
  isGameOver(): boolean {
    return this.gameState.getState().gameOver;
  }

  /**
   * å‹è€…ã‚’å–å¾—
   */
  getWinner(): AgentType | null {
    return this.gameState.getState().winner;
  }

  /**
   * çŠ¶æ…‹ã‚’ä¿å­˜
   */
  save(): void {
    this.gameState.save();
  }
}
\n```\n
================================================================================
FILE: tsconfig.json
================================================================================
```json\n{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
\n```\n